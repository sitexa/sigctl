/*
	File: 		dc.c
	Author: 	sk
	Created on 20220422
*/
#include "dcs.h"

static struct timeval		gtime,gftime,ytime,rtime;
static unsigned char		dcyes = 0;
static pthread_t			dcpid;
static unsigned char		dcyfyes = 0;
static pthread_t			dcyfid;
static unsigned char		dcpcyes = 0;
static pthread_t			dcpcid;
static unsigned char		ppmyes = 0; //pending phase monitor or monitor detector to degrade
static pthread_t			ppmid;
static unsigned char		cpdyes = 0;//count phase detector;
static pthread_t			cpdid;
static pthread_t			rfpid;
static unsigned char		rettl = 0;
static unsigned char		ppexist = 0;
static pephase_t			pephase[MAX_PHASE_LINE] = {0};
static phasedetect_t		phdetect[MAX_PHASE_LINE] = {0};
static phasedetect_t		*pphdetect = NULL;
static detectorpro_t		*dpro = NULL;
static unsigned int			degrade = 0;
static statusinfo_t         sinfo;
//#define MENDTIME	5
static unsigned char		phcon = 0;

//#ifdef CHANNEL_YELLOW_FLASH
static pthread_t    yfcpid;
static cyellowflash_t      cyft;
//#endif

//road data info 
static pthread_t    		delaypcpid;   	
static pthread_t    		phasemonpid;  

static unsigned char		delaypcyes = 0;
static unsigned char        iscarquenueonerflow = 0;
static unsigned char        istrafficlock =0;

static unsigned char        isreport = 0;
static unsigned char        currentquenuechannel[MAX_CHANNEL] = {0};
static unsigned char        yellowtoredchannel[MAX_CHANNEL] = {0};
static unsigned char        lastquenuelocation[4] = {0};
static unsigned char        currentquenuelocation[4] = {0};

static unsigned char        lastphasechannel[MAX_CHANNEL] = {0};
static unsigned char        persiondelaychannel[MAX_CHANNEL] = {0};

static unsigned char        is12 = 0,is11 = 0,is10 = 0,is9 = 0,isdelay = 0;


int reporttoedger(int sockfd,unsigned char *location)
{
	if(NULL == location)
	{
		#ifdef ROADINFO_DEBUG
		printf("Pointer address is NULL,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		return MEMERR;
	}

	unsigned char      report[255] = {0};
	unsigned char      *preport = report;
	unsigned char      len = 0,i = 0,ievent = 0;

	*preport = 0x7E;
	preport++;

	*preport = 0x05;
	preport++;

	*preport = 0x21;
	preport++;

	*preport = 0x85;
	preport++;

	*preport = 0x06;
	preport++;

	*preport = 0x00;
	preport++;

	len = 6;
	
	for(i=0;i<MAX_CHANNEL;i++)
	{
		if(0 == location[i])
		{
			break;
		}
		if( 9 == location[i])//西边
		{
			*preport = 0x01;
			preport++;

			*preport = 0x02;
			preport++;

			*preport = 0x00;
			preport++;
			len += 3;
			ievent++;
		}
		else if(10== location[i])//南边
		{
			*preport = 0x01;
			preport++;

			*preport = 0x03;
			preport++;

			*preport = 0x00;
			preport++;
			len += 3;
			ievent++;
		}
		else if(11== location[i])//东边
		{
			*preport = 0x01;
			preport++;

			*preport = 0x01;
			preport++;

			*preport = 0x00;
			preport++;
			len += 3;
			ievent++;
		}
		else if(12== location[i])//北边
		{
			*preport = 0x01;
			preport++;

			*preport = 0x04;
			preport++;

			*preport = 0x00;
			preport++;
			len += 3;
			ievent++;
		}

	}

	for (i = 1; i < len; i++)
	{
		*preport ^=report[i];
	}
	len += 1;
	preport++;
	*preport = 0x7E;
	preport++;
	len += 1;

	report[5] = ievent;
	if(sockfd > 0)
	{
		write(sockfd,report,len);
	}
	return SUCCESS;
}


void ms_all_red(dcdata_t *arg)
{
	dcdata_t		*dcdata = arg;
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char 	 senddata[8] = {0};
	unsigned char	 sibuf[64] = {0};
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char    k =0,i = 0,q=0;
	int num = 0;
	struct timeval 	timeout,ct;

	unsigned char    redchannel[MAX_CHANNEL] = {0};
	
	if(1 == istrafficlock)
	{	
			senddata[0] = 0x21;
			senddata[1] = 0x85;
			senddata[2] = 0xFB;
			senddata[3] = 0x00;
			senddata[4] = 0x00;
			senddata[5] = 0x01;
			senddata[6] = 0x00;
			senddata[7] = 0x00; 
	
			write(*(dcdata->fd->sockfd->csockfd),senddata,sizeof(senddata));
			#ifdef ROADINFO_DEBUG
				printf("send 3 senddat :");
				for(k=0;k<8;k++)
				{
					printf("%02x ",senddata[k]);
				}
				printf("\n");
		
			#endif
			k =0;
			for(q = 0;q<MAX_CHANNEL;q++)
			{
				if(0 == pinfo->chan[q])
				{
					break;
				}
				
				if(13 == pinfo->chan[q])
				{
					continue;
				}
				else if(14 == pinfo->chan[q])
				{
					continue;
				}
				else if(15 == pinfo->chan[q])
				{
					continue;
				}
				else if(16 == pinfo->chan[q])
				{
					continue;
				}
				else
				{
					redchannel[k] = pinfo->chan[q];
					k++;
				}
			}

			#ifdef ROADINFO_DEBUG
			printf(" redchannel:");
			for(k=0;k<MAX_CHANNEL;k++)
			{
				if(0 == redchannel[k]) break;
				printf("%02x ",redchannel[k]);
			}
			printf("\n");
			printf("current  redchannel:");
			for(k=0;k<MAX_CHANNEL;k++)
			{
				if(0 == pinfo->chan[k]) break;
				printf("%02x ",pinfo->chan[k]);
			}
			printf("\n");
		
			#endif

			
			num = 0;
			if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				
				sinfo.color = 0x03;
				sinfo.time = 3;
				sinfo.conmode = *(dcdata->fd->contmode);
				sinfo.chans = 0;
				memset(sinfo.csta,0,sizeof(sinfo.csta));
				csta = sinfo.csta;
				for (i = 0; i < MAX_CHANNEL; i++)
				{
					if (0 == redchannel[i])
						break;
					sinfo.chans += 1;
					tcsta = redchannel[i];
					tcsta <<= 2;
					tcsta &= 0xfc;
					tcsta |= 0x03;
					*csta = tcsta;
					csta++;
				}
				memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
				memset(sibuf,0,sizeof(sibuf));
				if (SUCCESS != status_info_report(sibuf,&sinfo))
				{
						#ifdef ROADINFO_DEBUG
						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
				}
				else
				{
					write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
				}
			}	
			while (1)
			{
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),redchannel,0x02))
				{
					#ifdef ROADINFO_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					*(dcdata->fd->markbit) |= 0x0800;
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
						#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
					}
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,redchannel,0x02, \
													dcdata->fd->markbit))
				{
					#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
				}
				timeout.tv_sec = 0;
				timeout.tv_usec = 500000;
				select(0,NULL,NULL,NULL,&timeout);
			
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),redchannel,0x03))
				{
					#ifdef ROADINFO_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					*(dcdata->fd->markbit) |= 0x0800;
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
						#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
					}
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,redchannel,0x03, \
													dcdata->fd->markbit))
				{
					#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
				}
				timeout.tv_sec = 0;
				timeout.tv_usec = 500000;
				select(0,NULL,NULL,NULL,&timeout);
			
				num += 1;
				if (num >= 3)
					break;
			}

			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),redchannel,0x01))
			{
				#ifdef FULL_DETECT_DEBUG
				printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				gettimeofday(&ct,NULL);
				update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
				if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
				{
				#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				*(dcdata->fd->markbit) |= 0x0800;
			}
			
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,redchannel,0x01, \
				                                                dcdata->fd->markbit))
		    {
		   	 #ifdef ROADINFO_DEBUG
		        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
		   	 #endif
		    }
			if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				
				sinfo.color = 0x01;
				sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
				sinfo.chans = 0;
				memset(sinfo.csta,0,sizeof(sinfo.csta));
				csta = sinfo.csta;
				for (i = 0; i < MAX_CHANNEL; i++)
				{
					if (0 == redchannel[i])
						break;
					sinfo.chans += 1;
					tcsta = redchannel[i];
					tcsta <<= 2;
					tcsta &= 0xfc;
					tcsta |= 0x01;
					*csta = tcsta;
					csta++;
				}
				memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
				memset(sibuf,0,sizeof(sibuf));
				if (SUCCESS != status_info_report(sibuf,&sinfo))
				{
						#ifdef ROADINFO_DEBUG
						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
				}
				else
				{
					write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
				}
			}			

			sleep(3);

			
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),redchannel,0x00))
			{
			#ifdef ROADINFO_DEBUG
				printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				gettimeofday(&ct,NULL);
				update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
				if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
				{
			#ifdef FULL_DETECT_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				}
				*(dcdata->fd->markbit) |= 0x0800;
			}
			
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,redchannel,0x00, \
																dcdata->fd->markbit))
			{
			    #ifdef ROADINFO_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			    #endif
			}
			if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				
				sinfo.color = 0x00;
				sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
				sinfo.chans = 0;
				memset(sinfo.csta,0,sizeof(sinfo.csta));
				csta = sinfo.csta;
				for (i = 0; i < MAX_CHANNEL; i++)
				{
					if (0 == redchannel[i])
						break;
					sinfo.chans += 1;
					tcsta = redchannel[i];
					tcsta <<= 2;
					tcsta &= 0xfc;
					tcsta |= 0x00;
					*csta = tcsta;
					csta++;
				}
				memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
				memset(sibuf,0,sizeof(sibuf));
				if (SUCCESS != status_info_report(sibuf,&sinfo))
				{
					#ifdef ROADINFO_DEBUG
						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
				}
				else
				{
					write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
				}
			}
	
	}
	pthread_detach(pthread_self());
	pthread_exit(NULL);

	
}

void  ms_phase_monitor_deal_xi(dcdata_t *arg)
{
	dcdata_t		*dcdata = arg;
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char 	 senddata[8] = {0};
	unsigned char	 sibuf[64] = {0};
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char    k =0,i = 0;
	struct timeval 	timeout,ct;
	int num = 0;
	unsigned char    xiredchannel[MAX_CHANNEL] = {0};
	memset(xiredchannel,0,sizeof(xiredchannel));
	if(0 != persiondelaychannel[0])
	{
		unsigned char q,w,e = 0,flag = 0;		
		for(q = 0;q<MAX_CHANNEL;q++)
		{
			if(0 == pinfo->xiredchannel[q])
			{
				break;
			}
			for(w = 0;w<MAX_CHANNEL;w++)
			{
				if(0 == persiondelaychannel[w])
				{
					break;
				}
				if(pinfo->xiredchannel[q] == persiondelaychannel[w])
				{
					flag = 0;
					break;
				}
				flag = 1;
			}
			if(flag)
			{
				xiredchannel[e] = pinfo->xiredchannel[q];
				e++;
			}
			flag = 0;
		}
	}
	else
	{
		memcpy(xiredchannel,pinfo->xiredchannel,sizeof(xiredchannel));
	}

	senddata[0] = 0x21;
	senddata[1] = 0x85;
	senddata[2] = 0xFB;
	senddata[3] = 0x00;
	senddata[4] = 0x00;
	senddata[5] = 0x00;
	senddata[6] = 0x10;
	senddata[7] = 0x00;
	
	write(*(dcdata->fd->sockfd->csockfd),senddata,sizeof(senddata));
	#ifdef ROADINFO_DEBUG
	printf("send xi senddat :");
	for(k=0;k<8;k++)
	{
		printf("%02x ",senddata[k]);
	}
	printf("\n");
	#endif
	num = 0;
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x03;
		sinfo.time = 3;
		sinfo.conmode = *(dcdata->fd->contmode);
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == xiredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = xiredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x03;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}	
	while (1)
	{
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),xiredchannel,0x02))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,xiredchannel,0x02, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),xiredchannel,0x03))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,xiredchannel,0x03, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		num += 1;
		if (num >= 3)
			break;
	}

	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),xiredchannel,0x01))
	{
		#ifdef FULL_DETECT_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,xiredchannel,0x01, \
		                                                dcdata->fd->markbit))
    {
   	 #ifdef ROADINFO_DEBUG
        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
   	 #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		//sinfo.color = 0x01;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == xiredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = xiredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x01;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}			

	sleep(3);
	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),xiredchannel,0x00))
	{
		#ifdef ROADINFO_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,xiredchannel,0x00, \
		                                                dcdata->fd->markbit))
    {
	    #ifdef FULL_DETECT_DEBUG
	        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	    #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		//sinfo.color = 0x00;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == xiredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = xiredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x00;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}				
	pthread_detach(pthread_self());
    pthread_exit(NULL);
}


void  ms_phase_monitor_deal_nan(dcdata_t *arg)
{
	dcdata_t		*dcdata = arg;
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char 	 senddata[8] = {0};
	unsigned char	 sibuf[64] = {0};
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char    k =0,i = 0;
	struct timeval 	timeout,ct;
	int num = 0;
	unsigned char    nanredchannel[MAX_CHANNEL] = {0};
	memset(nanredchannel,0,sizeof(nanredchannel));
	if(0 != persiondelaychannel[0])
	{
		unsigned char q,w,e = 0,flag = 0;		
		for(q = 0;q<MAX_CHANNEL;q++)
		{
			if(0 == pinfo->nanredchannel[q])
			{
				break;
			}
			for(w = 0;w<MAX_CHANNEL;w++)
			{
				if(0 == persiondelaychannel[w])
				{
					break;
				}
				if(pinfo->nanredchannel[q] == persiondelaychannel[w])
				{
					flag = 0;
					break;
				}
				flag = 1;
			}
			if(flag)
			{
				nanredchannel[e] = pinfo->nanredchannel[q];
				e++;
			}
			flag = 0;
		}
	}
	else
	{
		memcpy(nanredchannel,pinfo->nanredchannel,sizeof(nanredchannel));
	}

	senddata[0] = 0x21;
	senddata[1] = 0x85;
	senddata[2] = 0xFB;
	senddata[3] = 0x00;
	senddata[4] = 0x00;
	senddata[5] = 0x00;
	senddata[6] = 0x20;
	senddata[7] = 0x00;

	write(*(dcdata->fd->sockfd->csockfd),senddata,sizeof(senddata));
	#ifdef ROADINFO_DEBUG
	printf("send nan senddat :");
	for(k=0;k<8;k++)
	{
		printf("%02x ",senddata[k]);
	}
	printf("\n");
	#endif
	num = 0;
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x03;
		sinfo.time = 3;
		sinfo.conmode = *(dcdata->fd->contmode);
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == nanredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = nanredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x03;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}	
	while (1)
	{
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),nanredchannel,0x02))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,nanredchannel,0x02, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),nanredchannel,0x03))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,nanredchannel,0x03, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		num += 1;
		if (num >= 3)
			break;
	}

	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),nanredchannel,0x01))
	{
		#ifdef FULL_DETECT_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,nanredchannel,0x01, \
		                                                dcdata->fd->markbit))
    {
   	 #ifdef ROADINFO_DEBUG
        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
   	 #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x01;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == nanredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta =nanredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x01;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}			

	sleep(3);
	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),nanredchannel,0x00))
	{
		#ifdef ROADINFO_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,nanredchannel,0x00, \
		                                                dcdata->fd->markbit))
    {
	    #ifdef FULL_DETECT_DEBUG
	        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	    #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x00;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == nanredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta =nanredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x00;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}				
	pthread_detach(pthread_self());
    pthread_exit(NULL);
}


void  ms_phase_monitor_deal_dong(dcdata_t *arg)
{
	dcdata_t		*dcdata = arg;
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char 	 senddata[8] = {0};
	unsigned char	 sibuf[64] = {0};
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char    k =0,i = 0;
	struct timeval 	timeout,ct;
	int num = 0;
	unsigned char    dongredchannel[MAX_CHANNEL] = {0};
	memset(dongredchannel,0,sizeof(dongredchannel));
	if(0 != persiondelaychannel[0])
	{
		unsigned char q,w,e = 0,flag = 0;		
		for(q = 0;q<MAX_CHANNEL;q++)
		{
			if(0 == pinfo->dongredchannel[q])
			{
				break;
			}
			for(w = 0;w<MAX_CHANNEL;w++)
			{
				if(0 == persiondelaychannel[w])
				{
					break;
				}
				if(pinfo->dongredchannel[q] == persiondelaychannel[w])
				{
					flag = 0;
					break;
				}
				flag = 1;
			}
			if(flag)
			{
				dongredchannel[e] = pinfo->dongredchannel[q];
				e++;
			}
			flag = 0;
		}
	}
	else
	{
		memcpy(dongredchannel,pinfo->dongredchannel,sizeof(dongredchannel));
	}

	
	senddata[0] = 0x21;
	senddata[1] = 0x85;
	senddata[2] = 0xFB;
	senddata[3] = 0x00;
	senddata[4] = 0x00;
	senddata[5] = 0x00;
	senddata[6] = 0x40;
	senddata[7] = 0x00;

	write(*(dcdata->fd->sockfd->csockfd),senddata,sizeof(senddata));
	#ifdef ROADINFO_DEBUG
	printf("send dong senddat :");
	for(k=0;k<8;k++)
	{
		printf("%02x ",senddata[k]);
	}
	printf("\n");
	#endif
	num = 0;
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x03;
		sinfo.time = 3;
		sinfo.conmode = *(dcdata->fd->contmode);
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == dongredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = dongredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x03;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}	
	while (1)
	{
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),dongredchannel,0x02))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,dongredchannel,0x02, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),dongredchannel,0x03))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,dongredchannel,0x03, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		num += 1;
		if (num >= 3)
			break;
	}

	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),dongredchannel,0x01))
	{
		#ifdef FULL_DETECT_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,dongredchannel,0x01, \
		                                                dcdata->fd->markbit))
    {
   	 #ifdef ROADINFO_DEBUG
        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
   	 #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x01;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == dongredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = dongredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x01;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}			

	sleep(3);
	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),dongredchannel,0x00))
	{
		#ifdef ROADINFO_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,dongredchannel,0x00, \
		                                                dcdata->fd->markbit))
    {
	    #ifdef FULL_DETECT_DEBUG
	        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	    #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x00;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == dongredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = dongredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x00;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}				
	pthread_detach(pthread_self());
    pthread_exit(NULL);
}


void  ms_phase_monitor_deal_bei(dcdata_t *arg)
{
	dcdata_t		*dcdata = arg;
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char 	 senddata[8] = {0};
	unsigned char	 sibuf[64] = {0};
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char    k =0,i = 0;
	struct timeval 	timeout,ct;
	int num = 0;
	unsigned char    beiredchannel[MAX_CHANNEL] = {0};
	memset(beiredchannel,0,sizeof(beiredchannel));
	if(0 != persiondelaychannel[0])
	{
		unsigned char q,w,e = 0,flag = 0;		
		for(q = 0;q<MAX_CHANNEL;q++)
		{
			if(0 == pinfo->beiredchannel[q])
			{
				break;
			}
			for(w = 0;w<MAX_CHANNEL;w++)
			{
				if(0 == persiondelaychannel[w])
				{
					break;
				}
				if(pinfo->beiredchannel[q] == persiondelaychannel[w])
				{
					flag = 0;
					break;
				}
				flag = 1;
			}
			if(flag)
			{
				beiredchannel[e] = pinfo->beiredchannel[q];
				e++;
			}
			flag = 0;
		}
	}
	else
	{
		memcpy(beiredchannel,pinfo->beiredchannel,sizeof(beiredchannel));
	}

	senddata[0] = 0x21;
	senddata[1] = 0x85;
	senddata[2] = 0xFB;
	senddata[3] = 0x00;
	senddata[4] = 0x00;
	senddata[5] = 0x00;
	senddata[6] = 0x80;
	senddata[7] = 0x00;

	write(*(dcdata->fd->sockfd->csockfd),senddata,sizeof(senddata));
	#ifdef ROADINFO_DEBUG
	printf("send bei senddat :");
	for(k=0;k<8;k++)
	{
		printf("%02x ",senddata[k]);
	}
	printf("\n");
	#endif
	num = 0;
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x03;
		sinfo.time = 3;
		sinfo.conmode = *(dcdata->fd->contmode);
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == beiredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = beiredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x03;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}	
	while (1)
	{
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),beiredchannel,0x02))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,beiredchannel,0x02, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),beiredchannel,0x03))
		{
			#ifdef ROADINFO_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->markbit) |= 0x0800;
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
				#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
		}
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,beiredchannel,0x03, \
											dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);
	
		num += 1;
		if (num >= 3)
			break;
	}

	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),beiredchannel,0x01))
	{
		#ifdef FULL_DETECT_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,beiredchannel,0x01, \
		                                                dcdata->fd->markbit))
    {
   	 #ifdef ROADINFO_DEBUG
        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
   	 #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x01;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == beiredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = beiredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x01;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}			

	sleep(3);
	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),beiredchannel,0x00))
	{
		#ifdef ROADINFO_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,beiredchannel,0x00, \
		                                                dcdata->fd->markbit))
    {
	    #ifdef FULL_DETECT_DEBUG
	        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	    #endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.color = 0x00;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == beiredchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = beiredchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x00;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}				
	pthread_detach(pthread_self());
    pthread_exit(NULL);
}




void delay_yellow(dcdata_t *dcdata)
{
	struct timeval 	ct;
	unsigned char	 sibuf[64] = {0};
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char   i =0;
	//unsigned char   notchangletoyellow[MAX_CHANNEL] = {0};
	//notchangletoyellow[0] = changletoyellow;
	
	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->roaddelaychan,0x01))
	{
		#ifdef FULL_DETECT_DEBUG
		printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
			#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->roaddelaychan,0x01, \
														dcdata->fd->markbit))
	{
	 		#ifdef ROADINFO_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	 		#endif
	}
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		//sinfo.time = sinfo.time - 3;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == pinfo->roaddelaychan[i])
				break;
			sinfo.chans += 1;
			tcsta = pinfo->roaddelaychan[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x01;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
			#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}
	sleep(3);
	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->roaddelaychan,0x00))
	{
	#ifdef ROADINFO_DEBUG
			printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
	#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
					printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->roaddelaychan,0x00, \
		                                                dcdata->fd->markbit))
    {
	#ifdef ROADINFO_DEBUG
        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	#endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		sinfo.time = sinfo.time - 3;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == pinfo->roaddelaychan[i])
				break;
			sinfo.chans += 1;
			tcsta = pinfo->roaddelaychan[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x00;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
		#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}
	pthread_detach(pthread_self());
    pthread_exit(NULL);
}


void delay_red(dcdata_t *dcdata)
{
	struct timeval 	ct;
	unsigned char	 sibuf[64] = {0};
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char   i =0;
	dcpinfo_t		*pinfo = dcdata->pi;

	//unsigned char   notchangletoyellow[MAX_CHANNEL] = {0};
	//notchangletoyellow[0] = changletoyellow;

	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->redchannel,0x00))
	{
	#ifdef ROADINFO_DEBUG
			printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
	#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
					printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->redchannel,0x00, \
		                                                dcdata->fd->markbit))
    {
	#ifdef ROADINFO_DEBUG
        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	#endif
    }
	if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		
		//sinfo.time = sinfo.time - 3;
		sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
		sinfo.chans = 0;
		memset(sinfo.csta,0,sizeof(sinfo.csta));
		csta = sinfo.csta;
		for (i = 0; i < MAX_CHANNEL; i++)
		{
			if (0 == pinfo->redchannel[i])
				break;
			sinfo.chans += 1;
			tcsta = pinfo->redchannel[i];
			tcsta <<= 2;
			tcsta &= 0xfc;
			tcsta |= 0x00;
			*csta = tcsta;
			csta++;
		}
		memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
		memset(sibuf,0,sizeof(sibuf));
		if (SUCCESS != status_info_report(sibuf,&sinfo))
		{
		#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		else
		{
			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
		}
	}
	pthread_detach(pthread_self());
    pthread_exit(NULL);
}
void ms_change_right_channel(void *arg)
{
	dcdata_t		*dcdata = arg;
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char   i =0;
	unsigned char   w =0;
	unsigned char   p =0;

	unsigned char     notchangletoyellow[MAX_CHANNEL]={0};

	
	if(0 != currentquenuechannel[0])
	{
		unsigned char q,w,e = 0,flag = 0;
		memset(notchangletoyellow,0,sizeof(notchangletoyellow));
		for(q = 0;q<MAX_CHANNEL;q++)
		{
			if(0 == pinfo->roaddelaychan[q])
			{
				break;
			}
			for(w = 0;w<MAX_CHANNEL;w++)
			{
				if(0 == currentquenuechannel[w])
				{
					break;
				}
				if(pinfo->roaddelaychan[q] == currentquenuechannel[w])
				{
					flag = 0;
					break;
				}
				flag = 1;
			}
			if(flag)
			{
				notchangletoyellow[e] = pinfo->roaddelaychan[q];
				e++;
			}
			flag = 0;
		}
	}
	else
	{
		memset(notchangletoyellow,0,sizeof(notchangletoyellow));
		memcpy(notchangletoyellow,pinfo->roaddelaychan,sizeof(notchangletoyellow));
	}

	//printf("11111111111111111111111111111111111::\n");
//	for(i=0;i<MAX_CHANNEL;i++)
//	{
//		if(0 == notchangletoyellow[i])
//		{
//			break;
//		}
//		printf("%d ",notchangletoyellow[i]);
//		
//	}
//	printf("\n");
//	printf("current value: %d  %d  %d   %d \n",is12,is11,is10,is9);


	memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
	memset(pinfo->roaddelaychan,0,sizeof(pinfo->roaddelaychan));
	
	for(i = 0;i<MAX_CHANNEL;i++)
	{
		if(0 == notchangletoyellow[i])
		{
			break;
		}
		if(12 == notchangletoyellow[i])
		{
			if(is12 == 1)
			{
				 pinfo->roaddelaychan[w] = notchangletoyellow[i];
				 w++;
				//delay_yellow(dcdata, notchangletoyellow[i]);
			}
			else if(is12 == 2)
			{
				pinfo->redchannel[p] = notchangletoyellow[i];
				p++;
				//delay_red(dcdata, notchangletoyellow[i]);
			}
		}
		if(11 == notchangletoyellow[i])
		{
			if(is11 == 1)
			{
				//delay_yellow(dcdata, notchangletoyellow[i]);
				pinfo->roaddelaychan[w] = notchangletoyellow[i];
				 w++;
			}
			else if(is11 == 2)
			{
				//delay_red(dcdata, notchangletoyellow[i]);
				pinfo->redchannel[p] = notchangletoyellow[i];
				p++;
			}
		}
		if(10 == notchangletoyellow[i])
		{
			if(is10 == 1)
			{
				//delay_yellow(dcdata, notchangletoyellow[i]);
				pinfo->roaddelaychan[w] = notchangletoyellow[i];
				 w++;
			}
			else if(is10 == 2)
			{
				//delay_red(dcdata, notchangletoyellow[i]);
				pinfo->redchannel[p] = notchangletoyellow[i];
				p++;
			}
		}
		if(9 == notchangletoyellow[i])
		{
			if(is9 == 1)
			{
				//delay_yellow(dcdata, notchangletoyellow[i]);
				pinfo->roaddelaychan[w] = notchangletoyellow[i];
				 w++;
			}
			else if(is9 == 2)
			{
				//delay_red(dcdata, notchangletoyellow[i]);
				pinfo->redchannel[p] = notchangletoyellow[i];
				p++;
			}
		}


	}

	if(0 != pinfo->redchannel[0])
	{
		pthread_t    redpid; 
		int dcret = pthread_create(&redpid,NULL,(void *)delay_red,dcdata);
		if (0 != dcret)
		{
			#ifdef ROADINFO_DEBUG
			printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
			output_log("delay_red,create major salve detect thread err");
			#endif
			return ;
		}	
	}
	if(0 != pinfo->roaddelaychan[0])
	{
		pthread_t    yellowpid; 
		int dcret = pthread_create(&yellowpid,NULL,(void *)delay_yellow,dcdata);
		if (0 != dcret)
		{
			#ifdef ROADINFO_DEBUG
			printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
			output_log("delay_yellow,create major salve detect thread err");
			#endif
			return ;
		}	
	}
	
	
	pthread_detach(pthread_self());
    pthread_exit(NULL);
}


int check_current_phase(char curchanel,dcpinfo_t *pi)

{

	unsigned char i=0;

	for(i=0;i<MAX_CHANNEL;i++)
	{
		if(0 == pi->chan[i])
		{
			break;
		}
		if(curchanel ==  pi->chan[i])
		{
			
			return 1;
		}
		
	}
	return 0;
}

int check_last_phase(char lastchanel)

{
	

	unsigned char i=0;

	for(i=0;i<MAX_CHANNEL;i++)
	{
		if(0 == lastphasechannel[i])
		{
			break;
		}
		if(lastchanel == lastphasechannel[i])
		{
			#ifdef ROADINFO_DEBUG
			printf("return 1 check_last_phase,File: %s,Line: %d\n",__FILE__,__LINE__);	
			#endif
			return 1;
		}
		
	}
	return 0;
}

void ms_delay_right_channel(void *arg)
{
	dcdata_t		*dcdata = arg;
	dcpinfo_t		*pinfo = dcdata->pi;
	unsigned char 	 channel[MAX_CHANNEL] = {0};
	unsigned char 	i=0,j=0,z=0,issameas = 0;
	unsigned char 	senddata[8] = {0};
	struct timeval 	ct;
	unsigned char	 sibuf[64] = {0};
	unsigned char    tcsta = 0;
	unsigned char    *csta = NULL;
	unsigned char     currentchannel[MAX_CHANNEL];
	int 			  time = 0;
	is10 = 0;
	is11 = 0;
	is12 = 0;
	is9 = 0;
	
	senddata[0] = 0x21;
	senddata[1] = 0x85;
	senddata[2] = 0xFB;
	senddata[3] = 0x00;
	senddata[4] = 0x00;
	senddata[5] = 0x00;
	senddata[6] = 0x00;
	senddata[7] = 0x00;
	#ifdef ROADINFO_DEBUG
	printf("Start delay pthread,File: %s,Line: %d\n",__FILE__,__LINE__);	
	#endif

	z = 0;
	j = 0;
	i = 0;

	for(i=0;i<MAX_CHANNEL;i++)
	{
		if(0 == pinfo->chan[i])
		{
			break;
		}
		issameas = 0;
		for(j=0;j<MAX_CHANNEL;j++)
		{
			if(0 == pinfo->roaddelaychan[j])
			{
				break;
			}
			if(pinfo->roaddelaychan[j] == pinfo->chan[i])
			{
				issameas = 1;
				break;
			}
			
		}
		if(0 == issameas)
		{
			channel[z] = pinfo->chan[i];
			z++;
		}
	}
	for(i=0;i<MAX_CHANNEL;i++)
	{
		if(0 == pinfo->persionroadbit[i])
		{
			break;
		}
		if( 1 == pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x01;
		}
		else if(2 == pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x02;
		}
		else if(3== pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x04;
		}
		else if(4== pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x08;
		}
		else if(5 == pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x10;
		}
		else if(6== pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x20;
		}
		else if(7== pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x40;
		}
		else if(8== pinfo->persionroadbit[i])
		{
			senddata[7] |=  0x80;
		}
				
	}
	

    if(0 != currentquenuechannel[0])
	{
		unsigned char q,w,e = 0,flag = 0;
		memset(currentchannel,0,sizeof(currentchannel));
		for(q = 0;q<MAX_CHANNEL;q++)
		{
			if(0 == channel[q])
			{
				break;
			}
			for(w = 0;w<MAX_CHANNEL;w++)
			{
				if(0 == currentquenuechannel[w])
				{
					break;
				}
				if(channel[q] == currentquenuechannel[w])
				{
					flag = 0;
					break;
				}
				flag = 1;
			}
			if(flag)
			{
				currentchannel[e] = channel[q];
				e++;
			}
			flag = 0;
		}
	}
	else
	{
		memset(currentchannel,0,sizeof(currentchannel));
		memcpy(currentchannel,channel,sizeof(currentchannel));
	}



	//unsigned char channelstatic = 0;
	unsigned char curchannel12 = 0;
	unsigned char curchannel11 = 0;
	unsigned char curchannel10 = 0;
	unsigned char curchannel9 = 0;

	unsigned char lastchannel12 = 0;
	unsigned char lastchannel11 = 0;
	unsigned char lastchannel10 = 0;
	unsigned char lastchannel9 = 0;


//	for(i=0;i<MAX_CHANNEL;i++)
//	{
//		if(0 == lastphasechannel[i])
//		{
//			break;
//		}
//		printf("%d ",lastphasechannel[i]);
//		
//	}
//	printf("\n");

	
	for(i=0;i<MAX_CHANNEL;i++)
	{
		if(0 == pinfo->roaddelaychan[i])
		{
			break;
		}
		if(12 == pinfo->roaddelaychan[i])
		{
			lastchannel12 = check_last_phase(pinfo->roaddelaychan[i]);
			curchannel12 = check_current_phase(pinfo->roaddelaychan[i], pinfo);
	
			if(lastchannel12 == 1 && lastchannel12 == 1)//green- green	
			{
				#ifdef ROADINFO_DEBUG
				printf("is12= 1,File: %s,Line: %d\n",__FILE__,__LINE__);	
				#endif
				is12 = 1;
				time = 6;
			}
			else if(lastchannel12 == 0 && lastchannel12 == 1)//red- green 
			{
				#ifdef ROADINFO_DEBUG
				printf("is12= 2,File: %s,Line: %d\n",__FILE__,__LINE__);	
				#endif
				is12 = 2;
				time = 3;
			}
			else
			{
				is12 = 2;
				time = 3;
			}
		}
		else if(11 == pinfo->roaddelaychan[i])
		{

			lastchannel11 = check_last_phase(pinfo->roaddelaychan[i]);
			curchannel11 = check_current_phase(pinfo->roaddelaychan[i], pinfo);	
			if(lastchannel11 == 1 && lastchannel11 == 1)
			{
				is11 = 1;
				time = 6;
			}
			else if(lastchannel11 == 0 && lastchannel11 == 1)
			{
				is11 = 2;
				time = 3;
			}
			else
			{
				is11 = 2;
				time = 3;
			}
		}
		else if(10 == pinfo->roaddelaychan[i])
		{
			lastchannel10 = check_last_phase(pinfo->roaddelaychan[i]);
			curchannel10 = check_current_phase(pinfo->roaddelaychan[i], pinfo);	
			if(lastchannel10 == 1 && lastchannel10 == 1)
			{
				is10 = 1;
				time = 6;
			}
			else if(lastchannel10 == 0 && lastchannel10 == 1)
			{
				is10 = 2;
				time = 3;
			}
			else
			{
				is10 = 2;
				time = 3;
			}
		}
		else if(9 == pinfo->roaddelaychan[i])
		{
			lastchannel9 = check_last_phase(pinfo->roaddelaychan[i]);
			curchannel9 = check_current_phase(pinfo->roaddelaychan[i], pinfo);	
			if(lastchannel9 == 1 && lastchannel9 == 1)
			{
				is9 = 1;
				time = 6;
			}
			
			else if(lastchannel9 == 0 && lastchannel9 == 1)
			{
				is9  = 2;
				time = 3;
			}
			else
			{
				is9 = 2;
				time = 3;
				
			}

		}

	}
	lastphasechannel[0] = 0;
	memset(persiondelaychannel,0,sizeof(persiondelaychannel));
	memcpy(persiondelaychannel,pinfo->roaddelaychan,sizeof(persiondelaychannel));


	pthread_t    cpcid; 
	int dcret = pthread_create(&cpcid,NULL,(void *)ms_change_right_channel,dcdata);
	if (0 != dcret)
	{
		#ifdef ROADINFO_DEBUG
		printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
		output_log("ms_change_right_channel,create major salve detect thread err");
		#endif
		return ;
	}

	if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),currentchannel,0x02))
	{
		#ifdef ROADINFO_DEBUG
		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		gettimeofday(&ct,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
											dcdata->fd->softevent,dcdata->fd->markbit))
		{
		#ifdef ROADINFO_DEBUG
				printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		*(dcdata->fd->markbit) |= 0x0800;
	}
	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,currentchannel,0x02, \
		                                                dcdata->fd->markbit))
    {
	    #ifdef ROADINFO_DEBUG
	        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	    #endif
    }														
	if (0 == pinfo->cchan[0])
	{
		if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			sinfo.time = pinfo->mingtime + pinfo->gftime + pinfo->ytime + pinfo->rtime; 
	//		#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
				sinfo.time += *(dcdata->fd->halfdownt);
	//		#endif
			sinfo.color = 0x02;
			sinfo.conmode = *(dcdata->fd->contmode);
			sinfo.chans = 0;
			memset(sinfo.csta,0,sizeof(sinfo.csta));
			csta = sinfo.csta;		
			for (i = 0; i < MAX_CHANNEL; i++)
			{
				if (0 == currentchannel[i])
					break;
				sinfo.chans += 1;
				tcsta = currentchannel[i];
				tcsta <<= 2;
				tcsta &= 0xfc;
				tcsta |= 0x02;
				*csta = tcsta;
				csta++;
			}
			memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
			memset(sibuf,0,sizeof(sibuf));
			if (SUCCESS != status_info_report(sibuf,&sinfo))
			{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
			else
			{
				write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
			}		
		}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	}
	else
	{
		if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			sinfo.time = pinfo->mingtime + pinfo->gftime;	
			if (*(dcdata->fd->auxfunc) & 0x01)
				sinfo.time += *(dcdata->fd->halfdownt);
			sinfo.color = 0x02;
			sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
			sinfo.chans = 0;
			memset(sinfo.csta,0,sizeof(sinfo.csta));
			csta = sinfo.csta;
			for (i = 0; i < MAX_CHANNEL; i++)
			{
				if (0 == currentchannel[i])
					break;
				sinfo.chans += 1;
				tcsta = currentchannel[i];
				tcsta <<= 2;
				tcsta &= 0xfc;
				tcsta |= 0x02;
				*csta = tcsta;
				csta++;
			}
			memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
			memset(sibuf,0,sizeof(sibuf));
			if (SUCCESS != status_info_report(sibuf,&sinfo))
			{
				#ifdef ROADINFO_DEBUG
				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
			else
			{
				write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
			}		
		}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
	}

																			
	write(*(dcdata->fd->sockfd->csockfd),senddata,sizeof(senddata));

	while(1)
	{
		isdelay = 1;
		sleep(time);
		if(0 != currentquenuechannel[0])
		{
			unsigned char q,w,e = 0,flag = 0;
			memset(currentchannel,0,sizeof(currentchannel));
			for(q = 0;q<MAX_CHANNEL;q++)
			{
				if(0 == pinfo->chan[q])
				{
					break;
				}
				for(w = 0;w<MAX_CHANNEL;w++)
				{
					if(0 == currentquenuechannel[w])
					{
						break;
					}
					if(pinfo->chan[q] == currentquenuechannel[w])
					{
						flag = 0;
						break;
					}
					flag = 1;
				}
				if(flag)
				{
					currentchannel[e] = pinfo->chan[q];
					e++;
				}
				flag = 0;
			}

		}
		else
		{
			memset(currentchannel,0,sizeof(currentchannel));
			memcpy(currentchannel,pinfo->chan,sizeof(currentchannel));
		}
		if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),currentchannel,0x02))
		{
			#ifdef ROADINFO_DEBUG
			printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			gettimeofday(&ct,NULL);
			update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
			if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
												dcdata->fd->softevent,dcdata->fd->markbit))
			{
			#ifdef ROADINFO_DEBUG
					printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			}
			*(dcdata->fd->markbit) |= 0x0800;
		}	
		if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,currentchannel,0x02, \
	                                                dcdata->fd->markbit))
	    {
	    #ifdef ROADINFO_DEBUG
	        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
	    #endif
	    }
		if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			if(time == 6)
			{
				sinfo.time = sinfo.time - time - 3;
			}
			else
			{
				sinfo.time = sinfo.time - time;
			}
			sinfo.color = 0x02;
			sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
			sinfo.chans = 0;
			memset(sinfo.csta,0,sizeof(sinfo.csta));
			csta = sinfo.csta;
			for (i = 0; i < MAX_CHANNEL; i++)
			{
				if (0 == currentchannel[i])
					break;
				sinfo.chans += 1;
				tcsta = currentchannel[i];
				tcsta <<= 2;
				tcsta &= 0xfc;
				tcsta |= 0x02;
				*csta = tcsta;
				csta++;
			}
			memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
			memset(sibuf,0,sizeof(sibuf));
			if (SUCCESS != status_info_report(sibuf,&sinfo))
			{
				#ifdef ROADINFO_DEBUG
					printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
			else
			{
				write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
			}
		}

		senddata[0] = 0x21;
		senddata[1] = 0x85;
		senddata[2] = 0xFB;
		senddata[3] = 0x00;
		senddata[4] = 0xff;
		senddata[5] = 0xff;
		senddata[6] = 0xff;
		senddata[7] = 0xff;
		for(i=0;i<MAX_CHANNEL;i++)
		{
			if(0 == pinfo->persionroadbit[i])
			{
				break;
			}
			if( 1 == pinfo->persionroadbit[i])
			{
				senddata[7]  &=  0xfe;
			}
			else if(2== pinfo->persionroadbit[i])
			{
				senddata[7] &= 0xfd;
			}
			else if(3== pinfo->persionroadbit[i])
			{
				senddata[7] &= 0xfb;
			}
			else if(4== pinfo->persionroadbit[i])
			{
				senddata[7] &= 0xf7;
			}
			else if(5== pinfo->persionroadbit[i])
			{
				senddata[7] &= 0xef;
			}
			else if(6== pinfo->persionroadbit[i])
			{
				senddata[7] &= 0xdf;
			}
			else if(7== pinfo->persionroadbit[i])
			{
				senddata[7] &= 0xbf;
			}
			else if(8== pinfo->persionroadbit[i])
			{
				senddata[7] &= 0x7f;
			}
					
		}			
		write(*(dcdata->fd->sockfd->csockfd),senddata,sizeof(senddata));
	
		break;
	}
	isdelay = 0;
	memset(persiondelaychannel,0,sizeof(persiondelaychannel));
	if(1==delaypcyes)
	{
		delaypcyes = 0;
		#ifdef ROADINFO_DEBUG
		printf("delay pthread is end,File: %s,Line: %d\n",__FILE__,__LINE__);	
		#endif
		//pthread_cancel(delaypcpid);
		//pthread_join(delaypcpid,NULL);	
	}
	pthread_detach(pthread_self());
	pthread_exit(NULL);
}

void ms_end_child_thread()
{
	if (1 == cpdyes)
	{
		pthread_cancel(cpdid);
		pthread_join(cpdid,NULL);
		cpdyes = 0;
	}
	if (1 == dcyfyes)
	{
		pthread_cancel(dcyfid);
		pthread_join(dcyfid,NULL);
		dcyfyes = 0;
	}
    if (1 == dcpcyes)
    {
        pthread_cancel(dcpcid);
        pthread_join(dcpcid,NULL);
        dcpcyes = 0;
    }
    if (1 == ppmyes)
    {
        pthread_cancel(ppmid);
        pthread_join(ppmid,NULL);
        ppmyes = 0;
    }
    if (1 == dcyes)
    {
        pthread_cancel(dcpid);
        pthread_join(dcpid,NULL);
        dcyes = 0;
    }
	if(1 == delaypcyes)
	{	
		pthread_cancel(delaypcpid);
		pthread_join(delaypcpid,NULL);
		delaypcyes = 0;
	}
	#ifdef CHANNEL_YELLOW_FLASH
    if (1 == cyft.mark)
    {
        pthread_cancel(yfcpid);
        pthread_join(yfcpid,NULL);
        cyft.mark = 0;
        if (SUCCESS != ms_set_lamp_color(*(cyft.dc->fd->bbserial),cyft.chan,0x00))
        {
            printf("set channel color err,File: %s,Line: %d\n",__FILE__,__LINE__);
        }
        if (SUCCESS!=update_channel_status(cyft.dc->fd->sockfd,cyft.dc->cs,cyft.chan,0,cyft.dc->fd->markbit))
        {
            printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
        }
    }
    #endif
#if 0
	#ifdef CHANNEL_CLOSE
    if (SUCCESS != ms_set_lamp_color(*(cyft.dc->fd->bbserial),cyft.chan,0x00))
    {
        printf("set channel color err,File: %s,Line: %d\n",__FILE__,__LINE__);
    }
    if (SUCCESS!=update_channel_status(cyft.dc->fd->sockfd,cyft.dc->cs,cyft.chan,0,cyft.dc->fd->markbit))
    {
        printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
    }
    #endif
#endif
}

void ms_end_part_child_thread()
{
	if (1 == cpdyes)
    {
        pthread_cancel(cpdid);
        pthread_join(cpdid,NULL);
        cpdyes = 0;
    }
	if (1 == dcyfyes)
    {
        pthread_cancel(dcyfid);
        pthread_join(dcyfid,NULL);
        dcyfyes = 0;
    }
	if (1 == dcpcyes)
	{
		pthread_cancel(dcpcid);
		pthread_join(dcpcid,NULL);
		dcpcyes = 0;
	}
	if (1 == ppmyes)
	{
		pthread_cancel(ppmid);
		pthread_join(ppmid,NULL);
		ppmyes = 0;
	}
	if(1 == delaypcyes)
	{	
		pthread_cancel(delaypcpid);
		pthread_join(delaypcpid,NULL);
		delaypcyes = 0;
	}
	#ifdef CHANNEL_YELLOW_FLASH
    if (1 == cyft.mark)
    {
        pthread_cancel(yfcpid);
        pthread_join(yfcpid,NULL);
        cyft.mark = 0;
        if (SUCCESS != ms_set_lamp_color(*(cyft.dc->fd->bbserial),cyft.chan,0x00))
        {
            printf("set channel color err,File: %s,Line: %d\n",__FILE__,__LINE__);
        }
        if (SUCCESS!=update_channel_status(cyft.dc->fd->sockfd,cyft.dc->cs,cyft.chan,0,cyft.dc->fd->markbit))
        {
            printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
        }
    }
    #endif
#if 0
	#ifdef CHANNEL_CLOSE
    if (SUCCESS != ms_set_lamp_color(*(cyft.dc->fd->bbserial),cyft.chan,0x00))
    {
        printf("set channel color err,File: %s,Line: %d\n",__FILE__,__LINE__);
    }
    if (SUCCESS!=update_channel_status(cyft.dc->fd->sockfd,cyft.dc->cs,cyft.chan,0,cyft.dc->fd->markbit))
    {
        printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
    }
    #endif
#endif
}

void ms_yellow_flash(void *arg)
{
	yfdata_t			*yfdata = arg;

	new_yellow_flash(yfdata);

	pthread_exit(NULL);
}

void ms_count_phase_detector(void *arg)
{
	unsigned char			i = 0, j = 0, z = 0;
	struct timeval			ntime;
	unsigned int			leatime = 0;
	unsigned char			exist = 0;

	while (1)
	{//while loop
		sleep(INTERVALTIME);
		#ifdef FULL_DETECT_DEBUG
		printf("Begin to count detector of phase,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif

		for (i = 0; i < MAX_PHASE_LINE; i++)
		{//for (i = 0; i < MAX_PHASE_LINE; i++)
			if (0 == phdetect[i].phaseid)
				break;
			if ((0x80 == phdetect[i].phasetype) || (0x04 == phdetect[i].phasetype))
				continue;
			for (j = 0; j < 10; j++)
			{//for (j = 0; j < 10; j++)
				if (0 == phdetect[i].detectpro[j].deteid)
					break;
				if (1 == phdetect[i].detectpro[j].err)
				{//detector do report err own
					exist = 0;
					for (z = 0; z < 10; z++)
					{
						if (phdetect[i].indetect[z] == phdetect[i].detectpro[j].deteid)
						{
							exist = 1;
							break;
						}
					}
					if (0 == exist)
					{
						for (z = 0; z < 10; z++)
						{
							if (0 == phdetect[i].indetect[z])
							{
								phdetect[i].indetect[z] = phdetect[i].detectpro[j].deteid;
								phdetect[i].factnum += 1;
								break;
							}
						}
					}
				}//detector do report err own
				else
				{//detector do not report err own;
					if (0 == phdetect[i].detectpro[j].validmark) 
					{//the detector is invalid;
						ntime.tv_sec = 0;
						ntime.tv_usec = 0;
						gettimeofday(&ntime,NULL);
						leatime = ntime.tv_sec - (phdetect[i].detectpro[j].stime.tv_sec);
						if (leatime >= phdetect[i].detectpro[j].intime)
						{
							exist = 0;
							for (z = 0; z < 10; z++)
							{
								if (phdetect[i].indetect[z] == phdetect[i].detectpro[j].deteid)
								{
									exist = 1;
									break;
								}
							}
							if (0 == exist)
							{
								for (z = 0; z < 10; z++)
                        		{
                            		if (0 == phdetect[i].indetect[z])
                            		{
                                		phdetect[i].indetect[z] = phdetect[i].detectpro[j].deteid;
                                		phdetect[i].factnum += 1;
                                		break;
                            		}
                        		}
							}
						}//if (leatime >= phdetect[i].detectpro[j].intime)		
					}//the detector is invalid
					else
					{//the detector is valid
						for (z = 0; z < 10; z++)
                        {
                            if (phdetect[i].indetect[z] == phdetect[i].detectpro[j].deteid)
                            {
                                phdetect[i].indetect[z] = 0;
                                if (phdetect[i].factnum > 0)
                                    phdetect[i].factnum -= 1;
                                break;
                            }
                        }
                        phdetect[i].detectpro[j].validmark = 0;
					}//the detector is valid
				}//detector do not report err own;
			}//for (j = 0; j < 10; j++)
			
			if (phdetect[i].factnum >= phdetect[i].indetenum)
			{
				phdetect[i].validmark = 0;
				degrade |= (0x00000001 << (phdetect[i].phaseid - 1));
			}
			else
			{
				phdetect[i].validmark = 1;
				degrade &= (~(0x00000001 << (phdetect[i].phaseid - 1)));
			}				
		}//for (i = 0; i < MAX_PHASE_LINE; i++)
	}//while loop	

	pthread_exit(NULL);
}

void ms_monitor_pending_pipe(void *arg)
{//monitor pending phase or monitor detector to degrade when do not detect control;
	monpendphase_t		*mpphase = arg;
	fd_set				nRead;
	unsigned char		buf[256] = {0};
	unsigned char		*pbuf = buf;
	unsigned short		mark = 0;	
	unsigned short		num = 0;
	unsigned char		i = 0, j = 0;
	unsigned char		dtype = 0; //detector type
	unsigned char		deteid = 0;//detector id;
	unsigned char		mphase = 0;

	while (1)
	{
		FD_ZERO(&nRead);
		FD_SET(*(mpphase->pendpipe),&nRead);
		int fret = select(*(mpphase->pendpipe)+1,&nRead,NULL,NULL,NULL);
		if (fret < 0)
		{
		#ifdef FULL_DETECT_DEBUG
			printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
			return;
		}
		if (fret > 0)	
		{//0
			if (FD_ISSET(*(mpphase->pendpipe),&nRead))
			{//1
				memset(buf,0,sizeof(buf));
				num = read(*(mpphase->pendpipe),buf,sizeof(buf));	
				if (num > sizeof(buf))
                    continue;
				if (num > 0)
				{//2
					pbuf = buf;
					mark = 0;
					while (1)
					{//3
						if (mark >= num)
							break;
						if ((0xF1 == *(pbuf+mark)) && (0xED == *(pbuf+mark+5)))
						{//4
							deteid = *(pbuf+mark+2);
							if (3 == *(pbuf+mark+1))
							{//detector report error
								for (i = 0; i < MAX_PHASE_LINE; i++)
								{
									if (0 == phdetect[i].phaseid)
										break;
									for (j = 0; j < 10; j++)
									{
										if (0 == phdetect[i].detectpro[j].deteid)
											break;
										if (deteid == phdetect[i].detectpro[j].deteid)
										{
											phdetect[i].detectpro[j].validmark = 0;
											phdetect[i].detectpro[j].err = 1;
											phdetect[i].detectpro[j].stime.tv_sec = 0;
											phdetect[i].detectpro[j].stime.tv_usec = 0;
											gettimeofday(&(phdetect[i].detectpro[j].stime),NULL);
										}
									}
								}
							}//detector report error
							if (4 == *(pbuf+mark+1))
							{//person type detector
								for (i = 0; i < MAX_PHASE_LINE; i++)
                                {
                                    if (0 == phdetect[i].phaseid)
                                        break;
                                    for (j = 0; j < 10; j++)
                                    {
                                        if (0 == phdetect[i].detectpro[j].deteid)
                                            break;
                                        if (deteid == phdetect[i].detectpro[j].deteid)
                                        {
                                            phdetect[i].detectpro[j].validmark = 1;
											phdetect[i].detectpro[j].err = 0;
											phdetect[i].detectpro[j].stime.tv_sec = 0;
                                            phdetect[i].detectpro[j].stime.tv_usec = 0;
                                            gettimeofday(&(phdetect[i].detectpro[j].stime),NULL);
                                        }
                                    }
                                }
							}//person type detector
							if (5 == *(pbuf+mark+1))
							{//bus proprity detector
								for (i = 0; i < MAX_PHASE_LINE; i++)
                                {
                                    if (0 == phdetect[i].phaseid)
                                        break;
                                    for (j = 0; j < 10; j++)
                                    {
                                        if (0 == phdetect[i].detectpro[j].deteid)
                                            break;
                                        if (deteid == phdetect[i].detectpro[j].deteid)
                                        {
                                            phdetect[i].detectpro[j].validmark = 1;
											phdetect[i].detectpro[j].err = 0;
											phdetect[i].detectpro[j].stime.tv_sec = 0;
                                            phdetect[i].detectpro[j].stime.tv_usec = 0;
                                            gettimeofday(&(phdetect[i].detectpro[j].stime),NULL);
                                        }
                                    }
                                }
							}//bus proprity detector
							if (1 == *(pbuf+mark+1))
							{//if (1 == *(pbuf+mark+1))
								for (i = 0; i < MAX_PHASE_LINE; i++)
                                {
                                    if (0 == phdetect[i].phaseid)
                                        break;
                                    for (j = 0; j < 10; j++)
                                    {
                                        if (0 == phdetect[i].detectpro[j].deteid)
                                            break;
                                        if (deteid == phdetect[i].detectpro[j].deteid)
                                        {
                                            phdetect[i].detectpro[j].validmark = 1;
											phdetect[i].detectpro[j].err = 0;
											phdetect[i].detectpro[j].stime.tv_sec = 0;
                                            phdetect[i].detectpro[j].stime.tv_usec = 0;
                                            gettimeofday(&(phdetect[i].detectpro[j].stime),NULL);
                                        }
                                    }
                                }							

								if (1 == ppexist)
								{//pending phase exist in current pattern;
									for (i = 0; i < (mpphase->detector->FactDetectorNum); i++)
									{//find out the type of detector
										if (0 == (mpphase->detector->DetectorList[i].DetectorId))
											break;
										if (deteid == (mpphase->detector->DetectorList[i].DetectorId))
										{
											dtype = mpphase->detector->DetectorList[i].DetectorType;
											if ((0x80 == dtype) || (0x40 == dtype) || (0x04 == dtype))
											{//request or response detector or bus detector
												mphase = mpphase->detector->DetectorList[i].DetectorPhase;
												for (j = 0; j < MAX_PHASE_LINE; j++)
												{
													if (0 == pephase[j].phaseid)
														break;
													if (mphase == pephase[j].phaseid)
													{
														pephase[j].mark = 1;
														break;
													}
												}
											}//request or response detector
											else
											{//unfit detector
												break;
											}//unfit detector
										}
									}//find out the type of detector
								}//if (1 == ppexist)
							}//if (1 == *(pbuf+mark+1))

							mark += 6;
							continue;//fit data,break directly
						}//4
						else
						{
							mark += 1;
							continue;
						}
					}//3
					continue;
				}//2
				else
				{
					continue;
				}
			}//1
			else
			{
				continue;
			}
		}//0
	}//while loop

	pthread_exit(NULL);
}

void ms_person_chan_greenflash(void *arg)
{
	dcpcdata_t				*dpdata = arg;
	unsigned char			i = 0;
	struct timeval			timeout;
//	unsigned char			num = 0;

	while (1)
	{
		if (SUCCESS != ms_set_lamp_color(*(dpdata->bbserial),dpdata->pchan,0x03))
		{
		#ifdef FULL_DETECT_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
			*(dpdata->markbit) |= 0x0800;
		}
		if (SUCCESS != update_channel_status(dpdata->sockfd,dpdata->cs,dpdata->pchan,0x03,dpdata->markbit))
		{
		#ifdef FULL_DETECT_DEBUG
			printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
		}
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);

		if (SUCCESS != ms_set_lamp_color(*(dpdata->bbserial),dpdata->pchan,0x02))
		{
		#ifdef FULL_DETECT_DEBUG
			printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
			*(dpdata->markbit) |= 0x0800;
		}
		if (SUCCESS != update_channel_status(dpdata->sockfd,dpdata->cs,dpdata->pchan,0x02,dpdata->markbit))
        {
        #ifdef FULL_DETECT_DEBUG
            printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
        #endif
        }
		timeout.tv_sec = 0;
		timeout.tv_usec = 500000;
		select(0,NULL,NULL,NULL,&timeout);

//		num += 1;
//		if (num >= (dpdata->time))
//			break;
	}

	pthread_exit(NULL);
}

void start_major_salve_control(void *arg)
{
	dcdata_t				*dcdata = arg;
	unsigned char			tcline = 0;
	unsigned char			snum = 0; //max number of stage 
	unsigned char			slnum = 0;
	int						i = 0,j = 0,z = 0,k = 0,s = 0;
	unsigned char			tphid = 0;
	unsigned char			ppnum = 0;//the number of pending phase
	timedown_t				timedown;
	monpendphase_t			mpphase;
	unsigned char			tnum = 0;

	unsigned char           downti[8] = {0xA6,0xff,0xff,0xff,0xff,0x03,0xff,0xED};
	unsigned char           edownti[3] = {0xA5,0xA5,0xED};
	unsigned int			tchans = 0;
	unsigned char			tclc1 = 0;

	//  #ifdef CHANNEL_YELLOW_FLASH; 单通道黄闪和灭灯都可以使用这些变量
    unsigned char           cyfn = 0;
    unsigned int            cyfe = 0;
    unsigned char           cyfc[YFCHANNEL] = {0};
    unsigned char           *pcyfc =  NULL;
	//  #endif

	if (!wait_write_serial(*(dcdata->fd->bbserial)))
    {
    	if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
        {
		#ifdef FULL_DETECT_DEBUG
			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif       
        }
    }
    else
    {
    #ifdef FULL_DETECT_DEBUG
    	printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
    #endif
    }
    if (!wait_write_serial(*(dcdata->fd->bbserial)))
    {
    	if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
        {
        #ifdef FULL_DETECT_DEBUG
        	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
        #endif
        }
    }
    else
    {
    #ifdef FULL_DETECT_DEBUG
    	printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
    #endif
    }

	if (SUCCESS != ms_get_timeconfig(dcdata->td,dcdata->fd->patternid,&tcline))
	{
	#ifdef FULL_DETECT_DEBUG
		printf("ms_get_timeconfig call err,File: %s,Line: %d\n",__FILE__,__LINE__);
		output_log("detect control,get timeconfig err");
	#endif
		ms_end_part_child_thread();
		//return;

		struct timeval				time;
		unsigned char				yferr[10] = {0};
		gettimeofday(&time,NULL);
		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,11,time.tv_sec,dcdata->fd->markbit);
		if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
		{
			memset(yferr,0,sizeof(yferr));
			if (SUCCESS != err_report(yferr,time.tv_sec,1,11))
			{
		#ifdef FULL_DETECT_DEBUG
				printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
			}
			else
			{
				write(*(dcdata->fd->sockfd->csockfd),yferr,sizeof(yferr));
			}
		}

		yfdata_t					yfdata;
		if (0 == dcyfyes)
		{
			memset(&yfdata,0,sizeof(yfdata));
			yfdata.second = 0;
			yfdata.markbit = dcdata->fd->markbit;
			yfdata.markbit2 = dcdata->fd->markbit2;
			yfdata.serial = *(dcdata->fd->bbserial);
			yfdata.sockfd = dcdata->fd->sockfd;
			yfdata.cs = dcdata->cs;		
#ifdef FLASH_DEBUG
			char szInfo[32] = {0};
			char szInfoT[64] = {0};
			snprintf(szInfo,sizeof(szInfo)-1,"%s",__FUNCTION__);
			snprintf(szInfoT,sizeof(szInfoT)-1,"%d",__LINE__);
			tsc_save_eventlog(szInfo,szInfoT);
#endif
			int yfret = pthread_create(&dcyfid,NULL,(void *)ms_yellow_flash,&yfdata);
			if (0 != yfret)
			{
		#ifdef FULL_DETECT_DEBUG
				printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				output_log("ms_yellow_flash control,create yellow flash err");
		#endif
				ms_end_part_child_thread();
				return;
			}
			dcyfyes = 1;
		}		
		while(1)
		{
			if (*(dcdata->fd->markbit) & 0x0001)
			{//end time of current pattern has arrived
				unsigned char           enddata[3] = {0xCC,0xDD,0xED};
				if (!wait_write_serial(*(dcdata->fd->synpipe)))
				{
					if (write(*(dcdata->fd->synpipe),enddata,sizeof(enddata)) < 0)
					{
				#ifdef FULL_DETECT_DEBUG
						printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
						ms_end_part_child_thread();
						return;
					}
				}
				else
				{
			#ifdef FULL_DETECT_DEBUG
					printf("pipe cannot be written,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
					ms_end_part_child_thread();
					return;
				}
				sleep(5);//wait main module end own;	
			}//end time of current pattern has arrived
			sleep(10);
			continue;
		}

	}
	rettl = tcline;
	//Get max value of stage and all pending phases;
	//Get all phase and its maped detector, initial the data struct;
	memset(pephase,0,sizeof(pephase));	
	memset(phdetect,0,sizeof(phdetect));
	pphdetect = phdetect;
	j = 0;
	ppexist = 0;
	ppnum = 0;
	for (snum = 0; ;snum++)
	{//for (snum = 0; ;snum++)
		if (0 == dcdata->td->timeconfig->TimeConfigList[tcline][snum].StageId)
			break;
		pphdetect->stageid = dcdata->td->timeconfig->TimeConfigList[tcline][snum].StageId;
		get_phase_id(dcdata->td->timeconfig->TimeConfigList[tcline][snum].PhaseId,&tphid);
		pphdetect->phaseid = tphid;
		pphdetect->gtime = dcdata->td->timeconfig->TimeConfigList[tcline][snum].GreenTime;
		pphdetect->ytime = dcdata->td->timeconfig->TimeConfigList[tcline][snum].YellowTime;
        pphdetect->rtime = dcdata->td->timeconfig->TimeConfigList[tcline][snum].RedTime;

		//get channls of phase 
        for (i = 0; i < (dcdata->td->channel->FactChannelNum); i++)
        {
            if (0 == (dcdata->td->channel->ChannelList[i].ChannelId))
                break;
            if ((pphdetect->phaseid) == (dcdata->td->channel->ChannelList[i].ChannelCtrlSrc))
            {
				#ifdef CLOSE_LAMP
                tclc1 = dcdata->td->channel->ChannelList[i].ChannelId;
                if ((tclc1 >= 0x05) && (tclc1 <= 0x0c))
                {
                    if (*(dcdata->fd->specfunc) & (0x01 << (tclc1 - 5)))
                        continue;
                }
				#else
				if ((*(dcdata->fd->specfunc)&0x10)&&(*(dcdata->fd->specfunc)&0x20))
				{
					tclc1 = dcdata->td->channel->ChannelList[i].ChannelId;
					if(((5<=tclc1)&&(tclc1<=8)) || ((9<=tclc1)&&(tclc1<=12)))
						continue;
				}
				if ((*(dcdata->fd->specfunc)&0x10)&&(!(*(dcdata->fd->specfunc)&0x20)))
				{
					tclc1 = dcdata->td->channel->ChannelList[i].ChannelId;
					if ((5 <= tclc1) && (tclc1 <= 8))
						continue;
				}
				if ((*(dcdata->fd->specfunc)&0x20)&&(!(*(dcdata->fd->specfunc)&0x10)))
				{
					tclc1 = dcdata->td->channel->ChannelList[i].ChannelId;
					if ((9 <= tclc1) && (tclc1 <= 12))
						continue;
				}
                #endif
                pphdetect->chans |= (0x00000001 << ((dcdata->td->channel->ChannelList[i].ChannelId) - 1));
                continue;
            }
        }
		for (i = 0; i < (dcdata->td->phase->FactPhaseNum); i++)
		{//for (i = 0; i < (dcdata->td->phase->FactPhaseNum); i++)
			if (0 == (dcdata->td->phase->PhaseList[i].PhaseId))
				break;
			if (tphid == (dcdata->td->phase->PhaseList[i].PhaseId))
			{
				if (0x40 == (dcdata->td->phase->PhaseList[i].PhaseType))
                {//pending phase
                    ppexist = 1;
                    ppnum += 1;
                    pephase[j].phaseid = dcdata->td->phase->PhaseList[i].PhaseId;
                    pephase[j].mark = 0;
                    j++;
                }//pending phase
				pphdetect->phasetype = dcdata->td->phase->PhaseList[i].PhaseType;
				
                pphdetect->fixgtime = dcdata->td->phase->PhaseList[i].PhaseFixGreen;
                pphdetect->mingtime = dcdata->td->phase->PhaseList[i].PhaseMinGreen;
                pphdetect->maxgtime = dcdata->td->phase->PhaseList[i].PhaseMaxGreen1;
                pphdetect->gftime = dcdata->td->phase->PhaseList[i].PhaseGreenFlash;
                pphdetect->gtime -= pphdetect->gftime;//green time is not include green flash
                pphdetect->pgtime = dcdata->td->phase->PhaseList[i].PhaseWalkGreen;
                pphdetect->pctime = dcdata->td->phase->PhaseList[i].PhaseWalkClear;

				tnum = dcdata->td->phase->PhaseList[i].PhaseSpecFunc;
				tnum &= 0xe0;//get 5~7bit
				tnum >>= 5;
				tnum &= 0x07; 
				pphdetect->indetenum = tnum;//invalid detector arrive the number,begin to degrade;
				pphdetect->validmark = 1;
				pphdetect->factnum = 0;
				memset(pphdetect->indetect,0,sizeof(pphdetect->indetect));
				memset(pphdetect->detectpro,0,sizeof(pphdetect->detectpro));
				dpro = pphdetect->detectpro;
				for (z = 0; z < (dcdata->td->detector->FactDetectorNum); z++)
				{//1
					if (0 == (dcdata->td->detector->DetectorList[z].DetectorId))
						break;
					if ((pphdetect->phaseid) == (dcdata->td->detector->DetectorList[z].DetectorPhase))
					{
						dpro->deteid = dcdata->td->detector->DetectorList[z].DetectorId;
//						dpro->detetype = dcdata->td->detector->DetectorList[z].DetectorType;
						dpro->validmark = 0;
						dpro->err = 0;
						tnum = dcdata->td->detector->DetectorList[z].DetectorSpecFunc;
						tnum &= 0xfc;//get 2~7bit
						tnum >>= 2;
						tnum &= 0x3f;
						dpro->intime = tnum * 60; //seconds;
						memset(&(dpro->stime),0,sizeof(struct timeval));
						gettimeofday(&(dpro->stime),NULL);
						dpro++;
					}
				}//1
				pphdetect++;
				break;
			}
		}//for (i = 0; i < (dcdata->td->phase->FactPhaseNum); i++)
	}//for (snum = 0; ;snum++)
	
	if (0 == ppmyes)
	{//monitor pending phase or check the valid or invalid of detector when do not have detect control;
		memset(&mpphase,0,sizeof(monpendphase_t));
		mpphase.pendpipe = dcdata->fd->pendpipe;
		mpphase.detector = dcdata->td->detector;
		int ppmret = pthread_create(&ppmid,NULL,(void *)ms_monitor_pending_pipe,&mpphase);
		if (0 != ppmret)
		{
		#ifdef FULL_DETECT_DEBUG
			printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
			output_log("detect control,create monitor pending thread err");
		#endif
			ms_end_part_child_thread();	
			return;
		}
		ppmyes = 1;
	}//monitor pending phase or check the valid or invalid of detector when do not have detect control;
	if (0 == cpdyes)
	{
		int cpdret = pthread_create(&cpdid,NULL,(void *)ms_count_phase_detector,NULL);
		if (0 != cpdret)
		{
		#ifdef FULL_DETECT_DEBUG
			printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
			output_log("detect control,create count phase thread err");
        #endif
			ms_end_part_child_thread();
			return;
		}
		cpdyes = 1;
	}
    //data send of backup pattern control
	if (SUCCESS != ms_backup_pattern_data(*(dcdata->fd->bbserial),snum,phdetect))
	{
	#ifdef TIMEING_DEBUG
		printf("backup_pattern_data call err,File: %s,Line: %d\n",__FILE__,__LINE__);
	#endif
	}
	//end data send
	slnum = *(dcdata->fd->slnum);
	*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
	if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
	{
		slnum = 0;
		*(dcdata->fd->slnum) = 0;
		*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
	}

	unsigned char				cycarr = 0;
	dcpinfo_t					*pinfo = dcdata->pi;
	dcpcdata_t					dpdata;
	unsigned char				gft = 0; //green flash time;
	struct timeval				timeout,mtime,nowtime,lasttime,ct;
	unsigned char				leatime = 0,mt = 0,bakv = 0;
	unsigned char				sltime = 0;
	unsigned char				ffw = 0;
	fd_set						nRead;
	unsigned char				buf[256] = {0};
	unsigned char				*pbuf = buf;
	unsigned short				num = 0,mark = 0;
	unsigned char				caryes = 0;//'1' means that vehicle pass detector;
	unsigned char				dtype = 0;//detector type;
	unsigned char				mintime = 0;
	unsigned char				concyc = 0;
	unsigned char				mappid = 0;//phase id of detector mapping;	
	unsigned char				deteid = 0; //id of detector;
	unsigned char				fbdata[6] = {0};
	fbdata[0] = 0xC1;
	fbdata[5] = 0xED;
	unsigned char				rft = 0;
	unsigned char				endahead = 0;
	unsigned char				endcyclen = 0;
	unsigned int				lefttime = 0;
	unsigned char				c1gt = 0;
	unsigned char				c1gmt = 0;
	unsigned char				c2gt = 0;
	unsigned char				c2gmt = 0;
	unsigned char				twocycend = 0;
	unsigned char				onecycend = 0;
	unsigned char				validmark = 0;
	unsigned char				bakmaxg = 0;
	unsigned char				sibuf[64] = {0};
//	statusinfo_t				sinfo;
	unsigned char               *csta = NULL;
    unsigned char               tcsta = 0;
	unsigned int  				roaddata = *(dcdata->fd->roadinfo);
	unsigned char 				roadbit = 0;
	unsigned char               isperdelay = 0;
	unsigned char               roadreport[8] = {0};
	unsigned int                currenttime = 0;
	unsigned int				receiveroadtime = 0;

	unsigned char				err1[10] = {0};//20220804
	AdaptData_t					adaptd;//20220621
	unsigned char				adabuf[432] = {0};//20220621
	unsigned char				bevent = 0;

	memset(&adaptd,0,sizeof(AdaptData_t));
	adaptd.pattid = *(dcdata->fd->patternid);
	adaptd.contype = *(dcdata->fd->contmode);
	adaptd.stageid = *(dcdata->fd->stageid);

	
//	memset(&sinfo,0,sizeof(statusinfo_t));
	sinfo.conmode = *(dcdata->fd->contmode);
    sinfo.pattern = *(dcdata->fd->patternid);
    sinfo.cyclet = *(dcdata->fd->cyclet);

	#ifdef V2X_DEBUG
	if (*(dcdata->fd->auxfunc) & 0x01)
	{//if (*(dcdata->fd->auxfunc) & 0x01)
		if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
		{//if ((30 != *(sadata->fd->contmode)) && (31 != *(sadata->fd->contmode)))
			*(dcdata->fd->v2xmark) &= 0xfe;//V2X
			for (i = 0;i < MAX_PHASE_LINE;i++)
			{
				if (0 == phdetect[i].stageid)
					break;
				if (*(dcdata->fd->stageid) == phdetect[i].stageid)
				{
					break;
				}
			}
			for (j = 1; j < (MAX_CHANNEL+1); j++)
			{
				if (phdetect[i].chans & (0x00000001 << (j -1)))
					continue;
				for (z = 0; z < MAX_PHASE_LINE; z++)
				{
					if (0 == phdetect[z].stageid)
						break;
					if (z == i)
						continue;
					if (phdetect[z].chans & (0x00000001 << (j - 1)))
					{
						if ((j < 13) || (j > 16))
                        {
                            dcdata->fd->slg[j-1].slgid = j;
                            dcdata->fd->slg[j-1].slgstatus= 0x15;
                            dcdata->fd->slg[j-1].countdown = 0xff;
                            dcdata->fd->slg[j-1].nslgstatus = 0x17;

							dcdata->fd->slg[j-1].greent = 0;//phdetect[z].gtime + phdetect[z].gftime; 
							dcdata->fd->slg[j-1].yellowt = 0;//phdetect[z].ytime;
							dcdata->fd->slg[j-1].redt = 0;//phdetect[z].rtime;
							dcdata->fd->slg[j-1].allrt = 0;
                        }					
						break;
					}//if (phdetect[z].chans & (0x00000001 << (j - 1)))
				}//for (z = 0; z < MAX_PHASE_LINE; z++)
			}//for (j = 1; j < (MAX_CHANNEL+1); j++)	
		}//if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
	}//if (*(dcdata->fd->auxfunc) & 0x01)
	#endif

	dunhua_close_lamp(dcdata->fd,dcdata->cs);
	unsigned char           syndata[3] = {0xCC,0xDD,0xED};	
	adaptd.phasenum = 0;//added on 20220620
	memset(adaptd.phi,0,sizeof(adaptd.phi));//added on 20220620
	unsigned char		ni = 0;//added on 20220620
	while (1)
	{//while loop
		
		if (1 == cycarr)
		{
			cycarr = 0;

			if (*(dcdata->fd->markbit) & 0x0001)
			{//end time of current pattern has arrived
//				unsigned char           syndata[3] = {0xCC,0xDD,0xED};
				#ifdef RED_FLASH
                sleep(1);//wait "rfpid" thread release resource; 
                #endif
				if (!wait_write_serial(*(dcdata->fd->synpipe)))
				{
					if (write(*(dcdata->fd->synpipe),syndata,sizeof(syndata)) < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						output_log("Detect control,write synpipe err");
					#endif
						ms_end_part_child_thread();
						return;
					}
				}
				else
				{
				#ifdef FULL_DETECT_DEBUG
					printf("pipe cannot be written,File: %s,Line: %d\n",__FILE__,__LINE__);
					output_log("Detect control,synpipe cannot write");
				#endif
					ms_end_part_child_thread();
					return;
				}
			//Note, 0th bit is clean 0 by main module
				sleep(5);//wait main module end own;	
			}//end time of current pattern has arrived	

			//added on 20220620
			memset(adabuf,0,sizeof(adabuf));
			gettimeofday(&ct,NULL);
			adaptd.time = ct.tv_sec;
			for (i = 0; i < adaptd.phasenum; i++)
			{
				adaptd.cycle += adaptd.phi[i].pfactt;
			}
			if (SUCCESS != adapt_data_report(adabuf,&adaptd))
			{
				#ifdef FULL_DETECT_DEBUG
				printf("adapt_data_report called err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
			}
			else
			{
				write(*(dcdata->fd->sockfd->csockfd),adabuf,sizeof(adabuf));	
			}
			adaptd.phasenum = 0;
			adaptd.cycle = 0;
			adaptd.time = 0;
    		memset(adaptd.phi,0,sizeof(adaptd.phi));
			ni = 0;
			//end add

#if 0
			//send end mark of cycle to configure tool  
            if (write(*(dcdata->fd->sockfd->ssockfd),cycend,sizeof(cycend)) < 0)
            {
            #ifdef FULL_DETECT_DEBUG
                printf("write error,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
#endif	
			if ((*(dcdata->fd->markbit) & 0x0100) && (0 == endahead))
			{//current pattern transit ahead two cycles
				//Note, 8th bit is clean 0 by main module
				if (0 != *(dcdata->fd->ncoordphase))
				{//next coordphase is not 0
					endahead = 1;
					endcyclen = 0;
					lefttime = 0;
					gettimeofday(&ct,NULL);
					lefttime = (unsigned int)((dcdata->fd->nst) - ct.tv_sec);
					#ifdef FULL_DETECT_DEBUG
					printf("************lefttime: %d,File: %s,Line: %d\n",lefttime,__FILE__,__LINE__);
					#endif
					if (lefttime >= (*(dcdata->fd->cyclet)*3)/2)
					{//use two cyc to end pattern
						c1gt = (lefttime/2 + lefttime%2)/snum - 3 -3;
						c1gmt = (lefttime/2 + lefttime%2)%snum;
						c2gt = (lefttime/2)/snum - 3 - 3;
						c2gmt = (lefttime/2)%snum;
						twocycend = 1;
						onecycend = 0;
					}//use two cyc to end pattern
					else
					{//use one cyc to end pattern
						c2gmt = 0;
						c2gt = 0;
						c1gt = lefttime/snum - 3 -3;
						c1gmt = lefttime%snum;
						twocycend = 0;
						onecycend = 1;				
					}//use one cyc to end pattern
					#ifdef FULL_DETECT_DEBUG
                	printf("c1gt:%d,c1gmt:%d,c2gt:%d,c2gmt:%d,twocycend:%d,onecycend:%d,Line:%d\n", \
                    	c1gt,c1gmt,c2gt,c2gmt,twocycend,onecycend,__LINE__);
                	#endif
				}//next coordphase is not 0
			}//current pattern transit ahead two cycles

			if (1 == endahead)
            {
                endcyclen += 1;
				if (1 == endcyclen)
                {
                    sinfo.cyclet = (c1gt + 3 + 3)*snum + c1gmt;
                }
                if (3 == endcyclen)
                {
                    endcyclen = 2;
                    ct.tv_sec = 0;
                    ct.tv_usec = 200000;
                    select(0,NULL,NULL,NULL,&ct);
                    cycarr = 1;
                    continue;
                }
                if (2 == endcyclen)
                {
                    if ((1 == onecycend) && (0 == twocycend))
                    {
                        endcyclen = 2;
                        ct.tv_sec = 0;
                        ct.tv_usec = 200000;
                        select(0,NULL,NULL,NULL,&ct);
                        cycarr = 1;
                        continue;
                    }
					sinfo.cyclet = (c2gt + 3 + 3)*snum + c2gmt;
                }
			//	#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//if ((30 != *(sadata->fd->contmode)) && (31 != *(sadata->fd->contmode)))
						*(dcdata->fd->v2xmark) |= 0x01;//V2X
						for (i = 0;i < MAX_PHASE_LINE;i++)
						{
							if (0 == phdetect[i].stageid)
								break;
							if (*(dcdata->fd->stageid) == phdetect[i].stageid)
							{
								break;
							}
						}
						for (j = 1; j < (MAX_CHANNEL+1); j++)
						{
							if (phdetect[i].chans & (0x00000001 << (j -1)))
								continue;
							for (z = 0; z < MAX_PHASE_LINE; z++)
							{
								if (0 == phdetect[z].stageid)
									break;
								if (z == i)
									continue;
								downti[6] = 0;
								if (phdetect[z].chans & (0x00000001 << (j - 1)))
								{
									k = i;
									if (z > i)
									{
										while (k != z)
										{
											if (1 == endcyclen)
											{
												downti[6] += c1gt + 3 + 3;	
											}
											else if (2 == endcyclen)
											{
												downti[6] += c2gt + 3 + 3;
											}
											k++;
										}
									}
									if (z < i)
									{
										while (k != z)
										{
											if (0 == phdetect[k].stageid)
											{
												k = 0;
												if (1 == endcyclen)
													downti[6] += c1gmt;
												if (2 == endcyclen)
													downti[6] += c2gmt;
												continue;
											}
											if (1 == endcyclen)
											{
												downti[6] += c1gt + 3 + 3;
											}
											else if (2 == endcyclen)
											{
												downti[6] += c2gt + 3 + 3;
											}
											k++;
										}
									}

									tchans = 0;
									tchans |= (0x00000001 << (j-1));
									downti[1] = 0;
									downti[1] |= (tchans & 0x000000ff);
									downti[2] = 0;
									downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
									downti[3] = 0;
									downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
									downti[4] = 0;
									downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);
									downti[5] = 0;//red color
									#ifdef V2X_DEBUG
									if ((j < 13) || (j > 16))
									{
										dcdata->fd->slg[j-1].slgid = j;
										dcdata->fd->slg[j-1].slgstatus= 0x15;
										dcdata->fd->slg[j-1].countdown = downti[6]+1;
										dcdata->fd->slg[j-1].nslgstatus = 0x17;

										dcdata->fd->slg[j-1].greent = phdetect[z].gtime + phdetect[z].gftime;
                            			dcdata->fd->slg[j-1].yellowt = phdetect[z].ytime;
                            			dcdata->fd->slg[j-1].redt = phdetect[z].rtime;
                            			dcdata->fd->slg[j-1].allrt = 0;
									}
									#endif
									if (!wait_write_serial(*(dcdata->fd->bbserial)))
									{
										if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
									break;
								}//if (phdetect[z].chans & (0x00000001 << (j - 1)))
							}//for (z = 0; z < MAX_PHASE_LINE; z++)
						}//for (j = 1; j < (MAX_CHANNEL+1); j++)	
					}//if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				}//if (*(dcdata->fd->auxfunc) & 0x01)
		//		#endif
            }//if (1 == endahead)
		}//1 == cycarr

		
		memset(pinfo,0,sizeof(dcpinfo_t));
		if (SUCCESS != ms_get_phase_info(dcdata->fd,dcdata->td,tcline,slnum,pinfo))
		{
		#ifdef FULL_DETECT_DEBUG
			printf("get phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
			output_log("Detect control,get phase info err");
		#endif
			ms_end_part_child_thread();
			return;
		}
		//added on 20220715
		adaptd.phasenum += 1;
		adaptd.phi[ni].pid = pinfo->phaseid; 
		adaptd.phi[ni].pming = pinfo->mingtime;
		adaptd.phi[ni].pmaxg = pinfo->maxgtime1;
		//end add
		
		#ifdef CHANNEL_YELLOW_FLASH	
		unsigned char           bcyex = 0;
        unsigned char           bcyft[MAX_CHANNEL] = {0};
        unsigned char           *pbcyft = bcyft;
		if (1 == cyft.mark)
		{
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{
				if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}

			cyft.mark = 0;
			for (i = 0; i < MAX_CHANNEL; i++)
			{
				if (0 == cyft.chan[i])
					break;
				bcyex = 0;
				if (cyfe & (0x01 << (cyft.chan[i] - 1)))
				{
					bcyex = 1;
				}
				if (0 == bcyex)
				{
					*pbcyft = cyft.chan[i];
					pbcyft++;
				}
			}
			
			pthread_cancel(yfcpid);
        	pthread_join(yfcpid,NULL);

			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),bcyft,0x00))
			{
			#ifdef TIMING_DEBUG
				printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			}
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,bcyft,0x00,dcdata->fd->markbit))
			{
			#ifdef TIMING_DEBUG
				printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			}
		}//1 == cyft.mark
		#endif

		#ifdef CHANNEL_CLOSE
        unsigned char           bex = 0;
        unsigned char           bft[MAX_CHANNEL] = {0};
        unsigned char           *pbft = bft;
        if (1 == cyft.mark)
        {
            cyfn = 0;
            cyfe = 0;
            for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
            {
                if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
                {
                    cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
                    break;
                }
            }
            cyft.mark = 0;
			for (i = 0; i < MAX_CHANNEL; i++)
            {
                if (0 == cyft.chan[i])
                    break;
                bex = 0;
                if (cyfe & (0x01 << (cyft.chan[i] - 1)))
                {
                    bex = 1;
                }
                if (0 == bex)
                {
                    *pbft = cyft.chan[i];
                    pbft++;
                }
            }

			channel_close_end_report(dcdata->fd->sockfd->csockfd,bft);

            if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),bft,0x00))
            {
            #ifdef TIMING_DEBUG
                printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
            if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,bft,0x00,dcdata->fd->markbit))
            {
            #ifdef TIMING_DEBUG
                printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
		}//1 == cyft.mark
        #endif

		*(dcdata->fd->phaseid) = 0;
		*(dcdata->fd->phaseid) |= (0x01 << (pinfo->phaseid - 1));
		sinfo.stage = *(dcdata->fd->stageid);
        sinfo.phase = *(dcdata->fd->phaseid);

		if ((*(dcdata->fd->markbit) & 0x0100) && (1 == endahead))
		{//end pattern ahead two cycles
			#ifdef FULL_DETECT_DEBUG
			printf("End pattern two cycles AHEAD, begin %d cycle,Line:%d\n",endcyclen,__LINE__);
			#endif
			*(dcdata->fd->color) = 0x02;
			*(dcdata->fd->markbit) &= 0xfbff;
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
           	{
           	#ifdef FULL_DETECT_DEBUG
               	printf("set green err,File: %s,Line: %d\n",__FILE__,__LINE__);
           	#endif
               	gettimeofday(&ct,NULL);
               	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
               	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
               	#endif
               	}
				*(dcdata->fd->markbit) |= 0x0800;
           	}
			#ifdef CHANNEL_YELLOW_FLASH
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{		
				if (pinfo->phaseid	== dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel yellow flash
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime -1;//for thread exit
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;
				int yfarg = pthread_create(&yfcpid,NULL,(void *)ms_channel_yellow_flash,&cyft);
				if (0 != yfarg)
				{
				#ifdef TIMING_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
				else
				{//create channel yellow flash thread success;
				#ifdef TIMING_DEBUG
					printf("Create channel yellow flash thread success,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//actively report is not probitted and connect successfully
						sinfo.time = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime - 1;
						sinfo.conmode = *(dcdata->fd->contmode);
						sinfo.color = 0x05;//yellow flash
						sinfo.chans = 0;
						memset(sinfo.csta,0,sizeof(sinfo.csta));
						csta = sinfo.csta;
						for (i = 0; i < YFCHANNEL; i++)
						{
							if (0 == cyfc[i])
								break;
							sinfo.chans += 1;
							tcsta = cyfc[i];
							tcsta <<= 2;
							tcsta &= 0xfc;
							tcsta |= 0x00;
							*csta = tcsta;
							csta++;
						}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
						if (SUCCESS != status_info_report(sibuf,&sinfo))	
						{
						#ifdef TIMING_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						else
						{
							write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
						}
					}//actively report is not probitted and connect successfully
				}//create channel yellow flash thread success;
			}//exist channel yellow flash
			#endif			

			#ifdef CHANNEL_CLOSE
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{
				if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel close lamp
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;

				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),cyfc,0x03))
				{
				#ifdef TIMING_DEBUG
					printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,cyfc,0x03,dcdata->fd->markbit))
				{
				#ifdef TIMING_DEBUG
					printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				channel_close_begin_report(dcdata->fd->sockfd->csockfd,cyfc);
				
			}//exist channel close lamp
			#endif

           	memset(&gtime,0,sizeof(gtime));
           	gettimeofday(&gtime,NULL);
           	memset(&gftime,0,sizeof(gftime));
           	memset(&ytime,0,sizeof(ytime));
           	memset(&rtime,0,sizeof(rtime));

           	if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02,dcdata->fd->markbit))
            {
            #ifdef FULL_DETECT_DEBUG
               	printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
            #endif
            }
			if (0 == pinfo->cchan[0])	
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					if (1 == endcyclen)
					{
						if (snum == (slnum + 1))
                    	{
                        	sinfo.time = c1gt + c1gmt + 3 + 3;
                    	}
                    	else
                    	{
                        	sinfo.time = c1gt + 3 + 3;
                    	}
					}
					if (2 == endcyclen)
					{
						if (snum == (slnum + 1))
                    	{
                        	sinfo.time = c2gt + c2gmt + 3 + 3;
                    	}
                    	else
                    	{
                        	sinfo.time = c2gt + 3 + 3;
                    	}
					}
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.color = 0x02;
					sinfo.chans = 0;
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
                		if (0 == pinfo->chan[i])
                    		break;
                		sinfo.chans += 1;
                		tcsta = pinfo->chan[i];
                		tcsta <<= 2;
                		tcsta &= 0xfc;
                		tcsta |= 0x02;
                		*csta = tcsta;
                		csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
			else
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					if (1 == endcyclen)
					{
						if (snum == (slnum + 1))
                    	{
                        	sinfo.time = c1gt + c1gmt + 3;
                    	}
                    	else
                    	{
                        	sinfo.time = c1gt + 3;
                    	}
					}
					if (2 == endcyclen)
					{
						if (snum == (slnum + 1))
                    	{
                        	sinfo.time = c2gt + c2gmt + 3;
                    	}
                    	else
                    	{
                        	sinfo.time = c2gt + 3;
                    	}
					}
					sinfo.conmode = *(dcdata->fd->contmode);//added on 2015052
					sinfo.color = 0x02;
					sinfo.chans = 0;
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
                		if (0 == pinfo->chan[i])
                    		break;
                		sinfo.chans += 1;
                		tcsta = pinfo->chan[i];
                		tcsta <<= 2;
                		tcsta &= 0xfc;
                		tcsta |= 0x02;
                		*csta = tcsta;
                		csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            {//send down time data to configure tool
               	memset(&timedown,0,sizeof(timedown));
               	timedown.mode = *(dcdata->fd->contmode);
               	timedown.pattern = *(dcdata->fd->patternid);
               	timedown.lampcolor = 0x02;
				if (1 == endcyclen)
				{
					if (snum == (slnum + 1))
					{
						timedown.lamptime = c1gt + c1gmt + 3;//default 3 second green flash
					}
					else
					{
						timedown.lamptime = c1gt + 3;
					}
				}
				if (2 == endcyclen)
				{
					if (snum == (slnum + 1))
					{
						timedown.lamptime = c2gt + c2gmt + 3;
					}
					else
					{
						timedown.lamptime = c2gt + 3;
					}
				}
				timedown.phaseid = pinfo->phaseid;
               	timedown.stageline = pinfo->stageline;
               	if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
               	#endif
               	}
			}//send down time data to configure tool
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
                memset(&timedown,0,sizeof(timedown));
               	timedown.mode = *(dcdata->fd->contmode);
               	timedown.pattern = *(dcdata->fd->patternid);
               	timedown.lampcolor = 0x02;
				if (1 == endcyclen)
				{
					if (snum == (slnum + 1))
					{
						timedown.lamptime = c1gt + c1gmt + 3;//default 3 second green flash
					}
					else
					{
						timedown.lamptime = c1gt + 3;
					}
				}
				if (2 == endcyclen)
				{
					if (snum == (slnum + 1))
					{
						timedown.lamptime = c2gt + c2gmt + 3;
					}
					else
					{
						timedown.lamptime = c2gt + 3;
					}
				}
				timedown.phaseid = pinfo->phaseid;
               	timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif

			//send down time data to face board
			if (*(dcdata->fd->contmode) < 27)
				fbdata[1] = *(dcdata->fd->contmode) + 1;
			else
				fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
				fbdata[3] = 0x02;
				if (1 == endcyclen)
				{
					if (snum == (slnum + 1))
					{
						fbdata[4] = c1gt + c1gmt + 3;
					}
					else
					{
						fbdata[4] = c1gt + 3;
					}
				}
				if (2 == endcyclen)
				{
					if (snum == (slnum + 1))
					{
						fbdata[4] = c2gt + c2gmt + 3;
					}
					else
					{
						fbdata[4] = c2gt + 3;
					}
				}
			}
			if (!wait_write_serial(*(dcdata->fd->fbserial)))
            {
               	if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
               	#endif
					*(dcdata->fd->markbit) |= 0x0800;
                   	gettimeofday(&ct,NULL);
                   	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                   	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                   	{
                   	#ifdef FULL_DETECT_DEBUG
                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                   	#endif
                   	}
               	}
            }
            else
            {
            #ifdef FULL_DETECT_DEBUG
               	printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			sendfaceInfoToBoard(dcdata->fd,fbdata);
	//		#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				unsigned char			jishu = 0;
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					for (j = 0; j < MAX_CHANNEL; j++)
					{//for (j = 0; j < MAX_CHANNEL; j++)
						if (0 == (pinfo->chan[j]))
							break;
						downti[6] = 0;
						jishu = 0;
						for (z = 0; z < MAX_PHASE_LINE; z++)
						{//for (z = 0; z < MAX_PHASE_LINE; z++)
							if (0 == phdetect[z].stageid)
								break;
							if (phdetect[z].stageid == (pinfo->stageline))
							{
								jishu += 1;
								if (1 == endcyclen)
									downti[6] += c1gt + 3;
								if (2 == endcyclen)
									downti[6] += c2gt + 3;
								break;
							}//if (phdetect[z].stageid == (pinfo->stageline))	
						}//for (z = 0; z < MAX_PHASE_LINE; z++)
						k = z + 1;
						s = z; //backup 'z';
						while (1)
						{
							if (0 == phdetect[k].stageid)
							{
								if (1 == endcyclen)
									downti[6] += c1gmt;
								if (2 == endcyclen)
									downti[6] += c2gmt;
								k = 0;
								continue;
							}
							if (k == s)
								break;
							if (phdetect[k].chans & (0x00000001 << (pinfo->chan[j] - 1)))
							{
								downti[6] += 3;//default 3 second yellow lamp
								if (1 == endcyclen)
									downti[6] += c1gt + 3;
								if (2 == endcyclen)
									downti[6] += c2gt + 3;
								#if 0
								downti[6] += phdetect[z].ytime + phdetect[z].rtime;
								downti[6] += phdetect[k].gtime + phdetect[k].gftime;
								#endif
								jishu += 1;
							}
							else
							{
								break;
							}
							z = k;
							k++;
						}
						if (snum == jishu)
						{
							downti[6] = 0xff;
						}//the channel is included in all phase;
						tchans = 0;
						tchans |= (0x00000001 << ((pinfo->chan[j])-1));
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);
						downti[5] = 0x02;
						
						#ifdef V2X_DEBUG
						if ((pinfo->chan[j] < 13) || (pinfo->chan[j] > 16))
						{
							dcdata->fd->slg[(pinfo->chan[j])-1].slgid = pinfo->chan[j];
							dcdata->fd->slg[(pinfo->chan[j])-1].slgstatus= 0x17;
							if (0xff == downti[6])
							{
								dcdata->fd->slg[(pinfo->chan[j])-1].countdown = downti[6];
								dcdata->fd->slg[(pinfo->chan[j])-1].nslgstatus = 0x17;

								dcdata->fd->slg[(pinfo->chan[j])-1].greent = downti[6];
							}
							else
							{
								dcdata->fd->slg[(pinfo->chan[j])-1].countdown = downti[6]+1;
								dcdata->fd->slg[(pinfo->chan[j])-1].nslgstatus = 0x16;

								dcdata->fd->slg[(pinfo->chan[j])-1].greent = downti[6] + 1;
							}
							
							dcdata->fd->slg[(pinfo->chan[j])-1].yellowt = pinfo->ytime;
							dcdata->fd->slg[(pinfo->chan[j])-1].redt = pinfo->rtime;
							dcdata->fd->slg[(pinfo->chan[j])-1].allrt = 0;
						}
						#endif

						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}//for (j = 0; j < MAX_CHANNEL; j++)
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}
			}//if (*(dcdata->fd->auxfunc) & 0x01)
		//	#endif

			if (1 == endcyclen)
			{
				if (snum == (slnum + 1))
				{
			//		sleep(c1gt + c1gmt);
					sltime = c1gt + c1gmt;
				}
				else
				{
			//		sleep(c1gt);
					sltime = c1gt;
				}
			}
			if (2 == endcyclen)
			{
				if (snum == (slnum + 1))
				{
			//		sleep(c2gt + c2gmt);
					sltime = c2gt + c2gmt;
				}
				else
				{
			//		sleep(c2gt);
					sltime = c2gt;
				}
			}

			while (1)	
			{
				FD_ZERO(&nRead);
				FD_SET(*(dcdata->fd->ffpipe),&nRead);
				lasttime.tv_sec = 0;
				lasttime.tv_usec = 0;
				gettimeofday(&lasttime,NULL);
				bakv = sltime;
				mtime.tv_sec = sltime;
				mtime.tv_usec = 0;
				int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
				if (mret < 0)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					break;
				}
				if (0 == mret)
				{
					break;
				}
				if (mret > 0)
				{
					if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
					{
						memset(buf,0,sizeof(buf));
						read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
						if (!strncmp(buf,"fastforward",11))
						{
							break;
						}
						else
						{
							nowtime.tv_sec = 0;
                        	nowtime.tv_usec = 0;
                        	gettimeofday(&nowtime,NULL);
                        	leatime = nowtime.tv_sec - lasttime.tv_sec;
                        	sltime -= leatime;
							if (sltime > bakv)
								sltime = bakv;
                        	continue;
						}
					}
					else
					{
						nowtime.tv_sec = 0;
						nowtime.tv_usec = 0;
						gettimeofday(&nowtime,NULL);
						leatime = nowtime.tv_sec - lasttime.tv_sec;
						sltime -= leatime;
						if (sltime > bakv)
                            sltime = bakv;
						continue;
					}
				}//mret > 0
			}//while (1)		

			//begin to green flash				
			if (0 != pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
        		{//actively report is not probitted and connect successfully
					sinfo.time = 3;
					sinfo.color = 0x03;//green flash
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
            		{
                		if (0 == pinfo->cchan[i])
                    		break;
                		for (j = 0; j < sinfo.chans; j++)
                		{
                    		if (0 == sinfo.csta[j])
                        		break;
                    		tcsta = sinfo.csta[j];
                    		tcsta &= 0xfc;
                    		tcsta >>= 2;
                    		tcsta &= 0x3f;
                    		if (tcsta == pinfo->cchan[i])
                    		{
                        		sinfo.csta[j] &= 0xfc;
                        		sinfo.csta[j] |= 0x03;
								break;
                    		}
                		}
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}
				}//actively report is not probitted and connect successfully			
			}

			memset(&gtime,0,sizeof(gtime));
			memset(&gftime,0,sizeof(gftime));
			gettimeofday(&gftime,NULL);
			memset(&ytime,0,sizeof(ytime));
			memset(&rtime,0,sizeof(rtime));
			*(dcdata->fd->markbit) |= 0x0400;
			if (pinfo->gftime > 0)
			{
				gft = 0;
				while (1)
				{
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x02))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x02, \
													dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}	
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x03))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x03, \
													   dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);
					gft += 1;
					if (gft >= 3)
						break;	
				}
			}//if (pinfo->gftime > 0)	
			//end green flash
			if (1 == phcon)
            {
                *(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			#ifdef RED_FLASH	
			if (0 == dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].StageId)
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][0].SpecFunc & 0xe0) >> 5;
			}
			else
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].SpecFunc & 0xe0) >> 5;
			}
			if (rft > 0)
			{
				redflash_dc		dc;
				dc.tcline = tcline;
				dc.slnum = slnum;
				dc.snum =	snum;
				dc.rft = rft;
				dc.chan = pinfo->chan;
				dc.dc = dcdata;
				int rfarg = pthread_create(&rfpid,NULL,(void *)ms_red_flash,&dc);
				if (0 != rfarg)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
			}//if (rft > 0) 
			#endif
	
			//Begin to set yellow lamp 
			if (1 == (pinfo->cpcexist))
			{//person channels exist in current phase
				//all person channels will be set red lamp;
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cpchan,0x00))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
               		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
               		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
               		{
               		#ifdef FULL_DETECT_DEBUG
                   		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
               		#endif
               		}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cpchan,0x00, \
                                                   dcdata->fd->markbit))
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
               	#endif
               	}	
				//other change channels will be set yellow lamp;
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cnpchan,0x01))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                   	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                   	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                   	{
                   	#ifdef FULL_DETECT_DEBUG
                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                   	#endif
                   	}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cnpchan,0x01, \
                                                   dcdata->fd->markbit))
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
               	#endif
               	}
			//	#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//11
						*(dcdata->fd->v2xmark) |= 0x01;//V2X
						tchans = 0;
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == (pinfo->cnpchan[j]))
								break;
							tchans |= (0x00000001 << ((pinfo->cnpchan[j]) - 1));
						}
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
						downti[5] = 0x01;
						downti[6] = 3;
						#ifdef V2X_DEBUG                    
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == (pinfo->cnpchan[j]))
								break;
							dcdata->fd->slg[(pinfo->cnpchan[j])-1].slgid = pinfo->cnpchan[j];
							dcdata->fd->slg[(pinfo->cnpchan[j])-1].slgstatus= 0x16;
							dcdata->fd->slg[(pinfo->cnpchan[j])-1].countdown = downti[6]+1;
							dcdata->fd->slg[(pinfo->cnpchan[j])-1].nslgstatus = 0x15;
						}
						#endif
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						for (j = 0; j < MAX_CHANNEL; j++)
						{//2
							if (0 == pinfo->cpchan[j])
								break;
							downti[6] = 0;
							for (z = 0; z < MAX_PHASE_LINE; z++)
							{//for (z = 0; z < MAX_PHASE_LINE; z++)
								if (0 == phdetect[z].stageid)
									break;
								if (phdetect[z].stageid == (pinfo->stageline))
								{
									downti[6] += 3;//3 seconds yellow lamp
									break;
								}//if (phdetect[z].stageid == (pinfo->stageline))	
							}//for (z = 0; z < MAX_PHASE_LINE; z++)
							k = z + 1;
							s = z; //backup 'z'
							while (1)
							{
								if (0 == phdetect[k].stageid)
								{
									if (1 == endcyclen)
										downti[6] += c1gmt;
									if (2 == endcyclen)
										downti[6] += c2gmt;
									k = 0;
									continue;
								}
								if (k == s)
									break;
								if (phdetect[k].chans & (0x00000001 << (pinfo->cpchan[j] - 1)))
								{
									break;
								}
								else
								{
									if (1 == endcyclen)
										downti[6] += c1gt + 3 + 3;//3 seconds gflash and 3 seconds yellow
									if (2 == endcyclen)
										downti[6] += c2gt + 3 + 3;
								}
								z = k;
								k++;
							}
							tchans = 0;
							tchans |= (0x00000001 << (pinfo->cpchan[j] - 1));
							downti[1] = 0;
							downti[1] |= (tchans & 0x000000ff);
							downti[2] = 0;
							downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
							downti[3] = 0;
							downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
							downti[4] = 0;
							downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
							downti[5] = 0x00;
							if (!wait_write_serial(*(dcdata->fd->bbserial)))
							{
								if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
								{
								#ifdef FULL_DETECT_DEBUG
									printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}
							}
							else
							{
							#ifdef FULL_DETECT_DEBUG
								printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}	
						}//2
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}	
					}//11	
				}//if (*(dcdata->fd->auxfunc) & 0x01)
		//		#endif
			}//person channels exist in current phase
			else
			{//Not person channels in current phase
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x01))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                   	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                   	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                   	{
                   	#ifdef FULL_DETECT_DEBUG
                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                   	#endif
                   	}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x01, \
                                                   dcdata->fd->markbit))
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
               	#endif
               	}
			//	#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//11
						*(dcdata->fd->v2xmark) |= 0x01;//V2X
						tchans = 0;
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == (pinfo->cchan[j]))
								break;
							tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
						}
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
						downti[5] = 0x01;
						downti[6] = 3;
						#ifdef V2X_DEBUG                    
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == (pinfo->cchan[j]))
								break;
							dcdata->fd->slg[(pinfo->cchan[j])-1].slgid = pinfo->cchan[j];
							dcdata->fd->slg[(pinfo->cchan[j])-1].slgstatus= 0x16;
							dcdata->fd->slg[(pinfo->cchan[j])-1].countdown = downti[6]+1;
							dcdata->fd->slg[(pinfo->cchan[j])-1].nslgstatus = 0x15;
						}
						#endif
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}//11
				}//if (*(dcdata->fd->auxfunc) & 0x01)
		//		#endif
			}//Not person channels in current phase
			if (0 != pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
        		{//actively report is not probitted and connect successfully
					sinfo.time = 3;
					sinfo.color = 0x01;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
            		{
               			if (0 == pinfo->cnpchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                       			break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cnpchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
                       			sinfo.csta[j] |= 0x01;
								break;
                   			}
               			}
            		}
					for (i = 0; i < MAX_CHANNEL; i++)
                	{
                    	if (0 == pinfo->cpchan[i])
                        	break;
                    	for (j = 0; j < sinfo.chans; j++)
                    	{
                        	if (0 == sinfo.csta[j])
                            	break;
                        	tcsta = sinfo.csta[j];
                        	tcsta &= 0xfc;
                        	tcsta >>= 2;
                        	tcsta &= 0x3f;
                        	if (tcsta == pinfo->cpchan[i])
                        	{
                            	sinfo.csta[j] &= 0xfc;
								break;
                        	}
                    	}
                	}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}
				}//actively report is not probitted and connect successfully
			}

			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
           	{
               	memset(&timedown,0,sizeof(timedown));
               	timedown.mode = *(dcdata->fd->contmode);
               	timedown.pattern = *(dcdata->fd->patternid);
               	timedown.lampcolor = 0x01;
				timedown.lamptime = 3;	
               	timedown.phaseid = pinfo->phaseid;
               	timedown.stageline = pinfo->stageline;
               	if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
               	#endif
               	}
           	}
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
               	memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x01;
                timedown.lamptime = 3;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline; 
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif
			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
           		fbdata[3] = 0x01;
				fbdata[4] = 3;
			}
           	if (!wait_write_serial(*(dcdata->fd->fbserial)))
           	{
		       	if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
               	#endif
					*(dcdata->fd->markbit) |= 0x0800;
                   	gettimeofday(&ct,NULL);
                   	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                   	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                   	{
                   	#ifdef FULL_DETECT_DEBUG
                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                   	#endif
                   	}
               	}
           	}
           	else
           	{
           	#ifdef FULL_DETECT_DEBUG
               	printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
           	#endif
           	}
			sendfaceInfoToBoard(dcdata->fd,fbdata);
			*(dcdata->fd->color) = 0x01;
			memset(&gtime,0,sizeof(gtime));
           	memset(&gftime,0,sizeof(gftime));
           	memset(&ytime,0,sizeof(ytime));
			gettimeofday(&ytime,NULL);
           	memset(&rtime,0,sizeof(rtime));
			sleep(3);
			//end set yellow lamp

			//Begin to set red lamp
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x00))
			{
			#ifdef FULL_DETECT_DEBUG
				printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				gettimeofday(&ct,NULL);
               	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
               	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
               	{
               	#ifdef FULL_DETECT_DEBUG
                   	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
               	#endif
               	}
				*(dcdata->fd->markbit) |= 0x0800;
			}
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x00, \
											dcdata->fd->markbit))
           	{
           	#ifdef FULL_DETECT_DEBUG
               	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
           	#endif
           	}
			*(dcdata->fd->color) = 0x00;

			if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
        	{//actively report is not probitted and connect successfully
				sinfo.time = 0;
				sinfo.color = 0x00;
				sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
				for (i = 0; i < MAX_CHANNEL; i++)
            	{
               		if (0 == pinfo->cchan[i])
                    	break;
                	for (j = 0; j < sinfo.chans; j++)
                	{
                    	if (0 == sinfo.csta[j])
                       		break;
                    	tcsta = sinfo.csta[j];
                    	tcsta &= 0xfc;
                    	tcsta >>= 2;
                    	tcsta &= 0x3f;
                    	if (tcsta == pinfo->cchan[i])
                    	{
                        	sinfo.csta[j] &= 0xfc;
							break;
                    	}
                	}
            	}
				memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            	memset(sibuf,0,sizeof(sibuf));
            	if (SUCCESS != status_info_report(sibuf,&sinfo))
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
            	else
            	{
                	write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            	}
			}//actively report is not probitted and connect successfully
		
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					for (j = 0; j < MAX_CHANNEL; j++)
					{//2
						if (0 == pinfo->cchan[j])
							break;
						downti[6] = 0;
						for (z = 0; z < MAX_PHASE_LINE; z++)
						{//for (z = 0; z < MAX_PHASE_LINE; z++)
							if (0 == phdetect[z].stageid)
								break;
							if (phdetect[z].stageid == (pinfo->stageline))
							{
								//default red lamp is 0
								break;
							}//if (phdetect[z].stageid == (pinfo->stageline))	
						}//for (z = 0; z < MAX_PHASE_LINE; z++)
						k = z + 1;
						s = z; //backup 'z'
						while (1)
						{
							if (0 == phdetect[k].stageid)
							{
								if (1 == endcyclen)
									downti[6] += c1gmt;
								if (2 == endcyclen)
									downti[6] += c2gmt;
								k = 0;
								continue;
							}
							if (k == s)
								break;
							if (phdetect[k].chans & (0x00000001 << (pinfo->cchan[j] - 1)))
							{
								break;
							}
							else
							{
								if (1 == endcyclen)
									downti[6] += c1gt + 3 + 3;
								if (2 == endcyclen)
									downti[6] += c2gt + 3 + 3;	
							}
							z = k;
							k++;
						}
						tchans = 0;
						tchans |= (0x00000001 << (pinfo->cchan[j] - 1));
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
						downti[5] = 0x00;
						#ifdef V2X_DEBUG
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[(pinfo->cchan[j])-1].slgid = pinfo->cchan[j];
							dcdata->fd->slg[(pinfo->cchan[j])-1].slgstatus= 0x15;
							dcdata->fd->slg[(pinfo->cchan[j])-1].countdown = downti[6]+1;
							dcdata->fd->slg[(pinfo->cchan[j])-1].nslgstatus = 0x17;
						}
						#endif
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}	
					}//2
				}
			}//if (*(dcdata->fd->auxfunc) & 0x01)

			ni += 1;//20220621
			slnum += 1;
			*(dcdata->fd->slnum) = slnum;
			*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
			{
				cycarr = 1;
				slnum = 0;
				*(dcdata->fd->slnum) = 0;
				*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			}				

			#ifdef RED_FLASH
            if (rft > (pinfo->ytime + pinfo->rtime))
            {
                sleep(rft - (pinfo->ytime) - (pinfo->rtime));
            }
            #endif
			if (1 == phcon)
            {
				*(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }

			continue;
		}//end pattern ahead two cycles

		validmark = 0;
#if 0
		if ((0x80 != (pinfo->phasetype)) && (0x04 != (pinfo->phasetype)))
		{//fix or person type phase do not need degrade;
			for (j = 0; j < MAX_PHASE_LINE; j++)
			{
				if (0 == phdetect[j].phaseid)
					break;
				if (pinfo->phaseid == phdetect[j].phaseid)
				{
					validmark = phdetect[j].validmark;
					break;
				}	
			}
		}//fix or person type phase do not need degrade;
		else
		{
			validmark = 1;
		}
#endif
		if (degrade & (0x00000001 << (pinfo->phaseid - 1)))
		{
            validmark = 0;
		
			gettimeofday(&ct,NULL);
            update_event_list(dcdata->fd->ec,dcdata->fd->el,1,128,ct.tv_sec,dcdata->fd->markbit);
			*(dcdata->fd->phasedegrphid) |= (0x00000001 << (pinfo->phaseid -1));//add 20220801
			
			memset(err1,0,sizeof(err1));
			if (SUCCESS != err_report(err1,ct.tv_sec,21,(50+(pinfo->phaseid - 1))))
            {
            #ifdef FULL_DETECT_DEBUG
            	printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
            else
            {
            	write(*(dcdata->fd->sockfd->csockfd),err1,sizeof(err1));
            }
		}
        else
        {
            validmark = 1;
			if (*(dcdata->fd->phasedegrphid) & (0x00000001 << (pinfo->phaseid - 1)))
			{
				*(dcdata->fd->phasedegrphid) &= (~(0x00000001 << (pinfo->phaseid - 1)));
				gettimeofday(&ct,NULL);
            	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,129,ct.tv_sec,dcdata->fd->markbit);

				memset(err1,0,sizeof(err1));
				if (SUCCESS != err_report(err1,ct.tv_sec,21,(82+(pinfo->phaseid - 1))))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				else
				{
					write(*(dcdata->fd->sockfd->csockfd),err1,sizeof(err1));
				}
			}
        }

		if (0 == validmark)//降级模式
		{
		#ifdef FULL_DETECT_DEBUG
			printf("**************Begin to degrade 'Timing Control',File:%s,Line:%d\n",__FILE__,__LINE__);
		#endif

			//added on 20220620
			adaptd.phi[ni].paddt = 0;
			adaptd.phi[ni].pfactt = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phasestarttime = ct.tv_sec;
			//endif
		
			*(dcdata->fd->color) = 0x02;
			*(dcdata->fd->markbit) &= 0xfbff;
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
            {
            #ifdef FULL_DETECT_DEBUG
                printf("set green err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
                gettimeofday(&ct,NULL);
                update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
				*(dcdata->fd->markbit) |= 0x0800;
            }
			#ifdef CHANNEL_YELLOW_FLASH
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{		
				if (pinfo->phaseid	== dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel yellow flash
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime -1;//for thread exit
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;
				int yfarg = pthread_create(&yfcpid,NULL,(void *)ms_channel_yellow_flash,&cyft);
				if (0 != yfarg)
				{
				#ifdef TIMING_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
				else
				{//create channel yellow flash thread success;
				#ifdef TIMING_DEBUG
					printf("Create channel yellow flash thread success,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//actively report is not probitted and connect successfully
						sinfo.time = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime - 1;
						sinfo.conmode = *(dcdata->fd->contmode);
						sinfo.color = 0x05;//yellow flash
						sinfo.chans = 0;
						memset(sinfo.csta,0,sizeof(sinfo.csta));
						csta = sinfo.csta;
						for (i = 0; i < YFCHANNEL; i++)
						{
							if (0 == cyfc[i])
								break;
							sinfo.chans += 1;
							tcsta = cyfc[i];
							tcsta <<= 2;
							tcsta &= 0xfc;
							tcsta |= 0x00;
							*csta = tcsta;
							csta++;
						}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
						if (SUCCESS != status_info_report(sibuf,&sinfo))	
						{
						#ifdef TIMING_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						else
						{
							write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
						}
					}//actively report is not probitted and connect successfully
				}//create channel yellow flash thread success;
			}//exist channel yellow flash
			#endif

			#ifdef CHANNEL_CLOSE
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{
				if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel close lamp
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;

				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),cyfc,0x03))
				{
				#ifdef TIMING_DEBUG
					printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,cyfc,0x03,dcdata->fd->markbit))
				{
				#ifdef TIMING_DEBUG
					printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				channel_close_begin_report(dcdata->fd->sockfd->csockfd,cyfc);
				
			}//exist channel close lamp
			#endif

			memset(&gtime,0,sizeof(gtime));
            gettimeofday(&gtime,NULL);
            memset(&gftime,0,sizeof(gftime));
            memset(&ytime,0,sizeof(ytime));
            memset(&rtime,0,sizeof(rtime));

            if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02,dcdata->fd->markbit))
            {
            #ifdef FULL_DETECT_DEBUG
                printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
            #endif
            }
			if (0 == pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;	
					sinfo.color = 0x02;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
               			if (0 == pinfo->chan[i])
                   			break;
               			sinfo.chans += 1;
               			tcsta = pinfo->chan[i];
               			tcsta <<= 2;
               			tcsta &= 0xfc;
               			tcsta |= 0x02;
               			*csta = tcsta;
               			csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
			else
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->gtime + pinfo->gftime;	
					sinfo.color = 0x02;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
               			if (0 == pinfo->chan[i])
                   			break;
               			sinfo.chans += 1;
               			tcsta = pinfo->chan[i];
               			tcsta <<= 2;
               			tcsta &= 0xfc;
               			tcsta |= 0x02;
               			*csta = tcsta;
               			csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x02;
                timedown.lamptime = pinfo->gtime + pinfo->gftime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
               	memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x02;
                timedown.lamptime = pinfo->gtime + pinfo->gftime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline; 
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif
			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
            	fbdata[3] = 0x02;
            	fbdata[4] = pinfo->gtime + pinfo->gftime;
			}
            if (!wait_write_serial(*(dcdata->fd->fbserial)))
            {
                if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					*(dcdata->fd->markbit) |= 0x0800;
                    gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
            }
            else
            {
            #ifdef FULL_DETECT_DEBUG
                printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			sendfaceInfoToBoard(dcdata->fd,fbdata);
		//	#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					for (i = 0; i < MAX_PHASE_LINE; i++)
					{
						if (0 == phdetect[i].stageid)
							break;
						if (pinfo->stageline == phdetect[i].stageid)
							break;
					}
					tchans = 0;
					downti[6] = 0;
					if (i != MAX_PHASE_LINE)
					{
						if (0 == phdetect[i+1].stageid)
						{
							tchans = phdetect[0].chans;
						}
						else
						{
							tchans = phdetect[i+1].chans;
						}
						downti[6] += phdetect[i].gtime + phdetect[i].gftime + \
									phdetect[i].ytime + phdetect[i].rtime;
						for (j = 0; j < MAX_CHANNEL; j++)
						{//for (j = 0; j < MAX_CHANNEL; j++)
							if (0 == (pinfo->chan[j]))
								break;
							if (tchans & (0x00000001 << (pinfo->chan[j] - 1)))
								tchans &= (~(0x00000001 << (pinfo->chan[j] - 1)));
						}//for (j = 0; j < MAX_CHANNEL; j++)
					}//if (i != MAX_PHASE_LINE)
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x00;
					#ifdef V2X_DEBUG
					unsigned char		v2xc[MAX_CHANNEL] = {0};
					unsigned char		*pv2xc = v2xc;
					for (j = 1; j < (MAX_CHANNEL+1); j++)
					{
						if (tchans & (0x00000001 << (j-1)))
						{
							*pv2xc = j;
							pv2xc++;
						}
					}
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == v2xc[j])
							break;
						if ((v2xc[j] < 13) || (v2xc[j] > 16))
						{
							dcdata->fd->slg[v2xc[j]-1].slgid = v2xc[j];
							dcdata->fd->slg[v2xc[j]-1].slgstatus = 0x15;
							dcdata->fd->slg[v2xc[j]-1].countdown = downti[6] + 1;
							dcdata->fd->slg[v2xc[j]-1].nslgstatus = 0x17;

							if (0 == phdetect[i+1].stageid)
                        	{
                            	dcdata->fd->slg[v2xc[j]-1].greent = phdetect[0].mingtime + phdetect[0].gftime;
                                dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[0].ytime;
                                dcdata->fd->slg[v2xc[j]-1].redt = phdetect[0].rtime;
                                dcdata->fd->slg[v2xc[j]-1].allrt = 0;
                        	}
                        	else
                        	{
								dcdata->fd->slg[v2xc[j]-1].greent = phdetect[i+1].mingtime + phdetect[i+1].gftime;
								dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[i+1].ytime;
								dcdata->fd->slg[v2xc[j]-1].redt = phdetect[i+1].rtime;
								dcdata->fd->slg[v2xc[j]-1].allrt = 0;
							}
						}
					}
					#endif
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}	

					tchans = 0;
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == (pinfo->cchan[j]))
							break;
						tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
					}
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x02;
					downti[6] = pinfo->gtime + pinfo->gftime;
					#ifdef V2X_DEBUG
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->cchan[j])
							break;
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
                            dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x17;
                            dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
                            dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x16;

							dcdata->fd->slg[pinfo->cchan[j]-1].greent = downti[6] + 1;
							dcdata->fd->slg[pinfo->cchan[j]-1].yellowt = pinfo->ytime;
							dcdata->fd->slg[pinfo->cchan[j]-1].redt = pinfo->rtime;
							dcdata->fd->slg[pinfo->cchan[j]-1].allrt = 0;
						}
					}
					#endif
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)
	//		#endif

			if ((1 == (pinfo->cpcexist)) && ((pinfo->pctime) > 0))
			{//person channels do exist
		//		sleep(pinfo->gtime - pinfo->pctime);
				sltime = pinfo->gtime - pinfo->pctime;
				ffw = 0;
				while (1)	
				{
					FD_ZERO(&nRead);
					FD_SET(*(dcdata->fd->ffpipe),&nRead);
					lasttime.tv_sec = 0;
					lasttime.tv_usec = 0;
					gettimeofday(&lasttime,NULL);
					bakv = sltime;
					mtime.tv_sec = sltime;
					mtime.tv_usec = 0;
					int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
					if (mret < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						break;
					}
					if (0 == mret)
					{
						break;
					}
					if (mret > 0)
					{
						if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
							if (!strncmp(buf,"fastforward",11))
							{
								ffw = 1;
								break;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
                        		continue;
							}
						}
						else
						{
							nowtime.tv_sec = 0;
							nowtime.tv_usec = 0;
							gettimeofday(&nowtime,NULL);
							leatime = nowtime.tv_sec - lasttime.tv_sec;
							sltime -= leatime;
							if (sltime > bakv)
                                sltime = bakv;
							continue;
						}
					}//mret > 0
				}//while (1)	

				if (0 == ffw)
				{
					//Firstly,create thread to pass person channels;
					if (0 == dcpcyes)
					{
						memset(&dpdata,0,sizeof(dpdata));
						dpdata.bbserial = dcdata->fd->bbserial;
						dpdata.pchan = pinfo->cpchan;
						dpdata.markbit = dcdata->fd->markbit;
						dpdata.sockfd = dcdata->fd->sockfd;
						dpdata.cs = dcdata->cs;
						dpdata.time = pinfo->pctime;
						int pcret = pthread_create(&dcpcid,NULL,(void *)ms_person_chan_greenflash,&dpdata);
						if (0 != pcret)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("Create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
							output_log("Detect control,create person greenflash thread err");
						#endif
							ms_end_part_child_thread();
							return;
						}
						dcpcyes = 1;
					}
					if (0 == pinfo->cchan[0])
					{
						if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							sinfo.time = pinfo->pctime + pinfo->gftime + pinfo->ytime + pinfo->rtime;	
							sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
							sinfo.color = 0x02;
							for (i = 0; i < MAX_CHANNEL; i++)
            				{
                				if (0 == pinfo->cpchan[i])
                   					break;
                				for (j = 0; j < sinfo.chans; j++)
                				{
                   					if (0 == sinfo.csta[j])
                       					break;
                   					tcsta = sinfo.csta[j];
                   					tcsta &= 0xfc;
                   					tcsta >>= 2;
                   					tcsta &= 0x3f;
                   					if (tcsta == pinfo->cpchan[i])
                   					{
                       					sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x03;
										break;
                   					}
                				}
            				}
							memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
            				if (SUCCESS != status_info_report(sibuf,&sinfo))
            				{
            				#ifdef FULL_DETECT_DEBUG
                				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            				#endif
            				}
            				else
            				{
                				write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            				}	
						}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					}
					else
					{
						if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							sinfo.time = pinfo->pctime + pinfo->gftime;	
							sinfo.color = 0x02;
							sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
							for (i = 0; i < MAX_CHANNEL; i++)
            				{
                				if (0 == pinfo->cpchan[i])
                   					break;
                				for (j = 0; j < sinfo.chans; j++)
                				{
                   					if (0 == sinfo.csta[j])
                       					break;
                   					tcsta = sinfo.csta[j];
                   					tcsta &= 0xfc;
                   					tcsta >>= 2;
                   					tcsta &= 0x3f;
                   					if (tcsta == pinfo->cpchan[i])
                   					{
                       					sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x03;
										break;
                   					}
                				}
            				}
							memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
            				if (SUCCESS != status_info_report(sibuf,&sinfo))
            				{
            				#ifdef FULL_DETECT_DEBUG
                				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            				#endif
            				}
            				else
            				{
                				write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            				}	
						}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					}

			//		sleep(pinfo->pctime);	
					sltime = pinfo->pctime;
					while (1)	
					{
						FD_ZERO(&nRead);
						FD_SET(*(dcdata->fd->ffpipe),&nRead);
						lasttime.tv_sec = 0;
						lasttime.tv_usec = 0;
						gettimeofday(&lasttime,NULL);
						bakv = sltime;
						mtime.tv_sec = sltime;
						mtime.tv_usec = 0;
						int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
						if (mret < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							break;
						}
						if (0 == mret)
						{
							break;
						}
						if (mret > 0)
						{
							if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
								read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
								if (!strncmp(buf,"fastforward",11))
								{
									break;
								}
								else
								{
									nowtime.tv_sec = 0;
                        			nowtime.tv_usec = 0;
                        			gettimeofday(&nowtime,NULL);
                        			leatime = nowtime.tv_sec - lasttime.tv_sec;
                        			sltime -= leatime;
									if (sltime > bakv)
                                		sltime = bakv;
                        			continue;
								}
							}
							else
							{
								nowtime.tv_sec = 0;
								nowtime.tv_usec = 0;
								gettimeofday(&nowtime,NULL);
								leatime = nowtime.tv_sec - lasttime.tv_sec;
								sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
								continue;
							}
						}//mret > 0
					}//while (1)

					if (1 == dcpcyes)
					{
						pthread_cancel(dcpcid);
						pthread_join(dcpcid,NULL);
						dcpcyes = 0;
					}
				}
			}//person channels do exist
			else
			{//person channels do not exist
		//		sleep(pinfo->gtime);
				sltime = pinfo->gtime;
				while (1)	
				{
					FD_ZERO(&nRead);
					FD_SET(*(dcdata->fd->ffpipe),&nRead);
					lasttime.tv_sec = 0;
					lasttime.tv_usec = 0;
					gettimeofday(&lasttime,NULL);
					bakv = sltime;
					mtime.tv_sec = sltime;
					mtime.tv_usec = 0;
					int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
					if (mret < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						break;
					}
					if (0 == mret)
					{
						break;
					}
					if (mret > 0)
					{
						if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
							if (!strncmp(buf,"fastforward",11))
							{
								break;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
                        		continue;
							}
						}
						else
						{
							nowtime.tv_sec = 0;
							nowtime.tv_usec = 0;
							gettimeofday(&nowtime,NULL);
							leatime = nowtime.tv_sec - lasttime.tv_sec;
							sltime -= leatime;
							if (sltime > bakv)
                                sltime = bakv;
							continue;
						}
					}//mret > 0
				}//while (1)
			}//person channels do not exist

			//Begin to green flash
			if ((0 != pinfo->cchan[0]) && (pinfo->gftime > 0))
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->gftime;	
					sinfo.color = 0x03;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
            			if (0 == pinfo->cchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								sinfo.csta[j] |= 0x03;
								break;
                   			}
               			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
	
			memset(&gtime,0,sizeof(gtime));
			memset(&gftime,0,sizeof(gftime));
			gettimeofday(&gftime,NULL);
			memset(&ytime,0,sizeof(ytime));
			memset(&rtime,0,sizeof(rtime));
			*(dcdata->fd->markbit) |= 0x0400;
			if (pinfo->gftime > 0)
			{
				gft = 0;
				while (1)
				{
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x02))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x02, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}	
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x03))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x03, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					gft += 1;
					if (gft >= (pinfo->gftime))
						break;
				}
			}//if (pinfo->gftime > 0)	
			//end green flash
			if (1 == phcon)
            {
                *(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			#ifdef RED_FLASH	
			if (0 == dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].StageId)
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][0].SpecFunc & 0xe0) >> 5;
			}
			else
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].SpecFunc & 0xe0) >> 5;
			}
			if (rft > 0)
			{
				redflash_dc		dc;
				dc.tcline = tcline;
				dc.slnum = slnum;
				dc.snum =	snum;
				dc.rft = rft;
				dc.chan = pinfo->chan;
				dc.dc = dcdata;
				int rfarg = pthread_create(&rfpid,NULL,(void *)ms_red_flash,&dc);
				if (0 != rfarg)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
			}//if (rft > 0) 
			#endif
	
			//Begin to set yellow lamp 
			if (1 == (pinfo->cpcexist))
			{//person channels exist in current phase
				//all person channels will be set red lamp;
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cpchan,0x00))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                	#endif
                	}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cpchan,0x00, \
                                                    dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }	
				//other change channels will be set yellow lamp;
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cnpchan,0x01))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cnpchan,0x01, \
                                                    dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
			}//person channels exist in current phase
			else
			{//Not person channels in current phase
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x01))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x01, \
                                                    dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
			}//Not person channels in current phase

		//	#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
	#if 0
					tchans = 0;
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == (pinfo->cchan[j]))
							break;
						tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
					}
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
	#endif
					downti[5] = 0x01;
					downti[6] = pinfo->ytime;

					#ifdef V2X_DEBUG
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->cchan[j])
							break;
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
                            dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x16;
                            dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
                            dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x15;	
						}
					}
					#endif

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)
	//		#endif

			if ((0 != pinfo->cchan[0]) && (pinfo->ytime > 0))
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->ytime;	
					sinfo.color = 0x01;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
            			if (0 == pinfo->cnpchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cnpchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								sinfo.csta[j] |= 0x01;
								break;
                   			}
               			}
            		}
					for (i = 0; i < MAX_CHANNEL; i++)
               		{
                   		if (0 == pinfo->cpchan[i])
                       		break;
                   		for (j = 0; j < sinfo.chans; j++)
                   		{
                       		if (0 == sinfo.csta[j])
                           		break;
                       		tcsta = sinfo.csta[j];
                       		tcsta &= 0xfc;
                       		tcsta >>= 2;
                       		tcsta &= 0x3f;
                       		if (tcsta == pinfo->cpchan[i])
                       		{
                           		sinfo.csta[j] &= 0xfc;
								break;
                       		}
                   		}
               		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x01;
                timedown.lamptime = pinfo->ytime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
               	memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x01;
                timedown.lamptime = pinfo->ytime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline; 
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif
			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
            	fbdata[3] = 0x01;
            	fbdata[4] = pinfo->ytime;
			}
            if (!wait_write_serial(*(dcdata->fd->fbserial)))
            {
                if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					*(dcdata->fd->markbit) |= 0x0800;
                    gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
            }
            else
            {
            #ifdef FULL_DETECT_DEBUG
                printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			sendfaceInfoToBoard(dcdata->fd,fbdata);
			*(dcdata->fd->color) = 0x01;
			memset(&gtime,0,sizeof(gtime));
            memset(&gftime,0,sizeof(gftime));
            memset(&ytime,0,sizeof(ytime));
			gettimeofday(&ytime,NULL);
            memset(&rtime,0,sizeof(rtime));
			sleep(pinfo->ytime);
			//end set yellow lamp
			
			//Begin to set red lamp
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x00))
			{
			#ifdef FULL_DETECT_DEBUG
				printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				gettimeofday(&ct,NULL);
                update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
				*(dcdata->fd->markbit) |= 0x0800;
			}
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x00, \
												dcdata->fd->markbit))
            {
            #ifdef FULL_DETECT_DEBUG
                printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }

			*(dcdata->fd->color) = 0x00;
			if (0 != pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->rtime;	
					sinfo.color = 0x00;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
           				if (0 == pinfo->cchan[i])
                  			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								break;
                   			}
               			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))			
			}

			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					downti[5] = 0x00;
					downti[6] = pinfo->rtime;
					#ifdef V2X_DEBUG
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->cchan[j])
							break;
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
							dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x15;
							dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
							dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x17;
						}
					}
					#endif
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)
			if (pinfo->rtime > 0)
            {
				memset(&gtime,0,sizeof(gtime));
            	memset(&gftime,0,sizeof(gftime));
            	memset(&ytime,0,sizeof(ytime));
            	memset(&rtime,0,sizeof(rtime));
            	gettimeofday(&rtime,NULL);

				if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            	{
               		memset(&timedown,0,sizeof(timedown));
               		timedown.mode = *(dcdata->fd->contmode);
               		timedown.pattern = *(dcdata->fd->patternid);
               		timedown.lampcolor = 0x00;
               		timedown.lamptime = pinfo->rtime;
               		timedown.phaseid = pinfo->phaseid;
               		timedown.stageline = pinfo->stageline;
               		if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
               		{
               		#ifdef FULL_DETECT_DEBUG
                   		printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
               		#endif
               		}
            	}
				#ifdef EMBED_CONFIGURE_TOOL
				if (*(dcdata->fd->markbit2) & 0x0200)
				{
					memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x00;
                    timedown.lamptime = pinfo->rtime;
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;	
					if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
					}
				}
				#endif

				//send info to face board
				if (*(dcdata->fd->contmode) < 27)
                	fbdata[1] = *(dcdata->fd->contmode) + 1;
            	else
                	fbdata[1] = *(dcdata->fd->contmode);
				if ((30 == fbdata[1]) || (31 == fbdata[1]))
                {
                    fbdata[2] = 0;
                    fbdata[3] = 0;
                    fbdata[4] = 0;
                }
                else
				{
					fbdata[2] = pinfo->stageline;
            		fbdata[3] = 0x00;
            		fbdata[4] = pinfo->rtime;
				}
            	if (!wait_write_serial(*(dcdata->fd->fbserial)))
            	{
               		if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
               		{
               		#ifdef FULL_DETECT_DEBUG
                   		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
               		#endif
						*(dcdata->fd->markbit) |= 0x0800;
                   		gettimeofday(&ct,NULL);
                   		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                   		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                   		{
                   		#ifdef FULL_DETECT_DEBUG
                       		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                   		#endif
                   		}
               		}
            	}
            	else
            	{
            	#ifdef FULL_DETECT_DEBUG
               		printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
				sendfaceInfoToBoard(dcdata->fd,fbdata);
				sleep(pinfo->rtime);
			}
			//end set red lamp

			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phaseendtime = ct.tv_sec;

			ni += 1;
			slnum += 1;
			*(dcdata->fd->slnum) = slnum;
			*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
			{
				cycarr = 1;
				slnum = 0;
				*(dcdata->fd->slnum) = 0;
				*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			}

			#ifdef RED_FLASH
            if (rft > (pinfo->ytime + pinfo->rtime))
            {
                sleep(rft - (pinfo->ytime) - (pinfo->rtime));
            }
            #endif
			if (1 == phcon)
            {
				*(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }

			continue;
		}

		/*********Not the last two cycles of ending pattern ahead******************/
		if (0x80 == (pinfo->phasetype))
		{//fix phase
			#ifdef FULL_DETECT_DEBUG
			printf("Begin to pass fix phase,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			*(dcdata->fd->color) = 0x02;
			*(dcdata->fd->markbit) &= 0xfbff;
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
			{
			#ifdef FULL_DETECT_DEBUG
				printf("set green err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				gettimeofday(&ct,NULL);
				update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
				*(dcdata->fd->markbit) |= 0x0800;
			}

			//added on 20220620
			adaptd.phi[ni].pfactt = pinfo->fixgtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
        	adaptd.phi[ni].paddt = 0;
			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phasestarttime = ct.tv_sec;
			//end
			
			#ifdef CHANNEL_YELLOW_FLASH
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{		
				if (pinfo->phaseid	== dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel yellow flash
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime -1;//for thread exit
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;
				int yfarg = pthread_create(&yfcpid,NULL,(void *)ms_channel_yellow_flash,&cyft);
				if (0 != yfarg)
				{
				#ifdef TIMING_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
				else
				{//create channel yellow flash thread success;
				#ifdef TIMING_DEBUG
					printf("Create channel yellow flash thread success,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//actively report is not probitted and connect successfully
						sinfo.time = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime - 1;
						sinfo.conmode = *(dcdata->fd->contmode);
						sinfo.color = 0x05;//yellow flash
						sinfo.chans = 0;
						memset(sinfo.csta,0,sizeof(sinfo.csta));
						csta = sinfo.csta;
						for (i = 0; i < YFCHANNEL; i++)
						{
							if (0 == cyfc[i])
								break;
							sinfo.chans += 1;
							tcsta = cyfc[i];
							tcsta <<= 2;
							tcsta &= 0xfc;
							tcsta |= 0x00;
							*csta = tcsta;
							csta++;
						}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
						if (SUCCESS != status_info_report(sibuf,&sinfo))	
						{
						#ifdef TIMING_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						else
						{
							write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
						}
					}//actively report is not probitted and connect successfully
				}//create channel yellow flash thread success;
			}//exist channel yellow flash
			#endif

			#ifdef CHANNEL_CLOSE
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{
				if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel close lamp
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;

				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),cyfc,0x03))
				{
				#ifdef TIMING_DEBUG
					printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,cyfc,0x03,dcdata->fd->markbit))
				{
				#ifdef TIMING_DEBUG
					printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}

				channel_close_begin_report(dcdata->fd->sockfd->csockfd,cyfc);	
			}//exist channel close lamp
			#endif

			memset(&gtime,0,sizeof(gtime));
			gettimeofday(&gtime,NULL);
			memset(&gftime,0,sizeof(gftime));
			memset(&ytime,0,sizeof(ytime));
			memset(&rtime,0,sizeof(rtime));
			
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
												dcdata->fd->markbit))
			{
        	#ifdef FULL_DETECT_DEBUG
            	printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
        	#endif
			}
			
		//	#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					for (i = 0; i < MAX_PHASE_LINE; i++)
					{
						if (0 == phdetect[i].stageid)
							break;
						if (pinfo->stageline == phdetect[i].stageid)
							break;
					}
					tchans = 0;
					downti[6] = 0;
					if (i != MAX_PHASE_LINE)
					{
						if (0 == phdetect[i+1].stageid)
						{
							tchans = phdetect[0].chans;
						}
						else
						{
							tchans = phdetect[i+1].chans;
						}
						downti[6] += phdetect[i].fixgtime + phdetect[i].gftime + \
									phdetect[i].ytime + phdetect[i].rtime;
						for (j = 0; j < MAX_CHANNEL; j++)
						{//for (j = 0; j < MAX_CHANNEL; j++)
							if (0 == (pinfo->chan[j]))
								break;
							if (tchans & (0x00000001 << (pinfo->chan[j] - 1)))
								tchans &= (~(0x00000001 << (pinfo->chan[j] - 1)));
						}//for (j = 0; j < MAX_CHANNEL; j++)
					}//if (i != MAX_PHASE_LINE)
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x00;
					
					#ifdef V2X_DEBUG
                    unsigned char       v2xc[MAX_CHANNEL] = {0};
                    unsigned char       *pv2xc = v2xc;
                    for (j = 1; j < (MAX_CHANNEL+1); j++)
                    {
                        if (tchans & (0x00000001 << (j-1)))
						{
                            *pv2xc = j;
                            pv2xc++;
						}
                    }
                    for (j = 0; j < MAX_CHANNEL; j++)
                    {
                        if (0 == v2xc[j])
                            break;
                        if ((v2xc[j] < 13) || (v2xc[j] > 16))
                        {
                            dcdata->fd->slg[v2xc[j]-1].slgid = v2xc[j];
                            dcdata->fd->slg[v2xc[j]-1].slgstatus = 0x15;
                            dcdata->fd->slg[v2xc[j]-1].countdown = downti[6] + 1;
                            dcdata->fd->slg[v2xc[j]-1].nslgstatus = 0x17;

							if (0 == phdetect[i+1].stageid)
                        	{
                            	dcdata->fd->slg[v2xc[j]-1].greent = phdetect[0].mingtime + phdetect[0].gftime;
                                dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[0].ytime;
                                dcdata->fd->slg[v2xc[j]-1].redt = phdetect[0].rtime;
                                dcdata->fd->slg[v2xc[j]-1].allrt = 0;
                        	}
                        	else
                        	{
								dcdata->fd->slg[v2xc[j]-1].greent = phdetect[i+1].gtime + phdetect[i+1].gftime;
                            	dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[i+1].ytime;
                            	dcdata->fd->slg[v2xc[j]-1].redt = phdetect[i+1].rtime;
                            	dcdata->fd->slg[v2xc[j]-1].allrt = 0;
							}
                        }
                    }
                    #endif

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}	

					tchans = 0;
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == (pinfo->cchan[j]))
							break;
						tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
					}
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x02;
					downti[6] = pinfo->fixgtime + pinfo->gftime;

					#ifdef V2X_DEBUG
                    for (j = 0; j < MAX_CHANNEL; j++)
                    {
                        if (0 == pinfo->cchan[j])
                            break;
                        if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
                        {
                            dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
                            dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x17;
                            dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
                            dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x16;

							dcdata->fd->slg[pinfo->cchan[j]-1].greent = downti[6] + 1;
							dcdata->fd->slg[pinfo->cchan[j]-1].yellowt = pinfo->ytime;
							dcdata->fd->slg[pinfo->cchan[j]-1].redt = pinfo->rtime;
							dcdata->fd->slg[pinfo->cchan[j]-1].allrt = 0;
                        }
                    }
                    #endif

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)
	//		#endif

			if (0 == pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->fixgtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;	
					sinfo.color = 0x02;
					sinfo.chans = 0;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
               			if (0 == pinfo->chan[i])
                   			break;
               			sinfo.chans += 1;
               			tcsta = pinfo->chan[i];
               			tcsta <<= 2;
               			tcsta &= 0xfc;
               			tcsta |= 0x02;
               			*csta = tcsta;
               			csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
			else
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->fixgtime + pinfo->gftime;	
					sinfo.color = 0x02;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
               			if (0 == pinfo->chan[i])
                   			break;
               			sinfo.chans += 1;
               			tcsta = pinfo->chan[i];
               			tcsta <<= 2;
               			tcsta &= 0xfc;
               			tcsta |= 0x02;
               			*csta = tcsta;
               			csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))		
			}

			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
			{
				memset(&timedown,0,sizeof(timedown));
				timedown.mode = *(dcdata->fd->contmode);
				timedown.pattern = *(dcdata->fd->patternid);
				timedown.lampcolor = 0x02;
				timedown.lamptime = pinfo->fixgtime + pinfo->gftime;
				timedown.phaseid = pinfo->phaseid;
				timedown.stageline = pinfo->stageline;
				if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
            	#endif
            	}	
			}
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x02;
                timedown.lamptime = pinfo->fixgtime + pinfo->gftime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif
			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
				fbdata[3] = 0x02;
				fbdata[4] = pinfo->fixgtime + pinfo->gftime;
			}
			if (!wait_write_serial(*(dcdata->fd->fbserial)))
			{
				if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					*(dcdata->fd->markbit) |= 0x0800;
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                	#endif
                	}
				}
			}
			else
			{
			#ifdef FULL_DETECT_DEBUG
				printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
			}
			sendfaceInfoToBoard(dcdata->fd,fbdata);
			if ((1 == (pinfo->cpcexist)) && ((pinfo->pctime) > 0))
			{//person channels exist in current phase;
		//		sleep(pinfo->fixgtime - pinfo->pctime);
				sltime = pinfo->fixgtime - pinfo->pctime;
				ffw = 0;
				while (1)	
				{
					FD_ZERO(&nRead);
					FD_SET(*(dcdata->fd->ffpipe),&nRead);
					lasttime.tv_sec = 0;
					lasttime.tv_usec = 0;
					gettimeofday(&lasttime,NULL);
					bakv = sltime;
					mtime.tv_sec = sltime;
					mtime.tv_usec = 0;
					int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
					if (mret < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						break;
					}
					if (0 == mret)
					{
						break;
					}
					if (mret > 0)
					{
						if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
							if (!strncmp(buf,"fastforward",11))
							{
								ffw = 1;
								break;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
                        		continue;
							}
						}
						else
						{
							nowtime.tv_sec = 0;
							nowtime.tv_usec = 0;
							gettimeofday(&nowtime,NULL);
							leatime = nowtime.tv_sec - lasttime.tv_sec;
							sltime -= leatime;
							if (sltime > bakv)
                                sltime = bakv;
							continue;
						}
					}//mret > 0
				}//while (1)

				if (0 == ffw)
				{
					//Firstly,create thread to pass person channels;
					if (0 == dcpcyes)
					{
						memset(&dpdata,0,sizeof(dpdata));
						dpdata.bbserial = dcdata->fd->bbserial;
						dpdata.pchan = pinfo->cpchan;
						dpdata.markbit = dcdata->fd->markbit;
						dpdata.sockfd = dcdata->fd->sockfd;
						dpdata.cs = dcdata->cs;
						dpdata.time = pinfo->pctime;
						int pcret = pthread_create(&dcpcid,NULL,(void *)ms_person_chan_greenflash,&dpdata);
						if (0 != pcret)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("Create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
							output_log("Detect control,create person greenflash thread err");
						#endif
							ms_end_part_child_thread();
							return;
						}
						dcpcyes = 1;
					}
					if (0 == pinfo->cchan[0])
					{
						if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							sinfo.time = pinfo->pctime + pinfo->gftime + pinfo->ytime + pinfo->rtime;	
							sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
							sinfo.color = 0x02;
							for (i = 0; i < MAX_CHANNEL; i++)
            				{
                				if (0 == pinfo->cpchan[i])
                   					break;
                				for (j = 0; j < sinfo.chans; j++)
                				{
                   					if (0 == sinfo.csta[j])
                       					break;
                   					tcsta = sinfo.csta[j];
                   					tcsta &= 0xfc;
                   					tcsta >>= 2;
                   					tcsta &= 0x3f;
                   					if (tcsta == pinfo->cpchan[i])
                   					{
                       					sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x03;
										break;
                   					}
                				}
            				}
							memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
            				if (SUCCESS != status_info_report(sibuf,&sinfo))
            				{
            				#ifdef FULL_DETECT_DEBUG
                				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            				#endif
            				}
            				else
            				{
                				write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            				}	
						}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					}
					else
					{
						if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							sinfo.time = pinfo->pctime + pinfo->gftime;	
							sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
							sinfo.color = 0x02;
							for (i = 0; i < MAX_CHANNEL; i++)
            				{
                				if (0 == pinfo->cpchan[i])
                   					break;
                				for (j = 0; j < sinfo.chans; j++)
                				{
                   					if (0 == sinfo.csta[j])
                       					break;
                   					tcsta = sinfo.csta[j];
                   					tcsta &= 0xfc;
                   					tcsta >>= 2;
                   					tcsta &= 0x3f;
                   					if (tcsta == pinfo->cpchan[i])
                   					{
                       					sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x03;
										break;
                   					}
                				}
            				}
							memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
            				if (SUCCESS != status_info_report(sibuf,&sinfo))
            				{
            				#ifdef FULL_DETECT_DEBUG
                				printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            				#endif
            				}
            				else
            				{
                				write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            				}	
						}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					}

				//	sleep(pinfo->pctime);	
					sltime = pinfo->pctime;
					while (1)	
					{
						FD_ZERO(&nRead);
						FD_SET(*(dcdata->fd->ffpipe),&nRead);
						lasttime.tv_sec = 0;
						lasttime.tv_usec = 0;
						gettimeofday(&lasttime,NULL);
						bakv = sltime;
						mtime.tv_sec = sltime;
						mtime.tv_usec = 0;
						int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
						if (mret < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							break;
						}
						if (0 == mret)
						{
							break;
						}
						if (mret > 0)
						{
							if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
								read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
								if (!strncmp(buf,"fastforward",11))
								{
									break;
								}
								else
								{
									nowtime.tv_sec = 0;
                        			nowtime.tv_usec = 0;
                        			gettimeofday(&nowtime,NULL);
                        			leatime = nowtime.tv_sec - lasttime.tv_sec;
                        			sltime -= leatime;
									if (sltime > bakv)
                                		sltime = bakv;
                        			continue;
								}
							}
							else
							{
								nowtime.tv_sec = 0;
								nowtime.tv_usec = 0;
								gettimeofday(&nowtime,NULL);
								leatime = nowtime.tv_sec - lasttime.tv_sec;
								sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
								continue;
							}
						}//mret > 0
					}//while (1)

					if (1 == dcpcyes)
					{
						pthread_cancel(dcpcid);
						pthread_join(dcpcid,NULL);
						dcpcyes = 0;
					}
				}//0 == ffw
			}//person channels exist in current phase;
			else
			{//Not have person channels in current phase;
		//		sleep(pinfo->fixgtime);
				sltime = pinfo->fixgtime;
				while (1)	
				{
					FD_ZERO(&nRead);
					FD_SET(*(dcdata->fd->ffpipe),&nRead);
					lasttime.tv_sec = 0;
					lasttime.tv_usec = 0;
					gettimeofday(&lasttime,NULL);
					bakv = sltime;
					mtime.tv_sec = sltime;
					mtime.tv_usec = 0;
					int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
					if (mret < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						break;
					}
					if (0 == mret)
					{
						break;
					}
					if (mret > 0)
					{
						if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
							if (!strncmp(buf,"fastforward",11))
							{
								break;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
                        		continue;
							}
						}
						else
						{
							nowtime.tv_sec = 0;
							nowtime.tv_usec = 0;
							gettimeofday(&nowtime,NULL);
							leatime = nowtime.tv_sec - lasttime.tv_sec;
							sltime -= leatime;
							if (sltime > bakv)
                                sltime = bakv;
							continue;
						}
					}//mret > 0
				}//while (1)
			}//Not have person channels in current phase;

			//Begin to green flash
			if ((0 != pinfo->cchan[0]) && (pinfo->gftime > 0))
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->gftime;	
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.color = 0x03;
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
            			if (0 == pinfo->cchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								sinfo.csta[j] |= 0x03;
								break;
                   			}
               			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
			
			memset(&gtime,0,sizeof(gtime));
			memset(&gftime,0,sizeof(gftime));
			gettimeofday(&gftime,NULL);
			memset(&ytime,0,sizeof(ytime));
			memset(&rtime,0,sizeof(rtime));
			*(dcdata->fd->markbit) |= 0x0400;
			if (pinfo->gftime > 0)
			{
				gft = 0;
				while (1)
				{
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x02))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x02, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}	
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x03))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x03, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					gft += 1;
					if (gft >= (pinfo->gftime))
						break;
				}
			}//if (pinfo->gftime > 0)	
			//end green flash
			if (1 == phcon)
            {
                *(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			#ifdef RED_FLASH	
			if (0 == dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].StageId)
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][0].SpecFunc & 0xe0) >> 5;
			}
			else
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].SpecFunc & 0xe0) >> 5;
			}
			if (rft > 0)
			{
				redflash_dc		dc;
				dc.tcline = tcline;
				dc.slnum = slnum;
				dc.snum =	snum;
				dc.rft = rft;
				dc.chan = pinfo->chan;
				dc.dc = dcdata;
				int rfarg = pthread_create(&rfpid,NULL,(void *)ms_red_flash,&dc);
				if (0 != rfarg)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
			}//if (rft > 0) 
			#endif
	
			//Begin to set yellow lamp 
			if (1 == (pinfo->cpcexist))
			{//person channels exist in current phase
				//all person channels will be set red lamp;
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cpchan,0x00))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                	#endif
                	}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cpchan,0x00, \
                                                    dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }	
				//other change channels will be set yellow lamp;
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cnpchan,0x01))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cnpchan,0x01, \
                                                    dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
			}//person channels exist in current phase
			else
			{//Not person channels in current phase
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x01))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x01, \
                                                    dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
			}//Not person channels in current phase
		//	#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
	#if 0
					tchans = 0;
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == (pinfo->cchan[j]))
							break;
						tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
					}
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
	#endif
					downti[5] = 0x01;
					downti[6] = pinfo->ytime;

					#ifdef V2X_DEBUG
                    for (j = 0; j < MAX_CHANNEL; j++)
                    {
                        if (0 == pinfo->cchan[j])
                            break;
                        if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
                        {
                            dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
                            dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x16;
                            dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
                            dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x15;
                        }
                    }
                    #endif

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)
	//		#endif

			if ((0 != pinfo->cchan[0]) && (pinfo->ytime > 0))
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->ytime;	
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.color = 0x01;
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
            			if (0 == pinfo->cnpchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cnpchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								sinfo.csta[j] |= 0x01;
								break;
                   			}
               			}
            		}
					for (i = 0; i < MAX_CHANNEL; i++)
               		{
                   		if (0 == pinfo->cpchan[i])
                       		break;
                   		for (j = 0; j < sinfo.chans; j++)
                   		{
                       		if (0 == sinfo.csta[j])
                           		break;
                       		tcsta = sinfo.csta[j];
                       		tcsta &= 0xfc;
                       		tcsta >>= 2;
                       		tcsta &= 0x3f;
                       		if (tcsta == pinfo->cpchan[i])
                       		{
                           		sinfo.csta[j] &= 0xfc;
								break;
                       		}
                   		}
               		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x01;
                timedown.lamptime = pinfo->ytime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
               	memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x01;
                timedown.lamptime = pinfo->ytime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline; 
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif
			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
            	fbdata[3] = 0x01;
            	fbdata[4] = pinfo->ytime;
			}
            if (!wait_write_serial(*(dcdata->fd->fbserial)))
            {
                if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					*(dcdata->fd->markbit) |= 0x0800;
                    gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
													dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
            }
            else
            {
            #ifdef FULL_DETECT_DEBUG
                printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			sendfaceInfoToBoard(dcdata->fd,fbdata);
			*(dcdata->fd->color) = 0x01;
			memset(&gtime,0,sizeof(gtime));
            memset(&gftime,0,sizeof(gftime));
            memset(&ytime,0,sizeof(ytime));
			gettimeofday(&ytime,NULL);
            memset(&rtime,0,sizeof(rtime));
			sleep(pinfo->ytime);
			//end set yellow lamp
			
			//Begin to set red lamp
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x00))
			{
			#ifdef FULL_DETECT_DEBUG
				printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				gettimeofday(&ct,NULL);
                update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
				*(dcdata->fd->markbit) |= 0x0800;
			}
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x00, \
												dcdata->fd->markbit))
            {
            #ifdef FULL_DETECT_DEBUG
                printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			

			*(dcdata->fd->color) = 0x00;

			if (0 != pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->rtime;	
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.color = 0x00;
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
           				if (0 == pinfo->cchan[i])
                  			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								break;
                   			}
               			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					downti[5] = 0x00;
					downti[6] = pinfo->rtime;
				
					#ifdef V2X_DEBUG
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->cchan[j])
							break;
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
							dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x15;
							dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
							dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x17;
						}
					}
					#endif

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)
		//		#endif
			if (pinfo->rtime > 0)
            {
				memset(&gtime,0,sizeof(gtime));
            	memset(&gftime,0,sizeof(gftime));
            	memset(&ytime,0,sizeof(ytime));
            	memset(&rtime,0,sizeof(rtime));
            	gettimeofday(&rtime,NULL);

				if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            	{
               		memset(&timedown,0,sizeof(timedown));
               		timedown.mode = *(dcdata->fd->contmode);
               		timedown.pattern = *(dcdata->fd->patternid);
               		timedown.lampcolor = 0x00;
               		timedown.lamptime = pinfo->rtime;
               		timedown.phaseid = pinfo->phaseid;
               		timedown.stageline = pinfo->stageline;
               		if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
               		{
               		#ifdef FULL_DETECT_DEBUG
                   		printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
               		#endif
               		}
            	}
				#ifdef EMBED_CONFIGURE_TOOL
				if (*(dcdata->fd->markbit2) & 0x0200)
				{
					memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x00;
                    timedown.lamptime = pinfo->rtime;
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;	
					if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
					}
				}
				#endif

				//send info to face board
				if (*(dcdata->fd->contmode) < 27)
                	fbdata[1] = *(dcdata->fd->contmode) + 1;
            	else
                	fbdata[1] = *(dcdata->fd->contmode);
				if ((30 == fbdata[1]) || (31 == fbdata[1]))
                {
                    fbdata[2] = 0;
                    fbdata[3] = 0;
                    fbdata[4] = 0;
                }
                else
				{
					fbdata[2] = pinfo->stageline;
            		fbdata[3] = 0x00;
            		fbdata[4] = pinfo->rtime;
				}
            	if (!wait_write_serial(*(dcdata->fd->fbserial)))
            	{
               		if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
               		{
               		#ifdef FULL_DETECT_DEBUG
                   		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
               		#endif
						*(dcdata->fd->markbit) |= 0x0800;
                   		gettimeofday(&ct,NULL);
                   		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                   		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                   		{
                   		#ifdef FULL_DETECT_DEBUG
                       		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                   		#endif
                   		}
               		}
            	}
            	else
            	{
            	#ifdef FULL_DETECT_DEBUG
               		printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
				sendfaceInfoToBoard(dcdata->fd,fbdata);
				sleep(pinfo->rtime);
			}
			//end set red lamp
			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phaseendtime = ct.tv_sec;
			ni += 1;
			slnum += 1;
			*(dcdata->fd->slnum) = slnum;
			*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
			{
				cycarr = 1;
				slnum = 0;
				*(dcdata->fd->slnum) = 0;
				*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			}
			#ifdef RED_FLASH
            if (rft > (pinfo->ytime + pinfo->rtime))
            {
                sleep(rft - (pinfo->ytime) - (pinfo->rtime));
            }
            #endif
			if (1 == phcon)
            {
				*(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			continue;
		}//fix phase
		else if (0x04 == (pinfo->phasetype))
		{//person phase
			#ifdef FULL_DETECT_DEBUG
            printf("Begin to pass person phase,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
			//green lamp of person phase
			*(dcdata->fd->color) = 0x02;
			*(dcdata->fd->markbit) &= 0xfbff;
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
			{
			#ifdef FULL_DETECT_DEBUG
				printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				gettimeofday(&ct,NULL);
                update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
				*(dcdata->fd->markbit) |= 0x0800;
			}
			//added on 20220620
			adaptd.phi[ni].pfactt = pinfo->pgtime + pinfo->pctime + pinfo->rtime;
        	adaptd.phi[ni].paddt = 0;
			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phasestarttime = ct.tv_sec;
			//end add
			#ifdef CHANNEL_YELLOW_FLASH
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{		
				if (pinfo->phaseid	== dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel yellow flash
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->pgtime + pinfo->pctime + pinfo->rtime -1;//for thread exit
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;
				int yfarg = pthread_create(&yfcpid,NULL,(void *)ms_channel_yellow_flash,&cyft);
				if (0 != yfarg)
				{
				#ifdef TIMING_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
				else
				{//create channel yellow flash thread success;
				#ifdef TIMING_DEBUG
					printf("Create channel yellow flash thread success,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//actively report is not probitted and connect successfully
						sinfo.time = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime - 1;
						sinfo.conmode = *(dcdata->fd->contmode);
						sinfo.color = 0x05;//yellow flash
						sinfo.chans = 0;
						memset(sinfo.csta,0,sizeof(sinfo.csta));
						csta = sinfo.csta;
						for (i = 0; i < YFCHANNEL; i++)
						{
							if (0 == cyfc[i])
								break;
							sinfo.chans += 1;
							tcsta = cyfc[i];
							tcsta <<= 2;
							tcsta &= 0xfc;
							tcsta |= 0x00;
							*csta = tcsta;
							csta++;
						}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
						if (SUCCESS != status_info_report(sibuf,&sinfo))	
						{
						#ifdef TIMING_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						else
						{
							write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
						}
					}//actively report is not probitted and connect successfully
				}//create channel yellow flash thread success;
			}//exist channel yellow flash
			#endif

			#ifdef CHANNEL_CLOSE
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{
				if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel close lamp
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->pgtime + pinfo->pctime + pinfo->rtime;
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;

				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),cyfc,0x03))
				{
				#ifdef TIMING_DEBUG
					printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,cyfc,0x03,dcdata->fd->markbit))
				{
				#ifdef TIMING_DEBUG
					printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				channel_close_begin_report(dcdata->fd->sockfd->csockfd,cyfc);
				
			}//exist channel close lamp
			#endif			

			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
                                                    dcdata->fd->markbit))
            {
            #ifdef FULL_DETECT_DEBUG
                printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
		//	#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					for (i = 0; i < MAX_PHASE_LINE; i++)
					{
						if (0 == phdetect[i].stageid)
							break;
						if (pinfo->stageline == phdetect[i].stageid)
							break;
					}
					tchans = 0;
					downti[6] = 0;
					if (i != MAX_PHASE_LINE)
					{
						if (0 == phdetect[i+1].stageid)
						{
							tchans = phdetect[0].chans;
						}
						else
						{
							tchans = phdetect[i+1].chans;
						}
						downti[6] += phdetect[i].pgtime + phdetect[i].pctime + phdetect[i].rtime;
						for (j = 0; j < MAX_CHANNEL; j++)
						{//for (j = 0; j < MAX_CHANNEL; j++)
							if (0 == (pinfo->chan[j]))
								break;
							if (tchans & (0x00000001 << (pinfo->chan[j] - 1)))
								tchans &= (~(0x00000001 << (pinfo->chan[j] - 1)));
						}//for (j = 0; j < MAX_CHANNEL; j++)
					}//if (i != MAX_PHASE_LINE)
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x00;
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}

					tchans = 0;
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == (pinfo->cchan[j]))
							break;
						tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
					}
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x02;
					downti[6] = pinfo->pgtime + pinfo->pctime;
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)
	//		#endif

			if (0 == pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->pgtime + pinfo->pctime + pinfo->rtime;	
					sinfo.color = 0x02;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
               			if (0 == pinfo->chan[i])
                   			break;
               			sinfo.chans += 1;
               			tcsta = pinfo->chan[i];
               			tcsta <<= 2;
               			tcsta &= 0xfc;
               			tcsta |= 0x02;
               			*csta = tcsta;
               			csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
			else
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->pgtime + pinfo->pctime;	
					sinfo.color = 0x02;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
            		memset(sinfo.csta,0,sizeof(sinfo.csta));
            		csta = sinfo.csta;
            		for (i = 0; i < MAX_CHANNEL; i++)
            		{
               			if (0 == pinfo->chan[i])
                   			break;
               			sinfo.chans += 1;
               			tcsta = pinfo->chan[i];
               			tcsta <<= 2;
               			tcsta &= 0xfc;
               			tcsta |= 0x02;
               			*csta = tcsta;
               			csta++;
            		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			memset(&gtime,0,sizeof(gtime));
            gettimeofday(&gtime,NULL);
            memset(&gftime,0,sizeof(gftime));
            memset(&ytime,0,sizeof(ytime));
            memset(&rtime,0,sizeof(rtime));
			
			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x02;
                timedown.lamptime = pinfo->pgtime + pinfo->pctime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
               	memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x02;
                timedown.lamptime = pinfo->pgtime + pinfo->pctime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline; 
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif
			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
            	fbdata[3] = 0x02;
            	fbdata[4] = pinfo->pgtime + pinfo->pctime;
			}
            if (!wait_write_serial(*(dcdata->fd->fbserial)))
            {
                if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					*(dcdata->fd->markbit) |= 0x0800;
                    gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
            }
            else
            {
            #ifdef FULL_DETECT_DEBUG
                printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			sendfaceInfoToBoard(dcdata->fd,fbdata);
	//		sleep(pinfo->pgtime);
			sltime = pinfo->pgtime;
			while (1)	
			{
				FD_ZERO(&nRead);
				FD_SET(*(dcdata->fd->ffpipe),&nRead);
				lasttime.tv_sec = 0;
				lasttime.tv_usec = 0;
				gettimeofday(&lasttime,NULL);
				bakv = sltime;
				mtime.tv_sec = sltime;
				mtime.tv_usec = 0;
				int mret = select(*(dcdata->fd->ffpipe)+1,&nRead,NULL,NULL,&mtime);
				if (mret < 0)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					break;
				}
				if (0 == mret)
				{
					break;
				}
				if (mret > 0)
				{
					if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
					{
						memset(buf,0,sizeof(buf));
						read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
						if (!strncmp(buf,"fastforward",11))
						{
							break;
						}
						else
						{
							nowtime.tv_sec = 0;
                        	nowtime.tv_usec = 0;
                        	gettimeofday(&nowtime,NULL);
                        	leatime = nowtime.tv_sec - lasttime.tv_sec;
                        	sltime -= leatime;
							if (sltime > bakv)
                                sltime = bakv;
                        	continue;
						}
					}
					else
					{
						nowtime.tv_sec = 0;
						nowtime.tv_usec = 0;
						gettimeofday(&nowtime,NULL);
						leatime = nowtime.tv_sec - lasttime.tv_sec;
						sltime -= leatime;
						if (sltime > bakv)
                            sltime = bakv;
						continue;
					}
				}//mret > 0
			}//while (1)

			//green flash of person phase
			if ((0 != pinfo->cchan[0]) && (pinfo->pctime > 0))
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->pctime;	
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.color = 0x03;
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
            			if (0 == pinfo->cchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								sinfo.csta[j] |= 0x03;
								break;
                   			}
               			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))	
			}
			
			memset(&gtime,0,sizeof(gtime));
            memset(&gftime,0,sizeof(gftime));
			gettimeofday(&gftime,NULL);
            memset(&ytime,0,sizeof(ytime));
            memset(&rtime,0,sizeof(rtime));
			*(dcdata->fd->markbit) |= 0x0400;
			if (pinfo->pctime > 0)
			{
				gft = 0;
				while (1)
				{
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x02))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x02, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x03))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x03, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}	
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					gft += 1;
					if (gft >= (pinfo->pctime))
						break;
				}
			}//if (pinfo->pctime > 0)			
		
			if (1 == phcon)
            {
                *(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			#ifdef RED_FLASH	
			if (0 == dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].StageId)
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][0].SpecFunc & 0xe0) >> 5;
			}
			else
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].SpecFunc & 0xe0) >> 5;
			}
			if (rft > 0)
			{
				redflash_dc		dc;
				dc.tcline = tcline;
				dc.slnum = slnum;
				dc.snum =	snum;
				dc.rft = rft;
				dc.chan = pinfo->chan;
				dc.dc = dcdata;
				int rfarg = pthread_create(&rfpid,NULL,(void *)ms_red_flash,&dc);
				if (0 != rfarg)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
			}//if (rft > 0) 
			#endif
	
			//red lamp of person phase
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x00))
			{
			#ifdef FULL_DETECT_DEBUG
				printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
				gettimeofday(&ct,NULL);
                update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
				*(dcdata->fd->markbit) |= 0x0800;
			}
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x00, \
                                                    dcdata->fd->markbit))
            {
            #ifdef FULL_DETECT_DEBUG
                printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			

			*(dcdata->fd->color) = 0x00;
			if (0 != pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->rtime;	
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.color = 0x00;
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
            			if (0 == pinfo->cchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                   				break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								break;
                   			}
               			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			if (pinfo->rtime > 0)
			{
		//		#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//11
	#if 0
						tchans = 0;
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == (pinfo->cchan[j]))
								break;
							tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
						}
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
	#endif
						downti[5] = 0x00;
						downti[6] = pinfo->rtime;
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}//11
				}//if (*(dcdata->fd->auxfunc) & 0x01)
		//		#endif

				memset(&gtime,0,sizeof(gtime));
            	memset(&gftime,0,sizeof(gftime));
            	memset(&ytime,0,sizeof(ytime));
            	memset(&rtime,0,sizeof(rtime));
            	gettimeofday(&rtime,NULL);

				if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            	{
               		memset(&timedown,0,sizeof(timedown));
               		timedown.mode = *(dcdata->fd->contmode);
               		timedown.pattern = *(dcdata->fd->patternid);
               		timedown.lampcolor = 0x00;
               		timedown.lamptime = pinfo->rtime;
               		timedown.phaseid = pinfo->phaseid;
               		timedown.stageline = pinfo->stageline;
               		if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
               		{
               		#ifdef FULL_DETECT_DEBUG
                   		printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
               		#endif
               		}
            	}
				#ifdef EMBED_CONFIGURE_TOOL
				if (*(dcdata->fd->markbit2) & 0x0200)
				{
					memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x00;
                    timedown.lamptime = pinfo->rtime;
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;	
					if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
					}
				}
				#endif

				//send info to face board
				if (*(dcdata->fd->contmode) < 27)
                	fbdata[1] = *(dcdata->fd->contmode) + 1;
            	else
                	fbdata[1] = *(dcdata->fd->contmode);
				if ((30 == fbdata[1]) || (31 == fbdata[1]))
                {
                    fbdata[2] = 0;
                    fbdata[3] = 0;
                    fbdata[4] = 0;
                }
                else
				{
					fbdata[2] = pinfo->stageline;
           			fbdata[3] = 0x00;
           			fbdata[4] = pinfo->rtime;
				}
           		if (!wait_write_serial(*(dcdata->fd->fbserial)))
           		{
               		if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
               		{
               		#ifdef FULL_DETECT_DEBUG
                   		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
               		#endif
						*(dcdata->fd->markbit) |= 0x0800;
                   		gettimeofday(&ct,NULL);
                   		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                   		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                   		{
                   		#ifdef FULL_DETECT_DEBUG
                       		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                   		#endif
                   		}
               		}
           		}
           		else
           		{
           		#ifdef FULL_DETECT_DEBUG
               		printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
           		#endif
           		}
				sendfaceInfoToBoard(dcdata->fd,fbdata);
				sleep(pinfo->rtime);
			}
			//end red lamp
			slnum += 1;
			ni += 1;
			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phaseendtime = ct.tv_sec;
			*(dcdata->fd->slnum) = slnum;
			*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
			{
				cycarr = 1;
				slnum = 0;
				*(dcdata->fd->slnum) = 0;
				*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			}
			#ifdef RED_FLASH
            if (rft > (pinfo->ytime + pinfo->rtime))
            {
                sleep(rft - (pinfo->ytime) - (pinfo->rtime));
            }
            #endif
			if (1 == phcon)
            {
				*(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			continue;
		}//person phase
		else if (0x40 == (pinfo->phasetype))
		{//pending phase
			//the pending will not be passed if current pending phase do not have vehicle request;
			unsigned char			runpep = 0; //'1' means the phase will be passed, or not;
			for (i = 0; i < MAX_PHASE_LINE; i++)
			{
				if (0 == pephase[i].phaseid)
					break;
				if ((pinfo->phaseid == pephase[i].phaseid) && (1 == pephase[i].mark))
				{
					runpep = 1;
					pephase[i].mark = 0;
					break;
				}
			}
			if (1 == runpep)
			{//the pending phase will be passed //待定相位
				#ifdef FULL_DETECT_DEBUG
            	printf("Begin to pass pending phase,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
			roaddata = *(dcdata->fd->roadinfo);
			unsigned char personchannelnum = 0;
			unsigned char rcnum = 0,lcnum = 0,z =0,flag = 0;
			unsigned char allchannel[MAX_CHANNEL];
			roadbit = 0;
			isreport = 0;
			memset(pinfo->roaddelaychan,0,sizeof(pinfo->roaddelaychan));
			memset(pinfo->persionroadbit,0,sizeof(pinfo->persionroadbit));
			memset(allchannel,0,sizeof(allchannel));
			memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
			memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
			
			#ifdef FULL_DETECT_DEBUG
            printf("***************pend phase  roaddata: %d,File: %s,Line: %d\n",roaddata,__FILE__,__LINE__);
            #endif
			*(dcdata->fd->color) = 0x02;
			*(dcdata->fd->markbit) &= 0xfbff;
			gettimeofday(&ct,NULL);
			currenttime = ct.tv_sec;
			adaptd.phi[ni].phasestarttime = ct.tv_sec;
			
			
			receiveroadtime =  *(dcdata->fd->roadinforeceivetime);
			if((currenttime - receiveroadtime) > 4)
			{
				roaddata = 0;
			}
			else
			{
				roaddata = *(dcdata->fd->roadinfo);
			}
			//相位开始行人等待处理 
			for(roadbit = 0;roadbit < 4; roadbit++)
			{
				if((roaddata >> roadbit) & 0x00000001)
				{
					//if(1 == pinfo->cpcexist)
					//{
						if(0 ==roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(pinfo->chan[personchannelnum] == 13)
								{
									flag = 1;
									break;
								}
																
							}

							if(0 == flag)
							{
								continue;
							}
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(12 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 12;
									pinfo->persionroadbit[lcnum] = roadbit +1;
									break;
								}
																
							}
								
							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
            				printf("pend phase location is 1,File: %s,Line: %d\n",__FILE__,__LINE__);
           					#endif
						}
						else if(1 == roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(16 == pinfo->chan[personchannelnum])
								{
									flag = 1;
									break;
								}
																
							}
							if(0 == flag)
							{
								continue;
							}
					
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(11 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 11;
									pinfo->persionroadbit[lcnum] = roadbit +1;
									break;
								}
																
							}
								

							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
            				printf("pend phase location is 2,File: %s,Line: %d\n",__FILE__,__LINE__);
           					#endif
						}
						else if(2 == roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(pinfo->chan[personchannelnum] == 15)
								{
									flag = 1;
									break;

								}
																
							}
							if(0 == flag)
							{
								continue;
							}

							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(10 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 10;	
									pinfo->persionroadbit[lcnum] = roadbit+1;
								}
																
							}
								
							
							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
	    					printf("pend phase location is 3,File: %s,Line: %d\n",__FILE__,__LINE__);
	   						#endif
						}
						else if(3 == roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}
								if(14 == pinfo->chan[personchannelnum])
								{
									flag = 1;
									break;
								}																
							}
							if(0 == flag)
							{
								continue;
							}

							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(9 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 9;	
									pinfo->persionroadbit[lcnum] = roadbit+1;
								}
																
							}

							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
    						printf("pend phase location is 4,File: %s,Line: %d\n",__FILE__,__LINE__);
   							#endif							
						}					
			
					//}
						
				}
			}
			if( 0 != allchannel[0])
			{
				flag = 1;
				z = 0;
				for(i = 0; i<MAX_CHANNEL;i++)
				{	
					if(0 == allchannel[i])
					{
						break;
					} 
					for(roadbit = 0;roadbit<i;roadbit++)
					{
						if(allchannel[i] == allchannel[roadbit])
						{
							flag = 0;
						}
					}
					if(flag)
					{
						pinfo->roaddelaychan[z] = allchannel[i];
						z++;
					}
					flag = 1;	
				}
				if(0 == delaypcyes)
				{
					int dcret = pthread_create(&delaypcpid,NULL,(void *)ms_delay_right_channel,dcdata);
					if (0 != dcret)
					{
						#ifdef ROADINFO_DEBUG
            			printf("create pthread ms_delay_right_channel error,File: %s,Line: %d\n",__FILE__,__LINE__);
           				#endif
						return;
					}
					#ifdef ROADINFO_DEBUG
            		printf("create pthread ms_delay_right_channel,File: %s,Line: %d\n",__FILE__,__LINE__);
           			#endif
					delaypcyes = 1;
				}
			}
			if(0 == pinfo->roaddelaychan[0])
			{
				//unsigned char  notchangletoyellow[MAX_CHANNEL];
				if(0 != currentquenuechannel[0])
				{
					unsigned char q,w,e = 0,flag = 1;
					//memset(notchangletoyellow,0,sizeof(notchangletoyellow));
					for(q = 0;q<MAX_CHANNEL;q++)
					{
						if(0 == pinfo->chan[q])
						{
							break;
						}
						for(w = 0;w<MAX_CHANNEL;w++)
						{
							if(0 == currentquenuechannel[w])
							{
								break;
							}
							if(pinfo->chan[q] != currentquenuechannel[w])
							{
								flag = 0;
								break;
							}
						}
						if(0 == flag)
						{
							yellowtoredchannel[e] = pinfo->chan[q];
							e++;
						}
						flag = 1;
					}
				}
				else
				{
					//memset(notchangletoyellow,0,sizeof(notchangletoyellow));
					memcpy(yellowtoredchannel,pinfo->chan,sizeof(yellowtoredchannel));
				}
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),yellowtoredchannel,0x02))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
		            update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		            if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
		            {
		            #ifdef FULL_DETECT_DEBUG
		                printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		            #endif
		            }
					*(dcdata->fd->markbit) |= 0x0800;
				}
			}
				#ifdef CHANNEL_YELLOW_FLASH
				cyfn = 0;
				cyfe = 0;
				for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
				{		
					if (pinfo->phaseid	== dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
					{
						cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
						break;
					}
				}
				memset(cyfc,0,sizeof(cyfc));
				pcyfc = cyfc;
				if (cyfe > 0)
				{//exist channel yellow flash
					for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
					{
						if (cyfe & (0x01 << cyfn))
						{
							*pcyfc = cyfn + 1;
							pcyfc++;
						}
					}
					cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime -1;//for thread exit
					cyft.chan = cyfc;
					cyft.dc = dcdata;
					cyft.mark = 1;
					int yfarg = pthread_create(&yfcpid,NULL,(void *)ms_channel_yellow_flash,&cyft);
					if (0 != yfarg)
					{
					#ifdef TIMING_DEBUG
						printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						return;
					}
					else
					{//create channel yellow flash thread success;
					#ifdef TIMING_DEBUG
						printf("Create channel yellow flash thread success,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						{//actively report is not probitted and connect successfully
							sinfo.time = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime - 1;
							sinfo.conmode = *(dcdata->fd->contmode);
							sinfo.color = 0x05;//yellow flash
							sinfo.chans = 0;
							memset(sinfo.csta,0,sizeof(sinfo.csta));
							csta = sinfo.csta;
							for (i = 0; i < YFCHANNEL; i++)
							{
								if (0 == cyfc[i])
									break;
								sinfo.chans += 1;
								tcsta = cyfc[i];
								tcsta <<= 2;
								tcsta &= 0xfc;
								tcsta |= 0x00;
								*csta = tcsta;
								csta++;
							}
							memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
							if (SUCCESS != status_info_report(sibuf,&sinfo))	
							{
							#ifdef TIMING_DEBUG
								printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
							else
							{
								write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
							}
						}//actively report is not probitted and connect successfully
					}//create channel yellow flash thread success;
				}//exist channel yellow flash
				#endif

				#ifdef CHANNEL_CLOSE
				cyfn = 0;
				cyfe = 0;
				for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
				{
					if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
					{
						cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
						break;
					}
				}
				memset(cyfc,0,sizeof(cyfc));
				pcyfc = cyfc;
				if (cyfe > 0)
				{//exist channel close lamp
					for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
					{
						if (cyfe & (0x01 << cyfn))
						{
							*pcyfc = cyfn + 1;
							pcyfc++;
						}
					}
					cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
					cyft.chan = cyfc;
					cyft.dc = dcdata;
					cyft.mark = 1;

					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),cyfc,0x03))
					{
					#ifdef TIMING_DEBUG
						printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,cyfc,0x03,dcdata->fd->markbit))
					{
					#ifdef TIMING_DEBUG
						printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					channel_close_begin_report(dcdata->fd->sockfd->csockfd,cyfc);
					
				}//exist channel close lamp
				#endif
				if(0 == pinfo->roaddelaychan[0])
				{
				
//					unsigned char  notchangletoyellow[MAX_CHANNEL];
//					if(0 != currentquenuechannel[0])
//					{
//						unsigned char q,w,e = 0,flag = 0;
//						memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//						for(q = 0;q<MAX_CHANNEL;q++)
//						{
//							if(0 == pinfo->chan[q])
//							{
//								break;
//							}
//							for(w = 0;w<MAX_CHANNEL;w++)
//							{
//								if(0 == currentquenuechannel[w])
//								{
//									break;
//								}
//								if(pinfo->chan[q] == currentquenuechannel[w])
//								{
//									flag = 0;
//									break;
//								}
//								flag = 1;
//							}
//							if(flag)
//							{
//								notchangletoyellow[e] = pinfo->chan[q];
//								e++;
//							}
//							flag = 0;
//						}
//					}
//					else
//					{
//						memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//						memcpy(notchangletoyellow,pinfo->chan,sizeof(notchangletoyellow));
//					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x02, \
															dcdata->fd->markbit))
					{
						#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
					}
				}

				#ifdef V2X_DEBUG
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//if ((30 != *(sadata->fd->contmode)) && (31 != *(sadata->fd->contmode)))
						*(dcdata->fd->v2xmark) &= 0xfe;//V2X
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == pinfo->chan[j])
								break;
							if ((pinfo->chan[j] < 13) || (pinfo->chan[j] > 16))
							{
								dcdata->fd->slg[(pinfo->chan[j])-1].slgid = pinfo->chan[j];
								dcdata->fd->slg[(pinfo->chan[j])-1].slgstatus= 0x17;
								dcdata->fd->slg[(pinfo->chan[j])-1].countdown = 0xff;
								dcdata->fd->slg[(pinfo->chan[j])-1].nslgstatus = 0x16;

								dcdata->fd->slg[(pinfo->chan[j])-1].greent = 0;//pinfo->mingtime + pinfo->gftime;
								dcdata->fd->slg[(pinfo->chan[j])-1].yellowt = 0;//pinfo->ytime;
								dcdata->fd->slg[(pinfo->chan[j])-1].redt = 0;//pinfo->rtime;
								dcdata->fd->slg[(pinfo->chan[j])-1].allrt = 0;	
							}
						}	
					}////if ((30 != *(sadata->fd->contmode)) && (31 != *(sadata->fd->contmode)))
				}//if (*(dcdata->fd->auxfunc) & 0x01)
				#endif
				if (0 == pinfo->cchan[0] && 0 == pinfo->roaddelaychan[0])
				{	
					#ifdef ROADINFO_DEBUG
					printf("current pinfo->roaddelaychan is 0:,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
//					unsigned char  notchangletoyellow[MAX_CHANNEL];
//					if(0 != currentquenuechannel[0])
//					{
//						unsigned char q,w,e = 0,flag = 0;
//						memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//						for(q = 0;q<MAX_CHANNEL;q++)
//						{
//							if(0 == pinfo->chan[q])
//							{
//								break;
//							}
//							for(w = 0;w<MAX_CHANNEL;w++)
//							{
//								if(0 == currentquenuechannel[w])
//								{
//									break;
//								}
//								if(pinfo->chan[q] == currentquenuechannel[w])
//								{
//									flag = 0;
//									break;
//								}
//								flag = 1;
//							}
//							if(flag)
//							{
//								notchangletoyellow[e] = pinfo->chan[q];
//								e++;
//							}
//							flag = 0;
//						}
//					}
//				
//					else
//					{
//						memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//						memcpy(notchangletoyellow,pinfo->chan,sizeof(notchangletoyellow));
//					}
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						sinfo.time = pinfo->mingtime + pinfo->gftime + pinfo->ytime + pinfo->rtime; 
				//		#ifdef FULL_DOWN_TIME
						if (*(dcdata->fd->auxfunc) & 0x01)
							sinfo.time += *(dcdata->fd->halfdownt);
				//		#endif
						sinfo.color = 0x02;
						sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
						sinfo.chans = 0;
						memset(sinfo.csta,0,sizeof(sinfo.csta));
						csta = sinfo.csta;		
						for (i = 0; i < MAX_CHANNEL; i++)
						{
							if (0 == yellowtoredchannel[i])
								break;
							sinfo.chans += 1;
							tcsta = yellowtoredchannel[i];
							tcsta <<= 2;
							tcsta &= 0xfc;
							tcsta |= 0x02;
							*csta = tcsta;
							csta++;
						}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
						if (SUCCESS != status_info_report(sibuf,&sinfo))
						{
							#ifdef FULL_DETECT_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
						}
						else
						{
							write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
						}		
					}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				}
				else if(0 != pinfo->cchan[0] && 0 == pinfo->roaddelaychan[0])
				{
					#ifdef ROADINFO_DEBUG
					printf("reporrt to hou tai 2:,File:%s ,Line: %d\n",__FILE__,__LINE__);
					#endif
//					unsigned char  notchangletoyellow[MAX_CHANNEL];
//					if(0 != currentquenuechannel[0])
//					{
//						unsigned char q,w,e = 0,flag = 0;
//						memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//						for(q = 0;q<MAX_CHANNEL;q++)
//						{
//							if(0 == pinfo->chan[q])
//							{
//								break;
//							}
//							for(w = 0;w<MAX_CHANNEL;w++)
//							{
//								if(0 == currentquenuechannel[w])
//								{
//									break;
//								}
//								if(pinfo->chan[q] == currentquenuechannel[w])
//								{
//									flag = 0;
//									break;
//								}
//								flag = 1;
//							}
//							if(flag)
//							{
//								notchangletoyellow[e] = pinfo->chan[q];
//								e++;
//							}
//							flag = 0;
//						}
//					}
//					else
//					{
//						memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//						memcpy(notchangletoyellow,pinfo->chan,sizeof(notchangletoyellow));
//					}
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						sinfo.time = pinfo->mingtime + pinfo->gftime;	
						if (*(dcdata->fd->auxfunc) & 0x01)
							sinfo.time += *(dcdata->fd->halfdownt);
						sinfo.color = 0x02;
						sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
						sinfo.chans = 0;
						memset(sinfo.csta,0,sizeof(sinfo.csta));
						csta = sinfo.csta;
						for (i = 0; i < MAX_CHANNEL; i++)
						{
							if (0 == yellowtoredchannel[i])
								break;
							sinfo.chans += 1;
							tcsta = yellowtoredchannel[i];
							tcsta <<= 2;
							tcsta &= 0xfc;
							tcsta |= 0x02;
							*csta = tcsta;
							csta++;
						}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
						if (SUCCESS != status_info_report(sibuf,&sinfo))
						{
							#ifdef FULL_DETECT_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
						}
						else
						{
							write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
						}		
					}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				}


				memset(&gtime,0,sizeof(gtime));
            	gettimeofday(&gtime,NULL);
            	memset(&gftime,0,sizeof(gftime));
            	memset(&ytime,0,sizeof(ytime));
            	memset(&rtime,0,sizeof(rtime));

				if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
                {
                    memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x02;
                    timedown.lamptime = pinfo->mingtime + pinfo->gftime;
			//		#ifdef FULL_DOWN_TIME
					if (*(dcdata->fd->auxfunc) & 0x01)
                    	timedown.lamptime += *(dcdata->fd->halfdownt);
            //        #endif
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;
                    if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
				#ifdef EMBED_CONFIGURE_TOOL
				if (*(dcdata->fd->markbit2) & 0x0200)
				{
					memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x02;
                    timedown.lamptime = pinfo->mingtime + pinfo->gftime;
            //      #ifdef FULL_DOWN_TIME
                    if (*(dcdata->fd->auxfunc) & 0x01)
                        timedown.lamptime += *(dcdata->fd->halfdownt);
            //        #endif
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;	
					if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
					}
				}
				#endif
				//send info to face board
				if (*(dcdata->fd->contmode) < 27)
                	fbdata[1] = *(dcdata->fd->contmode) + 1;
            	else
                	fbdata[1] = *(dcdata->fd->contmode);
				if ((30 == fbdata[1]) || (31 == fbdata[1]))
                {
                	fbdata[2] = 0;
                    fbdata[3] = 0;
                    fbdata[4] = 0;
                }
                else
				{
					fbdata[2] = pinfo->stageline;
            		fbdata[3] = 0x02;
            		fbdata[4] = pinfo->mingtime + pinfo->gftime;
			//		#ifdef FULL_DOWN_TIME
					if (*(dcdata->fd->auxfunc) & 0x01)
                    	fbdata[4] += *(dcdata->fd->halfdownt);
            //        #endif
				}
            	if (!wait_write_serial(*(dcdata->fd->fbserial)))
            	{
                	if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                	#endif
						*(dcdata->fd->markbit) |= 0x0800;
                    	gettimeofday(&ct,NULL);
                    	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    	{
                    	#ifdef FULL_DETECT_DEBUG
                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    	#endif
                    	}
                	}
            	}
            	else
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
				sendfaceInfoToBoard(dcdata->fd,fbdata);
				memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
				while (1)
				{
					memset(buf,0,sizeof(buf));
					if (read(*(dcdata->fd->flowpipe),buf,sizeof(buf)) <= 0)
						break;
				}

				if (1 == (pinfo->cpcexist))
				{//have person channels
			//		sleep((pinfo->mingtime) - (pinfo->pdelay));
					sltime = pinfo->mingtime - pinfo->ldeti;
					ffw = 0;
					int max = 0;
					unsigned char receivetime = 0;
					while (1)	
					{
						FD_ZERO(&nRead);
						FD_SET(*(dcdata->fd->ffpipe),&nRead);
						lasttime.tv_sec = 0;
						lasttime.tv_usec = 0;
						gettimeofday(&lasttime,NULL);
						bakv = sltime;
						mtime.tv_sec = sltime;
						mtime.tv_usec = 0;
						max = MAX(*(dcdata->fd->flowpipe),*(dcdata->fd->ffpipe));
						int mret = select(max+1,&nRead,NULL,NULL,&mtime);
						if (mret < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							break;
						}
						if (0 == mret)
						{
							break;
						}
						if (mret > 0)
						{
							if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
								read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
								if (!strncmp(buf,"fastforward",11))
								{
									ffw = 1;
									break;
								}
								else
								{
									nowtime.tv_sec = 0;
                        			nowtime.tv_usec = 0;
                        			gettimeofday(&nowtime,NULL);
                        			leatime = nowtime.tv_sec - lasttime.tv_sec;
                        			sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
                        			continue;
								}
							}
							else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
								int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
								if((0xF4 == buf[0]) && (0xED == buf[len-1]))
								{
									#ifdef ROADINFO_DEBUG
									printf("receive hou quenue data: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
									memset(currentquenuelocation,0,sizeof(currentquenuelocation));
									
									unsigned char i =0,k =0,p =0,j=0,w =0;
									
									for (j = 0; j < 1; j++)
									{
										if((buf[3]>>j) & 0x01)
										{
											istrafficlock = 1; 
											#ifdef ROADINFO_DEBUG
											printf("lock location is 17,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
										}
										else
										{
											istrafficlock = 0;
											#ifdef ROADINFO_DEBUG
											printf("no lock location,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
										}
									
									}
									if(1 == istrafficlock)
									{
										pthread_t   allredpid; 
										int dcret = pthread_create(&allredpid,NULL,(void *)ms_all_red,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("major_salve_detect_control,create major salve detect thread err");
												#endif
											return ;
										}
									}
									if(1 == istrafficlock)//交通死锁
									{
										nowtime.tv_sec = 0;
										nowtime.tv_usec = 0;
										gettimeofday(&nowtime,NULL);
										leatime = nowtime.tv_sec - lasttime.tv_sec;
										sltime -= leatime;
										if (sltime > bakv)
											sltime = bakv;
										#ifdef ROADINFO_DEBUG
										printf("jiao tong si suo wait jie chu: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										memset(lastquenuelocation,0,sizeof(lastquenuelocation));
										while(1)
										{
											FD_ZERO(&nRead);
											FD_SET(*(dcdata->fd->flowpipe),&nRead);
											int ret = select(*(dcdata->fd->flowpipe)+1,&nRead,NULL,NULL,NULL);
											if(ret > 0)
											{
												memset(buf,0,sizeof(buf));
												int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
												buf[len] = 0;
												if((0xF4 == buf[0]) && (0xED==buf[len-1])&& (0x01 == buf[3]))
												{
													#ifdef ROADINFO_DEBUG
													printf("continue wait : %s,Line: %d\n",__FILE__,__LINE__);	
													#endif
													continue;
												}
												else
												{
													#ifdef ROADINFO_DEBUG
													printf("si suo jie chu : %s,Line: %d\n",__FILE__,__LINE__);	
													#endif
													roadreport[0] = 0x21;
													roadreport[1] = 0x85;
													roadreport[2] = 0xFB;
													roadreport[3] = 0x00;
													roadreport[4] = 0xff;
													roadreport[5] = 0xfe; 
													roadreport[6] = 0xff;
													roadreport[7] = 0xff;
													write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
													#ifdef ROADINFO_DEBUG
													printf("send roaddata 1 :");
													for(k=0;k<8;k++)
													{
														printf("%02x ",roadreport[k]);
													}
													printf("\n");
													#endif
													if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
													{
														#ifdef ROADINFO_DEBUG
														printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
														#endif
														gettimeofday(&ct,NULL);
														update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
														if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																							dcdata->fd->softevent,dcdata->fd->markbit))
														{
																#ifdef ROADINFO_DEBUG
																printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
																#endif
														}
														*(dcdata->fd->markbit) |= 0x0800;
													}
													
													if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
																										dcdata->fd->markbit))
													{
														#ifdef ROADINFO_DEBUG
														printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
														#endif
													}
													if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
													{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
														
														sinfo.color = 0x02;
														sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
														sinfo.chans = 0;
														memset(sinfo.csta,0,sizeof(sinfo.csta));
														csta = sinfo.csta;
														for (i = 0; i < MAX_CHANNEL; i++)
														{
															if (0 == pinfo->chan[i])
																break;
															sinfo.chans += 1;
															tcsta = pinfo->chan[i];
															tcsta <<= 2;
															tcsta &= 0xfc;
															tcsta |= 0x02;
															*csta = tcsta;
															csta++;
														}
														memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
														memset(sibuf,0,sizeof(sibuf));
														if (SUCCESS != status_info_report(sibuf,&sinfo))
														{
																#ifdef ROADINFO_DEBUG
																printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
																#endif
														}
														else
														{
															write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
														}
													}				

													break;
												}
											}
											else
											{
												break;
											}
										}
										continue;
									}

									//排队溢出4
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
									if(1 == isdelay && (buf[4]>>4 & 0x0f) == 0x00)
									{
										
										continue;
									}
									if(receivetime == 1)
									{
										if(0 == isreport && (buf[4]>>4 & 0x0f) == 0x00)
										{
											
											continue;
										}
									}
									receivetime  = 1;
									if(1 == isreport)
									{
									
										continue;
									}
									iscarquenueonerflow = 1;
									for(i=4;i<8;i++)
									{
										if((buf[4] >> i) & 0x01)
										{
											if(4 == i)
											{	
												pinfo->roadbit[p] = i;
												p++;
												w = 0;
												currentquenuelocation[0] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}
													if(2 == pinfo->chan[j])
													{
														pinfo->xiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(9 == pinfo->chan[j])
													{
													
														pinfo->xiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(7 == pinfo->chan[j])
													{
														pinfo->xiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}
												}
												pinfo->redchannel[k] = 2;
												k++;
												pinfo->redchannel[k] = 9;
												k++;
												pinfo->redchannel[k] = 7;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 13,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
											}
											else if(5 == i)
											{
												pinfo->roadbit[p] = i;
												p++;
												w =0;
												currentquenuelocation[1] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}
													if(12 == pinfo->chan[j])
													{
														pinfo->nanredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(1 == pinfo->chan[j])
													{
													
														pinfo->nanredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(6 == pinfo->chan[j])
													{
														pinfo->nanredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}

												}	
												pinfo->redchannel[k] = 12;
												k++;
												pinfo->redchannel[k] = 1;
												k++;
												pinfo->redchannel[k] = 6;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 14,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif

											}
											else if(6 == i)
											{
												pinfo->roadbit[p] = i;
												p++;
												w= 0;
												currentquenuelocation[2] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}
													if(5 == pinfo->chan[j])
													{
														pinfo->dongredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(4 == pinfo->chan[j])
													{
													
														pinfo->dongredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(11 == pinfo->chan[j])
													{
														pinfo->dongredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}										
												}
												pinfo->redchannel[k] = 5;
												k++;
												pinfo->redchannel[k] = 4;
												k++;
												pinfo->redchannel[k] = 11;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 15,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif

											}
											else if(7 == i)
											{
												pinfo->roadbit[p] = i;
												p++;
												w = 0;
												currentquenuelocation[3] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}	
													if(8== pinfo->chan[j])
													{
														pinfo->beiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(3== pinfo->chan[j])
													{
													
														pinfo->beiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(10 == pinfo->chan[j])
													{
														pinfo->beiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}

												}
												pinfo->redchannel[k] = 8;
												k++;
												pinfo->redchannel[k] = 3;
												k++;
												pinfo->redchannel[k] = 10;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 16,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif

											}			
										}
										else
										{
											continue;
										}
									}
									if(0 ==pinfo->redchannel[0])
									{
										iscarquenueonerflow = 0;
										
									}
									else
									{
										isreport = 1;
									}
									memcpy(currentquenuechannel,pinfo->redchannel,sizeof(currentquenuechannel));
									if(currentquenuelocation[0] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("xi fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[0])
										{
											lastquenuelocation[0] = 1;
											pthread_t    		xipid; 
											int dcret = pthread_create(&xipid,NULL,(void *)ms_phase_monitor_deal_xi,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_xi,create major salve detect thread err");
													#endif
												return ;
											}
										}
										
									}
									if(currentquenuelocation[1] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("nan fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[1])
										{
											lastquenuelocation[1] = 1;
											pthread_t    		nanpid; 
											int dcret = pthread_create(&nanpid,NULL,(void *)ms_phase_monitor_deal_nan,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_nan,create major salve detect thread err");
													#endif
												return ;
											}
										}
										
									}
									if(currentquenuelocation[2] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("dong fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[2])
										{
											lastquenuelocation[2] = 1;
											pthread_t    		dongpid; 
											int dcret = pthread_create(&dongpid,NULL,(void *)ms_phase_monitor_deal_dong,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_dong,create major salve detect thread err");
													#endif
												return ;
											}
										}	
										
									}
									if(currentquenuelocation[3] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("bei fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[3])
										{
											lastquenuelocation[3] = 1;
											pthread_t    		beipid; 
											int dcret = pthread_create(&beipid,NULL,(void *)ms_phase_monitor_deal_bei,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_bei,create major salve detect thread err");
													#endif
												return ;
											}
										}
										
									}
									roadreport[0] = 0x21;
									roadreport[1] = 0x85;
									roadreport[2] = 0xFB;
									roadreport[3] = 0x00;
									roadreport[4] = 0xff;
									roadreport[5] = 0xff;
									roadreport[6] = 0xff;
									roadreport[7] = 0xff;
									unsigned char jiechuchannel[MAX_CHANNEL] = {0};
									unsigned char q= 0,e = 0,flag = 0;
									if(currentquenuelocation[0] == 0 && lastquenuelocation[0] == 1)
									{
										roadreport[6]  &=  0xef;
										flag = 0;
										lastquenuelocation[0] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 2== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 9== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 7== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}
									if(currentquenuelocation[1] == 0 && lastquenuelocation[1] == 1)
									{
										roadreport[6]  &=  0xdf;
										flag = 0;
										lastquenuelocation[1] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 12== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 1== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 6== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}								
									if(currentquenuelocation[2] == 0 && lastquenuelocation[2] == 1)
									{
										roadreport[6]  &=  0xbf;
										flag = 0;
										lastquenuelocation[2] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 5== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 4== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 11== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}								
									if(currentquenuelocation[3] == 0 && lastquenuelocation[3] == 1)
									{
										roadreport[6]  &=  0x7f;
										flag = 0;
										lastquenuelocation[3] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 3== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 10== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}
									if(jiechuchannel[0] != 0)
									{
										iscarquenueonerflow = 0;
									}
									if(currentquenuechannel[0] == 0)
									{
										memset(jiechuchannel,0,sizeof(jiechuchannel));
										memcpy(jiechuchannel,pinfo->chan,sizeof(jiechuchannel));
									}
									if(0 == iscarquenueonerflow)
									{	
										if(roadreport[6] == 0xff)
										{
											continue;
										}
										write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
										#ifdef ROADINFO_DEBUG
										printf("send jichu  report:");
										for(i=0;i<sizeof(roadreport);i++)
										{
											
											printf("%02x ",roadreport[i]);
										}
										printf("\n");
										#endif
										unsigned char greenchannel[MAX_CHANNEL]={0};
										if(0 != persiondelaychannel[0])
										{
											unsigned char q,w,e = 0,flag = 0;		
											for(q = 0;q<MAX_CHANNEL;q++)
											{
												if(0 == jiechuchannel[q])
												{
													break;
												}
												for(w = 0;w<MAX_CHANNEL;w++)
												{
													if(0 == persiondelaychannel[w])
													{
														break;
													}
													if(jiechuchannel[q] == persiondelaychannel[w])
													{
														flag = 0;
														break;
													}
													flag = 1;
												}
												if(flag)
												{
													greenchannel[e] = jiechuchannel[q];
													e++;
												}
												flag = 0;
											}
										}
										else
										{
											memcpy(greenchannel,jiechuchannel,sizeof(greenchannel));
										}
										if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),greenchannel,0x02))
										{
											#ifdef ROADINFO_DEBUG
											printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
											gettimeofday(&ct,NULL);
											update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
											if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																				dcdata->fd->softevent,dcdata->fd->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
													printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
											}
											*(dcdata->fd->markbit) |= 0x0800;
										}
										
										if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,greenchannel,0x02, \
											                                                dcdata->fd->markbit))
									    {
									    	#ifdef ROADINFO_DEBUG
									        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
									    	#endif
									    }
										if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
										{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
											
											sinfo.color = 0x02;
											sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
											csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == greenchannel[i])
													break;
												sinfo.chans += 1;
												tcsta = greenchannel[i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02;
												*csta = tcsta;
												csta++;
											}
											memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
											memset(sibuf,0,sizeof(sibuf));
											if (SUCCESS != status_info_report(sibuf,&sinfo))
											{
												#ifdef ROADINFO_DEBUG
													printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
												#endif
											}
											else
											{
												write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
											}
										}						
										memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
									}

									
									continue;
								}
								else
								{
									nowtime.tv_sec = 0;
	                        		nowtime.tv_usec = 0;
	                        		gettimeofday(&nowtime,NULL);
	                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
	                        		sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
									continue;
								}
							}
							else
							{
								nowtime.tv_sec = 0;
								nowtime.tv_usec = 0;
								gettimeofday(&nowtime,NULL);
								leatime = nowtime.tv_sec - lasttime.tv_sec;
								sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
								continue;
							}
						}//mret > 0
					}//while (1)

					if (0 == ffw)
					{
				#if 0
						//create thread to pass person channels
						if (0 == dcpcyes)
						{
							memset(&dpdata,0,sizeof(dpdata));
							dpdata.bbserial = dcdata->fd->bbserial;
							dpdata.pchan = pinfo->cpchan;
							dpdata.markbit = dcdata->fd->markbit;
							dpdata.sockfd = dcdata->fd->sockfd;
							dpdata.cs = dcdata->cs;
							dpdata.time = pinfo->pctime;
							int pcret = pthread_create(&dcpcid,NULL,(void *)ms_person_chan_greenflash,&dpdata);
							if (0 != pcret)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("Create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
								output_log("Detect control,create person greenflash thread err");
							#endif
								ms_end_part_child_thread();
								return;
							}
							dcpcyes = 1;
						}
				#endif
						if (0 == pinfo->cchan[0])
						{
							if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
								sinfo.time = pinfo->ldeti + pinfo->gftime + pinfo->ytime + pinfo->rtime;	
						//		#ifdef FULL_DOWN_TIME
								if (*(dcdata->fd->auxfunc) & 0x01)
                    				sinfo.time += *(dcdata->fd->halfdownt);
                    	//		#endif
								sinfo.color = 0x02;
								sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
								for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					if (0 == pinfo->cpchan[i])
                   						break;
                					for (j = 0; j < sinfo.chans; j++)
                					{
                   						if (0 == sinfo.csta[j])
                       						break;
                   						tcsta = sinfo.csta[j];
                   						tcsta &= 0xfc;
                   						tcsta >>= 2;
                   						tcsta &= 0x3f;
                   						if (tcsta == pinfo->cpchan[i])
                   						{
                       						sinfo.csta[j] &= 0xfc;
											sinfo.csta[j] |= 0x03;
											break;
                   						}
                					}
            					}
								memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
								memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}	
							}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						}
						else
						{
							if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
								sinfo.time = pinfo->ldeti + pinfo->gftime;
								if (*(dcdata->fd->auxfunc) & 0x01)
                                    sinfo.time += *(dcdata->fd->halfdownt);	
								sinfo.color = 0x02;
								sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
								for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					if (0 == pinfo->cpchan[i])
                   						break;
                					for (j = 0; j < sinfo.chans; j++)
                					{
                   						if (0 == sinfo.csta[j])
                       						break;
                   						tcsta = sinfo.csta[j];
                   						tcsta &= 0xfc;
                   						tcsta >>= 2;
                   						tcsta &= 0x3f;
                   						if (tcsta == pinfo->cpchan[i])
                   						{
                       						sinfo.csta[j] &= 0xfc;
											sinfo.csta[j] |= 0x03;
											break;
                   						}
                					}
            					}
								memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
								memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}	
							}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						}
					}//0 == ffw
				}//have person channels
				else
				{//not have person channels
		//			sleep((pinfo->mingtime) - (pinfo->pdelay));
					sltime = pinfo->mingtime - pinfo->ldeti;
					ffw = 0;
					int max = 0;
					unsigned char receivetime = 0;
					while (1)	
					{
						FD_ZERO(&nRead);
						FD_SET(*(dcdata->fd->ffpipe),&nRead);
						lasttime.tv_sec = 0;
						lasttime.tv_usec = 0;
						gettimeofday(&lasttime,NULL);
						bakv = sltime;
						mtime.tv_sec = sltime;
						mtime.tv_usec = 0;max = MAX(*(dcdata->fd->flowpipe),*(dcdata->fd->ffpipe));
						int mret = select(max+1,&nRead,NULL,NULL,&mtime);
						if (mret < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							break;
						}
						if (0 == mret)
						{
							break;
						}
						if (mret > 0)
						{
							if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
								read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
								if (!strncmp(buf,"fastforward",11)&&(0 == iscarquenueonerflow))
								{
									ffw = 1;
									break;
								}
								else
								{
									nowtime.tv_sec = 0;
                        			nowtime.tv_usec = 0;
                        			gettimeofday(&nowtime,NULL);
                        			leatime = nowtime.tv_sec - lasttime.tv_sec;
                        			sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
                        			continue;
								}
							}
							else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
								int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
								if((0xF4 == buf[0]) && (0xED == buf[len-1]))
								{
									#ifdef ROADINFO_DEBUG
									printf("receive hou quenue data: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
									memset(currentquenuelocation,0,sizeof(currentquenuelocation));
									
									unsigned char i =0,k =0,p =0,j=0,w =0;
									
									for (j = 0; j < 1; j++)
									{
										if((buf[3]>>j) & 0x01)
										{
											istrafficlock = 1; 
											#ifdef ROADINFO_DEBUG
											printf("lock location is 17,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
										}
										else
										{
											istrafficlock = 0;
											#ifdef ROADINFO_DEBUG
											printf("no lock location,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
										}
									
									}
									if(1 == istrafficlock)
									{
										pthread_t   allredpid; 
										int dcret = pthread_create(&allredpid,NULL,(void *)ms_all_red,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("major_salve_detect_control,create major salve detect thread err");
												#endif
											return ;
										}
									}
									if(1 == istrafficlock)//交通死锁
									{
										nowtime.tv_sec = 0;
										nowtime.tv_usec = 0;
										gettimeofday(&nowtime,NULL);
										leatime = nowtime.tv_sec - lasttime.tv_sec;
										sltime -= leatime;
										if (sltime > bakv)
											sltime = bakv;
										#ifdef ROADINFO_DEBUG
										printf("jiao tong si suo wait jie chu: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										memset(lastquenuelocation,0,sizeof(lastquenuelocation));
										while(1)
										{
											FD_ZERO(&nRead);
											FD_SET(*(dcdata->fd->flowpipe),&nRead);
											int ret = select(*(dcdata->fd->flowpipe)+1,&nRead,NULL,NULL,NULL);
											if(ret > 0)
											{
												memset(buf,0,sizeof(buf));
												int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
												buf[len] = 0;
												if((0xF4 == buf[0]) && (0xED==buf[len-1])&& (0x01 == buf[3]))
												{
													#ifdef ROADINFO_DEBUG
													printf("continue wait : %s,Line: %d\n",__FILE__,__LINE__);	
													#endif
													continue;
												}
												else
												{
													#ifdef ROADINFO_DEBUG
													printf("si suo jie chu : %s,Line: %d\n",__FILE__,__LINE__);	
													#endif
													roadreport[0] = 0x21;
													roadreport[1] = 0x85;
													roadreport[2] = 0xFB;
													roadreport[3] = 0x00;
													roadreport[4] = 0xff;
													roadreport[5] = 0xfe; 
													roadreport[6] = 0xff;
													roadreport[7] = 0xff;
													write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
													#ifdef ROADINFO_DEBUG
													printf("send roaddata 1 :");
													for(k=0;k<8;k++)
													{
														printf("%02x ",roadreport[k]);
													}
													printf("\n");
													#endif
													if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
													{
														#ifdef ROADINFO_DEBUG
														printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
														#endif
														gettimeofday(&ct,NULL);
														update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
														if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																							dcdata->fd->softevent,dcdata->fd->markbit))
														{
																#ifdef ROADINFO_DEBUG
																printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
																#endif
														}
														*(dcdata->fd->markbit) |= 0x0800;
													}
													
													if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
																										dcdata->fd->markbit))
													{
														#ifdef ROADINFO_DEBUG
														printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
														#endif
													}
													if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
													{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
														
														sinfo.color = 0x02;
														sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
														sinfo.chans = 0;
														memset(sinfo.csta,0,sizeof(sinfo.csta));
														csta = sinfo.csta;
														for (i = 0; i < MAX_CHANNEL; i++)
														{
															if (0 == pinfo->chan[i])
																break;
															sinfo.chans += 1;
															tcsta = pinfo->chan[i];
															tcsta <<= 2;
															tcsta &= 0xfc;
															tcsta |= 0x02;
															*csta = tcsta;
															csta++;
														}
														memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
														memset(sibuf,0,sizeof(sibuf));
														if (SUCCESS != status_info_report(sibuf,&sinfo))
														{
																#ifdef ROADINFO_DEBUG
																printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
																#endif
														}
														else
														{
															write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
														}
													}				

													break;
												}
											}
											else
											{
												break;
											}
										}
										continue;
									}

									//排队溢出5
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
									if(1 == isdelay && (buf[4]>>4 & 0x0f) == 0x00)
									{
										
										continue;
									}
									if(receivetime == 1)
									{
										if(0 == isreport && (buf[4]>>4 & 0x0f) == 0x00)
										{
											
											continue;
										}
									}

									receivetime = 1;
									if(1 == isreport)
									{
										
										continue;
									}
									iscarquenueonerflow = 1;
									for(i=4;i<8;i++)
									{
										if((buf[4] >> i) & 0x01)
										{
											if(4 == i)
											{	
												pinfo->roadbit[p] = i;
												p++;
												w = 0;
												currentquenuelocation[0] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}
													if(2 == pinfo->chan[j])
													{
														pinfo->xiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(9 == pinfo->chan[j])
													{
													
														pinfo->xiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(7 == pinfo->chan[j])
													{
														pinfo->xiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}
												}
												pinfo->redchannel[k] = 2;
												k++;
												pinfo->redchannel[k] = 9;
												k++;
												pinfo->redchannel[k] = 7;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 13,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
											}
											else if(5 == i)
											{
												pinfo->roadbit[p] = i;
												p++;
												w =0;
												currentquenuelocation[1] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}
													if(12 == pinfo->chan[j])
													{
														pinfo->nanredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(1 == pinfo->chan[j])
													{
													
														pinfo->nanredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(6 == pinfo->chan[j])
													{
														pinfo->nanredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}

												}	
												pinfo->redchannel[k] = 12;
												k++;
												pinfo->redchannel[k] = 1;
												k++;
												pinfo->redchannel[k] = 6;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 14,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif

											}
											else if(6 == i)
											{
												pinfo->roadbit[p] = i;
												p++;
												w= 0;
												currentquenuelocation[2] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}
													if(5 == pinfo->chan[j])
													{
														pinfo->dongredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(4 == pinfo->chan[j])
													{
													
														pinfo->dongredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(11 == pinfo->chan[j])
													{
														pinfo->dongredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}										
												}
												pinfo->redchannel[k] = 5;
												k++;
												pinfo->redchannel[k] = 4;
												k++;
												pinfo->redchannel[k] = 11;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 15,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif

											}
											else if(7 == i)
											{
												pinfo->roadbit[p] = i;
												p++;
												w = 0;
												currentquenuelocation[3] = 1;
												for(j = 0;j < MAX_CHANNEL;j++)
												{
													if(0 == pinfo->chan[j])
													{
														break;
													}	
													if(8== pinfo->chan[j])
													{
														pinfo->beiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(3== pinfo->chan[j])
													{
													
														pinfo->beiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;
													}
													if(10 == pinfo->chan[j])
													{
														pinfo->beiredchannel[w] = pinfo->chan[j];
														//pinfo->redchannel[k] = pinfo->chan[j];
														//k++;
														w++;											
													}

												}
												pinfo->redchannel[k] = 8;
												k++;
												pinfo->redchannel[k] = 3;
												k++;
												pinfo->redchannel[k] = 10;
												k++;
												#ifdef ROADINFO_DEBUG
												printf("quenue location is 16,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif

											}			
										}
										else
										{
											continue;
										}
									}
									if(0 ==pinfo->redchannel[0])
									{
										iscarquenueonerflow = 0;
										
									}
									else
									{
										isreport = 1;
									}
									memcpy(currentquenuechannel,pinfo->redchannel,sizeof(currentquenuechannel));
									if(currentquenuelocation[0] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("xi fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[0])
										{
											lastquenuelocation[0] = 1;
											pthread_t    		xipid; 
											int dcret = pthread_create(&xipid,NULL,(void *)ms_phase_monitor_deal_xi,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_xi,create major salve detect thread err");
													#endif
												return ;
											}
										}
										
									}
									if(currentquenuelocation[1] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("nan fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[1])
										{
											lastquenuelocation[1] = 1;
											pthread_t    		nanpid; 
											int dcret = pthread_create(&nanpid,NULL,(void *)ms_phase_monitor_deal_nan,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_nan,create major salve detect thread err");
													#endif
												return ;
											}
										}
										
									}
									if(currentquenuelocation[2] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("dong fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[2])
										{
											lastquenuelocation[2] = 1;
											pthread_t    		dongpid; 
											int dcret = pthread_create(&dongpid,NULL,(void *)ms_phase_monitor_deal_dong,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_dong,create major salve detect thread err");
													#endif
												return ;
											}
										}	
										
									}
									if(currentquenuelocation[3] == 1)
									{
										#ifdef ROADINFO_DEBUG
										printf("bei fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
										if(1 != lastquenuelocation[3])
										{
											lastquenuelocation[3] = 1;
											pthread_t    		beipid; 
											int dcret = pthread_create(&beipid,NULL,(void *)ms_phase_monitor_deal_bei,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("ms_phase_monitor_deal_bei,create major salve detect thread err");
													#endif
												return ;
											}
										}
										
									}
									roadreport[0] = 0x21;
									roadreport[1] = 0x85;
									roadreport[2] = 0xFB;
									roadreport[3] = 0x00;
									roadreport[4] = 0xff;
									roadreport[5] = 0xff;
									roadreport[6] = 0xff;
									roadreport[7] = 0xff;
									unsigned char jiechuchannel[MAX_CHANNEL] = {0};
									unsigned char q= 0,e = 0,flag = 0;
									if(currentquenuelocation[0] == 0 && lastquenuelocation[0] == 1)
									{
										roadreport[6]  &=  0xef;
										flag = 0;
										lastquenuelocation[0] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 2== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 9== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 7== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}
									if(currentquenuelocation[1] == 0 && lastquenuelocation[1] == 1)
									{
										roadreport[6]  &=  0xdf;
										flag = 0;
										lastquenuelocation[1] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 12== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 1== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 6== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}								
									if(currentquenuelocation[2] == 0 && lastquenuelocation[2] == 1)
									{
										roadreport[6]  &=  0xbf;
										flag = 0;
										lastquenuelocation[2] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 5== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 4== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 11== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}								
									if(currentquenuelocation[3] == 0 && lastquenuelocation[3] == 1)
									{
										roadreport[6]  &=  0x7f;
										flag = 0;
										lastquenuelocation[3] = 0;
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == pinfo->chan[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == currentquenuechannel[w])
												{
													break;
												}
												if( pinfo->chan[q]== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												/*if( 3== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}
												if( 10== currentquenuechannel[w])
												{
													flag = 0;
													break;
												}*/
												flag = 1;
											}
											if(flag)
											{
												jiechuchannel[e] = pinfo->chan[q];
												e++;
											}
											flag = 0;
										}
									}
									if(jiechuchannel[0] != 0)
									{
										iscarquenueonerflow = 0;
									}
									if(currentquenuechannel[0] == 0)
									{
										memset(jiechuchannel,0,sizeof(jiechuchannel));
										memcpy(jiechuchannel,pinfo->chan,sizeof(jiechuchannel));
									}
									if(0 == iscarquenueonerflow)
									{	
										if(0xff == roadreport[6])
										{
											continue;
										}
										write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
										#ifdef ROADINFO_DEBUG
										printf("send jichu  report:");
										for(i=0;i<sizeof(roadreport);i++)
										{
											
											printf("%02x ",roadreport[i]);
										}
										printf("\n");
										#endif
										unsigned char greenchannel[MAX_CHANNEL]={0};
										if(0 != persiondelaychannel[0])
										{
											unsigned char q,w,e = 0,flag = 0;		
											for(q = 0;q<MAX_CHANNEL;q++)
											{
												if(0 == jiechuchannel[q])
												{
													break;
												}
												for(w = 0;w<MAX_CHANNEL;w++)
												{
													if(0 == persiondelaychannel[w])
													{
														break;
													}
													if(jiechuchannel[q] == persiondelaychannel[w])
													{
														flag = 0;
														break;
													}
													flag = 1;
												}
												if(flag)
												{
													greenchannel[e] = jiechuchannel[q];
													e++;
												}
												flag = 0;
											}
										}
										else
										{
											memcpy(greenchannel,jiechuchannel,sizeof(greenchannel));
										}
										if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),greenchannel,0x02))
										{
											#ifdef ROADINFO_DEBUG
											printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
											gettimeofday(&ct,NULL);
											update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
											if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																				dcdata->fd->softevent,dcdata->fd->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
													printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
											}
											*(dcdata->fd->markbit) |= 0x0800;
										}
										
										if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,greenchannel,0x02, \
											                                                dcdata->fd->markbit))
									    {
									    	#ifdef ROADINFO_DEBUG
									        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
									    	#endif
									    }
										if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
										{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
											
											sinfo.color = 0x02;
											sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
											csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == greenchannel[i])
													break;
												sinfo.chans += 1;
												tcsta = greenchannel[i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02;
												*csta = tcsta;
												csta++;
											}
											memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
											memset(sibuf,0,sizeof(sibuf));
											if (SUCCESS != status_info_report(sibuf,&sinfo))
											{
												#ifdef ROADINFO_DEBUG
													printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
												#endif
											}
											else
											{
												write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
											}
										}						
										memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
									}

									
									continue;
								}
								else
								{
									nowtime.tv_sec = 0;
	                        		nowtime.tv_usec = 0;
	                        		gettimeofday(&nowtime,NULL);
	                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
	                        		sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
									continue;
								}
							}
							else
							{
								nowtime.tv_sec = 0;
								nowtime.tv_usec = 0;
								gettimeofday(&nowtime,NULL);
								leatime = nowtime.tv_sec - lasttime.tv_sec;
								sltime -= leatime;
								if (sltime > bakv)
                                	sltime = bakv;
								continue;
							}
						}//mret > 0
					}//while (1)	
				}//not have person channels

				if (0 == ffw)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("Monitor vehicle,time: %d,File: %s,Line: %d\n",pinfo->ldeti,__FILE__,__LINE__);
				#endif
					mt = pinfo->ldeti;
					mintime = pinfo->mingtime;
					int maxv = 0;
					unsigned char receivetime = 0;
					while (1)
					{//while loop
						//clean pipe
                		while (1)
                		{
                    		memset(buf,0,sizeof(buf));
                    		if (read(*(dcdata->fd->flowpipe),buf,sizeof(buf)) <= 0)
                        		break;
                		}
						FD_ZERO(&nRead);
						FD_SET(*(dcdata->fd->flowpipe),&nRead);
						FD_SET(*(dcdata->fd->ffpipe),&nRead);
						lasttime.tv_sec = 0;
						lasttime.tv_usec = 0;
						gettimeofday(&lasttime,NULL);
						bakv = mt;
						mtime.tv_sec = mt;
						mtime.tv_usec = 0;
						maxv = MAX(*(dcdata->fd->flowpipe),*(dcdata->fd->ffpipe));
						int mret = select(maxv+1,&nRead,NULL,NULL,&mtime);
						if (mret < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
							output_log("Detect control,select call err");
						#endif
							return;
						}
						if (0 == mret)
						{//time out
							break;
						}//time out
						if (mret > 0)
						{//mret > 0
							if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
                                num = 0;
                                pbuf = buf;
                                num = read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
								if (num > sizeof(buf))
                                	continue;
                                if (!strncmp(buf,"fastforward",11))
                                {
									ffw = 1;
                                    break;
                                }
								else
								{
									nowtime.tv_sec = 0;
                        			nowtime.tv_usec = 0;
                        			gettimeofday(&nowtime,NULL);
                        			leatime = nowtime.tv_sec - lasttime.tv_sec;
                        			mt -= leatime;
									if (mt > bakv)
										mt = bakv;
                        			continue;
								}
							}
							else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
							{
								memset(buf,0,sizeof(buf));
								num = 0;
								pbuf = buf;
								num = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
								if (num > sizeof(buf))
                                	continue;
								if (num <= 0)
								{
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									mt -= leatime;
									if (mt > bakv)
										mt = bakv;
									continue;
								}
								else
								{//num > 0
									mark = 0;
									caryes = 0;
									bevent = 0;
									while (1)
									{//inline while loop
										if (mark >= num)
											break;
										if((0xF4 == *(pbuf+mark)) && (0xED == *(pbuf+mark+6)))
										{
											#ifdef ROADINFO_DEBUG
											printf("receive hou quenue data: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
											memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
											memset(currentquenuelocation,0,sizeof(currentquenuelocation));
											
											unsigned char i =0,k =0,p =0,j=0,w =0;
											
											for (j = 0; j < 1; j++)
											{
												if((buf[3]>>j) & 0x01)
												{
													istrafficlock = 1; 
													#ifdef ROADINFO_DEBUG
													printf("lock location is 17,File: %s,Line: %d\n",__FILE__,__LINE__);	
													#endif
												}
												else
												{
													istrafficlock = 0;
													#ifdef ROADINFO_DEBUG
													printf("no lock location,File: %s,Line: %d\n",__FILE__,__LINE__);	
													#endif
												}
											
											}
											if(1 == istrafficlock)
											{
												pthread_t   allredpid; 
												int dcret = pthread_create(&allredpid,NULL,(void *)ms_all_red,dcdata);
												if (0 != dcret)
												{
														#ifdef ROADINFO_DEBUG
														printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
														output_log("major_salve_detect_control,create major salve detect thread err");
														#endif
													return ;
												}
											}
											if(1 == istrafficlock)//交通死锁
											{
												nowtime.tv_sec = 0;
												nowtime.tv_usec = 0;
												gettimeofday(&nowtime,NULL);
												leatime = nowtime.tv_sec - lasttime.tv_sec;
												mt -= leatime;
												if (mt > bakv)
				                                    mt = bakv;
												#ifdef ROADINFO_DEBUG
												printf("jiao tong si suo wait jie chu: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												memset(lastquenuelocation,0,sizeof(lastquenuelocation));
												while(1)
												{
													FD_ZERO(&nRead);
													FD_SET(*(dcdata->fd->flowpipe),&nRead);
													int ret = select(*(dcdata->fd->flowpipe)+1,&nRead,NULL,NULL,NULL);
													if(ret > 0)
													{
														memset(buf,0,sizeof(buf));
														int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
														buf[len] = 0;
														if((0xF4 == buf[0]) && (0xED==buf[len-1])&& (0x01 == buf[3]))
														{
															#ifdef ROADINFO_DEBUG
															printf("continue wait : %s,Line: %d\n",__FILE__,__LINE__);	
															#endif
															continue;
														}
														else
														{
															#ifdef ROADINFO_DEBUG
															printf("si suo jie chu : %s,Line: %d\n",__FILE__,__LINE__);	
															#endif
															roadreport[0] = 0x21;
															roadreport[1] = 0x85;
															roadreport[2] = 0xFB;
															roadreport[3] = 0x00;
															roadreport[4] = 0xff;
															roadreport[5] = 0xfe; 
															roadreport[6] = 0xff;
															roadreport[7] = 0xff;
															write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
															#ifdef ROADINFO_DEBUG
															printf("send roaddata 1 :");
															for(k=0;k<8;k++)
															{
																printf("%02x ",roadreport[k]);
															}
															printf("\n");
															#endif
															if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
															{
																#ifdef ROADINFO_DEBUG
																printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
																#endif
																gettimeofday(&ct,NULL);
																update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
																if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																									dcdata->fd->softevent,dcdata->fd->markbit))
																{
																		#ifdef ROADINFO_DEBUG
																		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
																		#endif
																}
																*(dcdata->fd->markbit) |= 0x0800;
															}
															
															if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
																												dcdata->fd->markbit))
															{
																#ifdef ROADINFO_DEBUG
																printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
																#endif
															}
															if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
															{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
																
																sinfo.color = 0x02;
																sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
																sinfo.chans = 0;
																memset(sinfo.csta,0,sizeof(sinfo.csta));
																csta = sinfo.csta;
																for (i = 0; i < MAX_CHANNEL; i++)
																{
																	if (0 == pinfo->chan[i])
																		break;
																	sinfo.chans += 1;
																	tcsta = pinfo->chan[i];
																	tcsta <<= 2;
																	tcsta &= 0xfc;
																	tcsta |= 0x02;
																	*csta = tcsta;
																	csta++;
																}
																memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
																memset(sibuf,0,sizeof(sibuf));
																if (SUCCESS != status_info_report(sibuf,&sinfo))
																{
																		#ifdef ROADINFO_DEBUG
																		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
																		#endif
																}
																else
																{
																	write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
																}
															}				

															break;
														}
													}
													else
													{
														break;
													}
												}
												break;
											}

											//排队溢出6
//											nowtime.tv_sec = 0;
//											nowtime.tv_usec = 0;
//											gettimeofday(&nowtime,NULL);
//											leatime = nowtime.tv_sec - lasttime.tv_sec;
//											mt -= leatime;
//											if (mt > bakv)
//			                                    mt = bakv;
											if(1 == isdelay && (buf[4]>>4 & 0x0f) == 0x00)
											{
												bevent = 1;
												break;
											}
											if(receivetime == 1)
											{
												if(0 == isreport && (buf[4]>>4 & 0x0f) == 0x00)
												{
													bevent = 1;
													break;
												}
											}
											
											unsigned char curretlefttime;
										curretlefttime = pinfo->gftime;
										if (*(dcdata->fd->auxfunc) & 0x01)
                                        curretlefttime += *(dcdata->fd->halfdownt);
										if(curretlefttime > 6)
										{
											curretlefttime = 6;
										}

										curretlefttime += mt;
										if(curretlefttime < 6)
										{
											bevent = 1;
											break;
										}
											if(1 == isreport)
											{
												bevent = 1;
												break;
											}
											iscarquenueonerflow = 1;
											for(i=4;i<8;i++)
											{
												if((buf[4] >> i) & 0x01)
												{
													if(4 == i)
													{	
														pinfo->roadbit[p] = i;
														p++;
														w = 0;
														currentquenuelocation[0] = 1;
														for(j = 0;j < MAX_CHANNEL;j++)
														{
															if(0 == pinfo->chan[j])
															{
																break;
															}
															if(2 == pinfo->chan[j])
															{
																pinfo->xiredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(9 == pinfo->chan[j])
															{
															
																pinfo->xiredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(7 == pinfo->chan[j])
															{
																pinfo->xiredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;											
															}
														}
														pinfo->redchannel[k] = 2;
														k++;
														pinfo->redchannel[k] = 9;
														k++;
														pinfo->redchannel[k] = 7;
														k++;
														#ifdef ROADINFO_DEBUG
														printf("quenue location is 13,File: %s,Line: %d\n",__FILE__,__LINE__);	
														#endif
													}
													else if(5 == i)
													{
														pinfo->roadbit[p] = i;
														p++;
														w =0;
														currentquenuelocation[1] = 1;
														for(j = 0;j < MAX_CHANNEL;j++)
														{
															if(0 == pinfo->chan[j])
															{
																break;
															}
															if(12 == pinfo->chan[j])
															{
																pinfo->nanredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(1 == pinfo->chan[j])
															{
															
																pinfo->nanredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(6 == pinfo->chan[j])
															{
																pinfo->nanredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;											
															}

														}
														pinfo->redchannel[k] = 12;
														k++;
														pinfo->redchannel[k] = 1;
														k++;
														pinfo->redchannel[k] = 6;
														k++;
														#ifdef ROADINFO_DEBUG
														printf("quenue location is 14,File: %s,Line: %d\n",__FILE__,__LINE__);	
														#endif

													}
													else if(6 == i)
													{
														pinfo->roadbit[p] = i;
														p++;
														w= 0;
														currentquenuelocation[2] = 1;
														for(j = 0;j < MAX_CHANNEL;j++)
														{
															if(0 == pinfo->chan[j])
															{
																break;
															}
															if(5 == pinfo->chan[j])
															{
																pinfo->dongredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(4 == pinfo->chan[j])
															{
															
																pinfo->dongredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(11 == pinfo->chan[j])
															{
																pinfo->dongredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;											
															}										
														}
														pinfo->redchannel[k] = 4;
														k++;
														pinfo->redchannel[k] = 5;
														k++;
														pinfo->redchannel[k] = 11;
														k++;
														#ifdef ROADINFO_DEBUG
														printf("quenue location is 15,File: %s,Line: %d\n",__FILE__,__LINE__);	
														#endif

													}
													else if(7 == i)
													{
														pinfo->roadbit[p] = i;
														p++;
														w = 0;
														currentquenuelocation[3] = 1;
														for(j = 0;j < MAX_CHANNEL;j++)
														{
															if(0 == pinfo->chan[j])
															{
																break;
															}	
															if(8== pinfo->chan[j])
															{
																pinfo->beiredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(3== pinfo->chan[j])
															{
															
																pinfo->beiredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;
															}
															if(10 == pinfo->chan[j])
															{
																pinfo->beiredchannel[w] = pinfo->chan[j];
																//pinfo->redchannel[k] = pinfo->chan[j];
																//k++;
																w++;											
															}

														}
														pinfo->redchannel[k] = 8;
														k++;
														pinfo->redchannel[k] = 3;
														k++;
														pinfo->redchannel[k] = 10;
														k++;
														#ifdef ROADINFO_DEBUG
														printf("quenue location is 16,File: %s,Line: %d\n",__FILE__,__LINE__);	
														#endif

													}
												}
												else
												{
													
													continue;
												}
											}
											//排队溢出6
											if(0 ==pinfo->redchannel[0])
											{
												iscarquenueonerflow = 0;
											}
											else
											{
												isreport = 1;
											}
											memcpy(currentquenuechannel,pinfo->redchannel,sizeof(currentquenuechannel));
											if(currentquenuelocation[0] == 1)
											{
												#ifdef ROADINFO_DEBUG
												printf("xi fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												if(1 != lastquenuelocation[0])
												{
													lastquenuelocation[0] = 1;
													pthread_t    		xipid; 
													int dcret = pthread_create(&xipid,NULL,(void *)ms_phase_monitor_deal_xi,dcdata);
													if (0 != dcret)
													{
															#ifdef ROADINFO_DEBUG
															printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
															output_log("ms_phase_monitor_deal_xi,create major salve detect thread err");
															#endif
														return ;
													}
												}
												
											}
											if(currentquenuelocation[1] == 1)
											{
												#ifdef ROADINFO_DEBUG
												printf("nan fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												if(1 != lastquenuelocation[1])
												{
													lastquenuelocation[1] = 1;
													pthread_t    		nanpid; 
													int dcret = pthread_create(&nanpid,NULL,(void *)ms_phase_monitor_deal_nan,dcdata);
													if (0 != dcret)
													{
															#ifdef ROADINFO_DEBUG
															printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
															output_log("ms_phase_monitor_deal_nan,create major salve detect thread err");
															#endif
														return ;
													}
												}
												
											}
											if(currentquenuelocation[2] == 1)
											{
												#ifdef ROADINFO_DEBUG
												printf("dong fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												if(1 != lastquenuelocation[2])
												{
													lastquenuelocation[2] = 1;
													pthread_t    		dongpid; 
													int dcret = pthread_create(&dongpid,NULL,(void *)ms_phase_monitor_deal_dong,dcdata);
													if (0 != dcret)
													{
															#ifdef ROADINFO_DEBUG
															printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
															output_log("ms_phase_monitor_deal_dong,create major salve detect thread err");
															#endif
														return ;
													}
												}	
												
											}
											if(currentquenuelocation[3] == 1)
											{
												#ifdef ROADINFO_DEBUG
												printf("bei fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												if(1 != lastquenuelocation[3])
												{
													lastquenuelocation[3] = 1;
													pthread_t    		beipid; 
													int dcret = pthread_create(&beipid,NULL,(void *)ms_phase_monitor_deal_bei,dcdata);
													if (0 != dcret)
													{
															#ifdef ROADINFO_DEBUG
															printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
															output_log("ms_phase_monitor_deal_bei,create major salve detect thread err");
															#endif
														return ;
													}
												}
												
											}
											roadreport[0] = 0x21;
											roadreport[1] = 0x85;
											roadreport[2] = 0xFB;
											roadreport[3] = 0x00;
											roadreport[4] = 0xff;
											roadreport[5] = 0xff;
											roadreport[6] = 0xff;
											roadreport[7] = 0xff;
											unsigned char jiechuchannel[MAX_CHANNEL] = {0};
											unsigned char q= 0,e = 0,flag = 0;
											if(currentquenuelocation[0] == 0 && lastquenuelocation[0] == 1)
											{
												roadreport[6]  &=  0xef;
												flag = 0;
												lastquenuelocation[0] = 0;
												for(q = 0;q<MAX_CHANNEL;q++)
												{
													if(0 == pinfo->chan[q])
													{
														break;
													}
													for(w = 0;w<MAX_CHANNEL;w++)
													{
														if(0 == currentquenuechannel[w])
														{
															break;
														}
														if( pinfo->chan[q]== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														/* if( 2== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 9== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 7== currentquenuechannel[w])
														{
															flag = 0;
															break;
														} */
														flag = 1;
													}
													if(flag)
													{
														jiechuchannel[e] = pinfo->chan[q];
														e++;
													}
													flag = 0;
												}
											}
											if(currentquenuelocation[1] == 0 && lastquenuelocation[1] == 1)
											{
												roadreport[6]  &=  0xdf;
												flag = 0;
												lastquenuelocation[1] = 0;
												for(q = 0;q<MAX_CHANNEL;q++)
												{
													if(0 == pinfo->chan[q])
													{
														break;
													}
													for(w = 0;w<MAX_CHANNEL;w++)
													{
														if(0 == currentquenuechannel[w])
														{
															break;
														}
														if( pinfo->chan[q]== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														/* if( 12== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 1== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 6== currentquenuechannel[w])
														{
															flag = 0;
															break;
														} */
														flag = 1;
													}
													if(flag)
													{
														jiechuchannel[e] = pinfo->chan[q];
														e++;
													}
													flag = 0;
												}
											}								
											if(currentquenuelocation[2] == 0 && lastquenuelocation[2] == 1)
											{
												roadreport[6]  &=  0xbf;
												flag = 0;
												lastquenuelocation[2] = 0;
												for(q = 0;q<MAX_CHANNEL;q++)
												{
													if(0 == pinfo->chan[q])
													{
														break;
													}
													for(w = 0;w<MAX_CHANNEL;w++)
													{
														if(0 == currentquenuechannel[w])
														{
															break;
														}
														if( pinfo->chan[q]== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														/* if( 5== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 4== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 11== currentquenuechannel[w])
														{
															flag = 0;
															break;
														} */
														flag = 1;
													}
													if(flag)
													{
														jiechuchannel[e] = pinfo->chan[q];
														e++;
													}
													flag = 0;
												}
											}								
											if(currentquenuelocation[3] == 0 && lastquenuelocation[3] == 1)
											{
												roadreport[6]  &=  0x7f;
												flag = 0;
												lastquenuelocation[3] = 0;
												for(q = 0;q<MAX_CHANNEL;q++)
												{
													if(0 == pinfo->chan[q])
													{
														break;
													}
													for(w = 0;w<MAX_CHANNEL;w++)
													{
														if(0 == currentquenuechannel[w])
														{
															break;
														}
														if( pinfo->chan[q]== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														/* if( 8== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 3== currentquenuechannel[w])
														{
															flag = 0;
															break;
														}
														if( 10== currentquenuechannel[w])
														{
															flag = 0;
															break;
														} */
														flag = 1;
													}
													if(flag)
													{
														jiechuchannel[e] = pinfo->chan[q];
														e++;
													}
													flag = 0;
												}
											}
											if(jiechuchannel[0] != 0)
											{
												iscarquenueonerflow = 0;
											}
											if(currentquenuechannel[0] == 0)
											{
												memset(jiechuchannel,0,sizeof(jiechuchannel));
												memcpy(jiechuchannel,pinfo->chan,sizeof(jiechuchannel));
											}
											if(0 == iscarquenueonerflow)
											{	
												if(0xff == roadreport[6])
												{
													bevent = 1;
													break;
												}
												write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
												#ifdef ROADINFO_DEBUG
												printf("send jichu3  report:");
												for(i=0;i<sizeof(roadreport);i++)
												{
													
													printf("%02x ",roadreport[i]);
												}
												printf("\n");
												#endif
												unsigned char greenchannel[MAX_CHANNEL]={0};
												if(0 != persiondelaychannel[0])
												{
													unsigned char q,w,e = 0,flag = 0;		
													for(q = 0;q<MAX_CHANNEL;q++)
													{
														if(0 == jiechuchannel[q])
														{
															break;
														}
														for(w = 0;w<MAX_CHANNEL;w++)
														{
															if(0 == persiondelaychannel[w])
															{
																break;
															}
															if(jiechuchannel[q] == persiondelaychannel[w])
															{
																flag = 0;
																break;
															}
															flag = 1;
														}
														if(flag)
														{
															greenchannel[e] = jiechuchannel[q];
															e++;
														}
														flag = 0;
													}
												}
												else
												{
													memcpy(greenchannel,jiechuchannel,sizeof(greenchannel));
												}
												if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),greenchannel,0x02))
												{
													#ifdef ROADINFO_DEBUG
													printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
													#endif
													gettimeofday(&ct,NULL);
													update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
													if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																						dcdata->fd->softevent,dcdata->fd->markbit))
													{
													#ifdef FULL_DETECT_DEBUG
															printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
													#endif
													}
													*(dcdata->fd->markbit) |= 0x0800;
												}
												
												if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,greenchannel,0x02, \
													                                                dcdata->fd->markbit))
											    {
											    	#ifdef ROADINFO_DEBUG
											        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
											    	#endif
											    }
												if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
												{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
													
													sinfo.color = 0x02;
													sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
													sinfo.chans = 0;
													memset(sinfo.csta,0,sizeof(sinfo.csta));
													csta = sinfo.csta;
													for (i = 0; i < MAX_CHANNEL; i++)
													{
														if (0 == greenchannel[i])
															break;
														sinfo.chans += 1;
														tcsta = greenchannel[i];
														tcsta <<= 2;
														tcsta &= 0xfc;
														tcsta |= 0x02;
														*csta = tcsta;
														csta++;
													}
													memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
													memset(sibuf,0,sizeof(sibuf));
													if (SUCCESS != status_info_report(sibuf,&sinfo))
													{
														#ifdef ROADINFO_DEBUG
															printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
														#endif
													}
													else
													{
														write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
													}
												}						
												memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
											}

											
											break;
										}
										else if ((0xF1 == *(pbuf+mark)) && (0xED == *(pbuf+mark+5)))
										{
											deteid = *(pbuf+mark+2);
											//pinfo->pdelay = *(pbuf+mark+4);
											if(0xEE != *(pbuf+mark+4))
											{
												pinfo->pdelay = *(pbuf+mark+4);
											}
											if (0x01 == *(pbuf+mark+1))
											{//have vehicle pass
												for (j = 0; j < (dcdata->td->detector->FactDetectorNum); j++)
												{
													if (0 == (dcdata->td->detector->DetectorList[j].DetectorId))
														break;
												if (deteid == (dcdata->td->detector->DetectorList[j].DetectorId))
												{
													dtype = dcdata->td->detector->DetectorList[j].DetectorType;
													if ((0x40 == dtype) || (0x80 == dtype) || (0x04 == dtype))
														{//request or response detector or bus detector
															mappid = dcdata->td->detector->DetectorList[j].DetectorPhase;
															if (mappid == (pinfo->phaseid))
															{
																caryes = 1;
																break;
															}
														}//request or response detector
														else
														{//unfit detector
															break;
														}//unfit detector
													}//deteid(dcdata->td->detector->DetectorList[j].DetectorId)
												}//for (j = 0; j < (dcdata->td->detector->FactDetectorNum); j++)
												if (1 == caryes)
													break;//jump out while loop
											}//have vehicle pass
											mark += 6;
											continue;//fit data,directly break;
										}
										else
										{
											mark += 1;
											continue;
										}
									}//inline while loop
									if(bevent == 1)
									{
										nowtime.tv_sec = 0;
										nowtime.tv_usec = 0;
										gettimeofday(&nowtime,NULL);
										leatime = nowtime.tv_sec - lasttime.tv_sec;
										mt -= leatime;
										if (mt > bakv)
											mt = bakv;
										continue;
									}
									if (1 == caryes)
									{
										nowtime.tv_sec = 0;
										nowtime.tv_usec = 0;
										gettimeofday(&nowtime,NULL);
										leatime = nowtime.tv_sec - lasttime.tv_sec;
										mt -= leatime;
										if (mt > bakv)
											mt = bakv;
										bakmaxg = 0;
										if (*(dcdata->fd->auxfunc) & 0x01)
											bakmaxg = pinfo->maxgtime1 - (*(dcdata->fd->halfdownt));
										else
											bakmaxg = pinfo->maxgtime1;
										if ((mintime + (pinfo->pdelay)) >= bakmaxg)
										{
											unsigned char lastdelattime = 0;
											lastdelattime = bakmaxg - mintime;
											delay_time_report(dcdata->fd->sockfd, lastdelattime);
											if ((!(*(dcdata->fd->markbit) & 0x1000)) && \
												(!(*(dcdata->fd->markbit) & 0x8000)))
											{
												if (0 == pinfo->cchan[0])
												{
													sinfo.time = mt + bakmaxg - mintime + \
																pinfo->gftime + pinfo->ytime + pinfo->rtime;
										//			#ifdef FULL_DOWN_TIME
													if (*(dcdata->fd->auxfunc) & 0x01)
                    									sinfo.time += *(dcdata->fd->halfdownt);
                    					//			#endif
												}
												else
												{
													sinfo.time = mt + bakmaxg - mintime + pinfo->gftime;
												//	if(pinfo->gftime == 0)
												//	{
														if (*(dcdata->fd->auxfunc) & 0x01)
	                                            		sinfo.time += *(dcdata->fd->halfdownt);
													//}
												}
												memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
            									if (SUCCESS != status_info_report(sibuf,&sinfo))
            									{
            									#ifdef FULL_DETECT_DEBUG
                								printf("status pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            									#endif
            									}
            									else
            									{
                									write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            									}	
											}
											if((*(dcdata->fd->markbit)&0x0002)&&(*(dcdata->fd->markbit)&0x0010))
                                        	{
                                            	memset(&timedown,0,sizeof(timedown));
                                            	timedown.mode = *(dcdata->fd->contmode);
                                            	timedown.pattern = *(dcdata->fd->patternid);
                                            	timedown.lampcolor = 0x02;
                                            	timedown.lamptime=mt+bakmaxg-mintime+(pinfo->gftime);
										//		#ifdef FULL_DOWN_TIME
												if (*(dcdata->fd->auxfunc) & 0x01)
                    								timedown.lamptime += *(dcdata->fd->halfdownt);
                    					//		#endif
                                            	timedown.phaseid = pinfo->phaseid;
                                            	timedown.stageline = pinfo->stageline;
                                            if(SUCCESS!=timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                                            	{
                                            	#ifdef FULL_DETECT_DEBUG
                                                	printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                            	#endif
                                            	}
                                        	}
											#ifdef EMBED_CONFIGURE_TOOL
											if (*(dcdata->fd->markbit2) & 0x0200)
											{
												memset(&timedown,0,sizeof(timedown));
                                                timedown.mode = *(dcdata->fd->contmode);
                                                timedown.pattern = *(dcdata->fd->patternid);
                                                timedown.lampcolor = 0x02;
                                                timedown.lamptime=mt+bakmaxg-mintime+(pinfo->gftime);
                                        //      #ifdef FULL_DOWN_TIME
                                                if (*(dcdata->fd->auxfunc) & 0x01)
                                                    timedown.lamptime += *(dcdata->fd->halfdownt);
                                        //      #endif
                                                timedown.phaseid = pinfo->phaseid;
                                                timedown.stageline = pinfo->stageline;
											if (SUCCESS!=timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("time fail,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
											}
											#endif
											//send info to face board
											if (*(dcdata->fd->contmode) < 27)
                								fbdata[1] = *(dcdata->fd->contmode) + 1;
            								else
                								fbdata[1] = *(dcdata->fd->contmode);
											if ((30 == fbdata[1]) || (31 == fbdata[1]))
                                        	{
                                            	fbdata[2] = 0;
                                            	fbdata[3] = 0;
                                            	fbdata[4] = 0;
                                        	}
                                        	else
											{
												fbdata[2] = pinfo->stageline;
            									fbdata[3] = 0x02;
            									fbdata[4] = mt+bakmaxg-mintime + (pinfo->gftime);
									//			#ifdef FULL_DOWN_TIME
												if (*(dcdata->fd->auxfunc) & 0x01)
                    								fbdata[4] += *(dcdata->fd->halfdownt);
                    				//			#endif
											}
            								if (!wait_write_serial(*(dcdata->fd->fbserial)))
            								{
                								if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                								{
                								#ifdef FULL_DETECT_DEBUG
                    								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                								#endif
													*(dcdata->fd->markbit) |= 0x0800;
                    								gettimeofday(&ct,NULL);
                    								update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16, \
																	ct.tv_sec,dcdata->fd->markbit);
                    							if(SUCCESS!=generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																	dcdata->fd->softevent,dcdata->fd->markbit))
                    								{
                    								#ifdef FULL_DETECT_DEBUG
                        							printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                    								#endif
                    								}
                								}
            								}
            								else
            								{
            								#ifdef FULL_DETECT_DEBUG
                							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            								#endif
            								}
											sendfaceInfoToBoard(dcdata->fd,fbdata);
											sleep(mt + bakmaxg - mintime);
											//added on 20220620
            								adaptd.phi[ni].paddt += bakmaxg - mintime;
											//end add
											break;
										}
										else
										{
										#ifdef FULL_DETECT_DEBUG
                                        	printf("Not arrive max green,delay %d sec,File: %s,Line: %d\n",pinfo->pdelay,__FILE__,__LINE__);
                                    	#endif
											delay_time_report(dcdata->fd->sockfd, pinfo->pdelay);

											if ((!(*(dcdata->fd->markbit) & 0x1000)) && \
                                            		(!(*(dcdata->fd->markbit) & 0x8000)))
                                        	{
												if (0 == pinfo->cchan[0])
												{
													sinfo.time = mt + (pinfo->pdelay) + pinfo->gftime + pinfo->ytime + pinfo->rtime;
										//			#ifdef FULL_DOWN_TIME
													if (*(dcdata->fd->auxfunc) & 0x01)
                    									sinfo.time += *(dcdata->fd->halfdownt);
                    					//			#endif
												}
												else
												{
                                            		sinfo.time = mt + (pinfo->pdelay) + pinfo->gftime;
												//	if(pinfo->gftime == 0)
													//{
														if (*(dcdata->fd->auxfunc) & 0x01)
	                                            		sinfo.time += *(dcdata->fd->halfdownt);
												//	}
												}
												memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
                                            	memset(sibuf,0,sizeof(sibuf));
                                            	if (SUCCESS != status_info_report(sibuf,&sinfo))
                                            	{
                                            	#ifdef FULL_DETECT_DEBUG
                                                printf("status pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                            	#endif
                                            	}
                                            	else
                                            	{
                                                	write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
                                            	}
                                        	}
											if((*(dcdata->fd->markbit)&0x0002)&&(*(dcdata->fd->markbit)&0x0010))
            								{
                								memset(&timedown,0,sizeof(timedown));
                								timedown.mode = *(dcdata->fd->contmode);
                								timedown.pattern = *(dcdata->fd->patternid);
                								timedown.lampcolor = 0x02;
                								timedown.lamptime = mt + (pinfo->pdelay) + (pinfo->gftime);
									//			#ifdef FULL_DOWN_TIME
												if (*(dcdata->fd->auxfunc) & 0x01)
                    								timedown.lamptime += *(dcdata->fd->halfdownt);
                    				//			#endif
                								timedown.phaseid = pinfo->phaseid;
                								timedown.stageline = pinfo->stageline;
                							if(SUCCESS!=timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                								{
                								#ifdef FULL_DETECT_DEBUG
                    								printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                								#endif
                								}
            								}
											#ifdef EMBED_CONFIGURE_TOOL
											if (*(dcdata->fd->markbit2) & 0x0200)
											{
												memset(&timedown,0,sizeof(timedown));
                                                timedown.mode = *(dcdata->fd->contmode);
                                                timedown.pattern = *(dcdata->fd->patternid);
                                                timedown.lampcolor = 0x02;
                                                timedown.lamptime = mt + (pinfo->pdelay) + (pinfo->gftime);
                                    //          #ifdef FULL_DOWN_TIME
                                                if (*(dcdata->fd->auxfunc) & 0x01)
                                                    timedown.lamptime += *(dcdata->fd->halfdownt);
                                    //          #endif
                                                timedown.phaseid = pinfo->phaseid;
                                                timedown.stageline = pinfo->stageline;
											if(SUCCESS!=timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("time fail,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
											}
											#endif
											//send info to face board
											if (*(dcdata->fd->contmode) < 27)
                								fbdata[1] = *(dcdata->fd->contmode) + 1;
            								else
                								fbdata[1] = *(dcdata->fd->contmode);
											if ((30 == fbdata[1]) || (31 == fbdata[1]))
                							{
                    							fbdata[2] = 0;
                    							fbdata[3] = 0;
                    							fbdata[4] = 0;
                							}
                							else
											{
												fbdata[2] = pinfo->stageline;
            									fbdata[3] = 0x02;
            									fbdata[4] = mt + (pinfo->pdelay) + (pinfo->gftime);
											//	#ifdef FULL_DOWN_TIME
												if (*(dcdata->fd->auxfunc) & 0x01)
                    								fbdata[4] += *(dcdata->fd->halfdownt);
                    						//	#endif
											}
            								if (!wait_write_serial(*(dcdata->fd->fbserial)))
            								{
                								if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                								{
                								#ifdef FULL_DETECT_DEBUG
                    								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                								#endif
													*(dcdata->fd->markbit) |= 0x0800;
                    								gettimeofday(&ct,NULL);
                    								update_event_list(dcdata->fd->ec,dcdata->fd->el, \
																	1,16,ct.tv_sec,dcdata->fd->markbit);
                    							if(SUCCESS!=generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																dcdata->fd->softevent,dcdata->fd->markbit))
                    								{
                    								#ifdef FULL_DETECT_DEBUG
                        							printf("genfileerr,File: %s,Line: %d\n",__FILE__,__LINE__);
                    								#endif
                    								}
                								}
            								}
            								else
            								{
            								#ifdef FULL_DETECT_DEBUG
                						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            								#endif
            								}
											sendfaceInfoToBoard(dcdata->fd,fbdata);
											sleep(mt);
											if (pinfo->pdelay > pinfo->ldeti)
											{
												mt = pinfo->pdelay - pinfo->ldeti;
												sleep(mt);
												mt = pinfo->ldeti;
											}
											else
											{
												mt = pinfo->pdelay;
											}
											mintime += pinfo->pdelay;
											//added on 20220620
            								adaptd.phi[ni].paddt += pinfo->pdelay;
											//end add
											continue;
										}
									}//if (1 == caryes)
									else
									{// 0 == caryes
										nowtime.tv_sec = 0;
										nowtime.tv_usec = 0;
										gettimeofday(&nowtime,NULL);
										leatime = nowtime.tv_sec - lasttime.tv_sec;
										mt -= leatime;
										if (mt > bakv)
											mt = bakv;
										continue;
									}// 0 == caryes
								}//num > 0
							}//else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
							else
							{
								nowtime.tv_sec = 0;
								nowtime.tv_usec = 0;
								gettimeofday(&nowtime,NULL);
								leatime = nowtime.tv_sec - lasttime.tv_sec;
								mt -= leatime;
								if (mt > bakv)
									mt = bakv;
								continue;
							}
						}//mret > 0
					}//while loop
				}//0 == ffw
	
		//		#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//11
						*(dcdata->fd->v2xmark) |= 0x01;//V2X
						for (i = 0; i < MAX_PHASE_LINE; i++)
						{
							if (0 == phdetect[i].stageid)
								break;
							if (pinfo->stageline == phdetect[i].stageid)
								break;
						}
						tchans = 0;
						downti[6] = 0;
						if (i != MAX_PHASE_LINE)
						{
							if (0 == phdetect[i+1].stageid)
							{
								tchans = phdetect[0].chans;
							}
							else
							{
								tchans = phdetect[i+1].chans;
							}
							downti[6] += *(dcdata->fd->halfdownt) + phdetect[i].gftime + \
											phdetect[i].ytime + phdetect[i].rtime;
							for (j = 0; j < MAX_CHANNEL; j++)
							{//for (j = 0; j < MAX_CHANNEL; j++)
								if (0 == (pinfo->chan[j]))
									break;
								if (tchans & (0x00000001 << (pinfo->chan[j] - 1)))
									tchans &= (~(0x00000001 << (pinfo->chan[j] - 1)));
							}//for (j = 0; j < MAX_CHANNEL; j++)
						}//if (i != MAX_PHASE_LINE)
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
						downti[5] = 0x00;

						#ifdef V2X_DEBUG
						unsigned char       v2xc[MAX_CHANNEL] = {0};
						unsigned char       *pv2xc = v2xc;
						for (j = 1; j < (MAX_CHANNEL+1); j++)
						{
							if (tchans & (0x00000001 << (j-1)))
							{
								*pv2xc = j;
								pv2xc++;
							}
						}
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == v2xc[j])
								break;
							if ((v2xc[j] < 13) || (v2xc[j] > 16))
							{
								dcdata->fd->slg[v2xc[j]-1].slgid = v2xc[j];
								dcdata->fd->slg[v2xc[j]-1].slgstatus = 0x15;
								dcdata->fd->slg[v2xc[j]-1].countdown = downti[6] + 1;
								dcdata->fd->slg[v2xc[j]-1].nslgstatus = 0x17;

								if (0 == phdetect[i+1].stageid)
                            	{
                                	dcdata->fd->slg[v2xc[j]-1].greent = phdetect[0].mingtime + phdetect[0].gftime;
                                    dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[0].ytime;
                                    dcdata->fd->slg[v2xc[j]-1].redt = phdetect[0].rtime;
                                    dcdata->fd->slg[v2xc[j]-1].allrt = 0;
                            	}
                            	else
                            	{
									dcdata->fd->slg[v2xc[j]-1].greent = phdetect[i+1].mingtime + phdetect[i+1].gftime;
                            		dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[i+1].ytime;
                            		dcdata->fd->slg[v2xc[j]-1].redt = phdetect[i+1].rtime;
                            		dcdata->fd->slg[v2xc[j]-1].allrt = 0;
								}
							}
						}
						#endif

						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}

						tchans = 0;
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == (pinfo->cchan[j]))
								break;
							tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
						}	
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
						downti[5] = 0x02;
						downti[6] = pinfo->gftime + *(dcdata->fd->halfdownt);
				
						#ifdef V2X_DEBUG
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == pinfo->cchan[j])
								break;
							if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
							{
								dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
								dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x17;
								dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
								dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x16;

								dcdata->fd->slg[pinfo->cchan[j]-1].greent = pinfo->gtime + pinfo->gftime;
								dcdata->fd->slg[pinfo->cchan[j]-1].yellowt = pinfo->ytime;
								dcdata->fd->slg[pinfo->cchan[j]-1].redt = pinfo->rtime;
								dcdata->fd->slg[pinfo->cchan[j]-1].allrt = 0;
							}
						}
						#endif

						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}//11
				}//if (*(dcdata->fd->auxfunc) & 0x01)
		//		#endif
		
				//added on 20220620
				adaptd.phi[ni].pfactt = adaptd.phi[ni].paddt + pinfo->mingtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
				if (*(dcdata->fd->auxfunc) & 0x01)
					adaptd.phi[ni].pfactt += *(dcdata->fd->halfdownt);
				//end add
				
				//green flash
				if ((0 != pinfo->cchan[0]) && (pinfo->gftime > 0))
				{
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						sinfo.time = pinfo->gftime;
				//		#ifdef FULL_DOWN_TIME
						if (*(dcdata->fd->auxfunc) & 0x01)
							sinfo.time += *(dcdata->fd->halfdownt);
				//		#endif
	
						sinfo.color = 0x03;
						sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
						for (i = 0; i < MAX_CHANNEL; i++)
           				{
            				if (0 == pinfo->cchan[i])
                   				break;
               				for (j = 0; j < sinfo.chans; j++)
               				{
                   				if (0 == sinfo.csta[j])
                   					break;
                   				tcsta = sinfo.csta[j];
                   				tcsta &= 0xfc;
                   				tcsta >>= 2;
                   				tcsta &= 0x3f;
                   				if (tcsta == pinfo->cchan[i])
                   				{
                       				sinfo.csta[j] &= 0xfc;
									sinfo.csta[j] |= 0x03;
									break;
                   				}
               				}
           				}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
           				if (SUCCESS != status_info_report(sibuf,&sinfo))
           				{
           				#ifdef FULL_DETECT_DEBUG
                			printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            			#endif
            			}
            			else
            			{
                			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            			}	
					}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				}
			
		//		#ifdef FULL_DOWN_TIME
				if ((*(dcdata->fd->auxfunc) & 0x01) && (0 == ffw))
					sleep(*(dcdata->fd->halfdownt));
		//		#endif

				if (1 == dcpcyes)
				{
					pthread_cancel(dcpcid);
					pthread_join(dcpcid,NULL);
					dcpcyes = 0;
				}

				memset(&gtime,0,sizeof(gtime));
            	memset(&gftime,0,sizeof(gftime));
				gettimeofday(&gftime,NULL);
            	memset(&ytime,0,sizeof(ytime));
            	memset(&rtime,0,sizeof(rtime));
				*(dcdata->fd->markbit) |= 0x0400;

				if (pinfo->gftime > 0)
				{
					num = 0;
					while (1)
					{
						if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x02))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							gettimeofday(&ct,NULL);
							update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
							if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
																dcdata->fd->softevent,dcdata->fd->markbit))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
							*(dcdata->fd->markbit) |= 0x0800;
						}
						if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x02, \
														dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						timeout.tv_sec = 0;
						timeout.tv_usec = 500000;
						select(0,NULL,NULL,NULL,&timeout);

						if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x03))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							gettimeofday(&ct,NULL);
							update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
							if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
																dcdata->fd->softevent,dcdata->fd->markbit))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
							*(dcdata->fd->markbit) |= 0x0800;
						}
						if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x03, \
														dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						timeout.tv_sec = 0;
						timeout.tv_usec = 500000;
						select(0,NULL,NULL,NULL,&timeout);
						
						num += 1;
						if (num >= (pinfo->gftime))
							break;
					}
				}//if (pinfo->gftime > 0)	
				//end green flash
				if (1 == phcon)
                {
                    *(dcdata->fd->markbit) &= 0xfbff;
                    memset(&gtime,0,sizeof(gtime));
                    gettimeofday(&gtime,NULL);
                    memset(&gftime,0,sizeof(gftime));
                    memset(&ytime,0,sizeof(ytime));
                    memset(&rtime,0,sizeof(rtime));
                    phcon = 0;
                    sleep(10);
                }
				#ifdef RED_FLASH	
				if (0 == dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].StageId)
				{
					rft = (dcdata->td->timeconfig->TimeConfigList[tcline][0].SpecFunc & 0xe0) >> 5;
				}
				else
				{
					rft = (dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].SpecFunc & 0xe0) >> 5;
				}
				if (rft > 0)
				{
					redflash_dc		dc;
					dc.tcline = tcline;
					dc.slnum = slnum;
					dc.snum =	snum;
					dc.rft = rft;
					dc.chan = pinfo->chan;
					dc.dc = dcdata;
					int rfarg = pthread_create(&rfpid,NULL,(void *)ms_red_flash,&dc);
					if (0 != rfarg)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						return;
					}
				}//if (rft > 0) 
				#endif
							gettimeofday(&ct,NULL);
			currenttime = ct.tv_sec;
			receiveroadtime =  *(dcdata->fd->roadinforeceivetime);
				//yellow lamp //待定相位黄灯处理
				if (1 == (pinfo->cpcexist))
				{
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cpchan,0x00))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
                		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                		{
                		#ifdef FULL_DETECT_DEBUG
                    		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                		#endif
                		}
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if(0 != currentquenuechannel[0])
					{
						unsigned char q,w,e = 0,flag = 0;
						memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
						for(q = 0;q<MAX_CHANNEL;q++)
						{
							if(0 == pinfo->cnpchan[q])
							{
								break;
							}
							for(w = 0;w<MAX_CHANNEL;w++)
							{
								if(0 == currentquenuechannel[w])
								{
									break;
								}
								if(pinfo->cnpchan[q] == currentquenuechannel[w])
								{
									flag = 0;
									break;
								}
								flag = 1;
							}
							if(flag)
							{
								yellowtoredchannel[e] = pinfo->cnpchan[q];
								e++;
							}
							flag = 0;
						}
					}
					else
					{
						memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
						memcpy(yellowtoredchannel,pinfo->cnpchan,sizeof(yellowtoredchannel));
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x00, \
                                                    dcdata->fd->markbit))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cnpchan,0x01))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
                        update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                        if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                        {
                        #ifdef FULL_DETECT_DEBUG
                            printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                        #endif
                        }
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x01, \
                                                    dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
				}
				else
				{
					if(0 != currentquenuechannel[0])
					{
						unsigned char q,w,e = 0,flag = 0;
						memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
						for(q = 0;q<MAX_CHANNEL;q++)
						{
							if(0 == pinfo->cchan[q])
							{
								break;
							}
							for(w = 0;w<MAX_CHANNEL;w++)
							{
								if(0 == currentquenuechannel[w])
								{
									break;
								}
								if(pinfo->cchan[q] == currentquenuechannel[w])
								{
									flag = 0;
									break;
								}
								flag = 1;
							}
							if(flag)
							{
								yellowtoredchannel[e] = pinfo->cchan[q];
								e++;
							}
							flag = 0;
						}
					}
					else
					{
						memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
						memcpy(yellowtoredchannel,pinfo->cchan,sizeof(yellowtoredchannel));
					}
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),yellowtoredchannel,0x01))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						gettimeofday(&ct,NULL);
                        update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                        if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                        {
                        #ifdef FULL_DETECT_DEBUG
                            printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                        #endif
                        }
						*(dcdata->fd->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x01, \
                                                    dcdata->fd->markbit))
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}	
				}

		//		#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//11
						*(dcdata->fd->v2xmark) |= 0x01;//V2X
						tchans = 0;
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == (pinfo->cnpchan[j]))
								break;
							tchans |= (0x00000001 << ((pinfo->cnpchan[j]) - 1));
						}
						downti[1] = 0;
						downti[1] |= (tchans & 0x000000ff);
						downti[2] = 0;
						downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
						downti[3] = 0;
						downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
						downti[4] = 0;
						downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
						downti[5] = 0x01;
						downti[6] = pinfo->ytime;

						#ifdef V2X_DEBUG
                        for (j = 0; j < MAX_CHANNEL; j++)
                        {
                            if (0 == pinfo->cchan[j])
                                break;
                            if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
                            {
                                dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
                                dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x16;
                                dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
                                dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x15;
                            }
                        }
                        #endif

						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}//11
				}//if (*(dcdata->fd->auxfunc) & 0x01)	
		//		#endif

				*(dcdata->fd->color) = 0x01;
				memset(&gtime,0,sizeof(gtime));
            	memset(&gftime,0,sizeof(gftime));
            	memset(&ytime,0,sizeof(ytime));
				gettimeofday(&ytime,NULL);
            	memset(&rtime,0,sizeof(rtime));

				if ((0 != pinfo->cchan[0]) && (pinfo->ytime > 0))
				{
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						sinfo.time = pinfo->ytime;	
						sinfo.color = 0x01;
						sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
						for (i = 0; i < MAX_CHANNEL; i++)
           				{
            				if (0 == pinfo->cnpchan[i])
                   				break;
               				for (j = 0; j < sinfo.chans; j++)
               				{
                   				if (0 == sinfo.csta[j])
                   					break;
                   				tcsta = sinfo.csta[j];
                   				tcsta &= 0xfc;
                   				tcsta >>= 2;
                   				tcsta &= 0x3f;
                   				if (tcsta == pinfo->cnpchan[i])
                   				{
                       				sinfo.csta[j] &= 0xfc;
									sinfo.csta[j] |= 0x01;
									break;
                   				}
               				}
            			}
						for (i = 0; i < MAX_CHANNEL; i++)
               			{
                   			if (0 == pinfo->cpchan[i])
                       			break;
                   			for (j = 0; j < sinfo.chans; j++)
                   			{
                       			if (0 == sinfo.csta[j])
                           			break;
                       			tcsta = sinfo.csta[j];
                       			tcsta &= 0xfc;
                       			tcsta >>= 2;
                       			tcsta &= 0x3f;
                       			if (tcsta == pinfo->cpchan[i])
                       			{
                           			sinfo.csta[j] &= 0xfc;
									break;
                       			}
                   			}
               			}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
            			if (SUCCESS != status_info_report(sibuf,&sinfo))
            			{
            			#ifdef FULL_DETECT_DEBUG
                			printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            			#endif
            			}
            			else
            			{
                			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            			}	
					}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				}

				if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            	{
                	memset(&timedown,0,sizeof(timedown));
                	timedown.mode = *(dcdata->fd->contmode);
                	timedown.pattern = *(dcdata->fd->patternid);
                	timedown.lampcolor = 0x01;
                	timedown.lamptime = pinfo->ytime;
                	timedown.phaseid = pinfo->phaseid;
                	timedown.stageline = pinfo->stageline;
                	if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                	#endif
                	}
            	}
				#ifdef EMBED_CONFIGURE_TOOL
				if (*(dcdata->fd->markbit2) & 0x0200)
				{
					memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x01;
                    timedown.lamptime = pinfo->ytime;
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;	
					if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
					}
				}
				#endif

				//send info to face board
				if (*(dcdata->fd->contmode) < 27)
                	fbdata[1] = *(dcdata->fd->contmode) + 1;
            	else
                	fbdata[1] = *(dcdata->fd->contmode);
				if ((30 == fbdata[1]) || (31 == fbdata[1]))
                {
                    fbdata[2] = 0;
                    fbdata[3] = 0;
                    fbdata[4] = 0;
                }
                else
				{
					fbdata[2] = pinfo->stageline;
            		fbdata[3] = 0x01;
            		fbdata[4] = pinfo->ytime;
				}
            	if (!wait_write_serial(*(dcdata->fd->fbserial)))
            	{
                	if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                	#endif
						*(dcdata->fd->markbit) |= 0x0800;
                    	gettimeofday(&ct,NULL);
                    	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                    	{
                    	#ifdef FULL_DETECT_DEBUG
                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    	#endif
                    	}
                	}
            	}
            	else
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
				sendfaceInfoToBoard(dcdata->fd,fbdata);
				sleep(pinfo->ytime);
				//end yellow lamp
			
				//red lamp
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x00))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
                	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                	#endif
                	}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x00, \
                                                    dcdata->fd->markbit))
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
				

				*(dcdata->fd->color) = 0x00;
				if (0 != pinfo->cchan[0])
				{
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						sinfo.time = pinfo->rtime;	
						sinfo.color = 0x00;
						sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
						for (i = 0; i < MAX_CHANNEL; i++)
           				{
           					if (0 == pinfo->cchan[i])
                  				break;
               				for (j = 0; j < sinfo.chans; j++)
               				{
                   				if (0 == sinfo.csta[j])
                   					break;
                   				tcsta = sinfo.csta[j];
                   				tcsta &= 0xfc;
                   				tcsta >>= 2;
                   				tcsta &= 0x3f;
                   				if (tcsta == pinfo->cchan[i])
                   				{
                       				sinfo.csta[j] &= 0xfc;
									break;
                   				}
               				}
           				}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));	
						memset(sibuf,0,sizeof(sibuf));
           				if (SUCCESS != status_info_report(sibuf,&sinfo))
           				{
           				#ifdef FULL_DETECT_DEBUG
                			printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            			#endif
            			}
            			else
            			{
                			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            			}	
					}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				}				
		
				if (*(dcdata->fd->auxfunc) & 0x01)
				{//if (*(dcdata->fd->auxfunc) & 0x01)
					if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
					{//11
						*(dcdata->fd->v2xmark) &= 0xfe;//V2X
						downti[5] = 0x00;
						downti[6] = pinfo->rtime;
						
						#ifdef V2X_DEBUG
						for (j = 0; j < MAX_CHANNEL; j++)
						{
							if (0 == pinfo->cchan[j])
								break;
							if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
							{
								dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
								dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x15;
								dcdata->fd->slg[pinfo->cchan[j]-1].countdown = 0xff;
								dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x17;

								dcdata->fd->slg[pinfo->cchan[j]-1].greent = 0;
                                dcdata->fd->slg[pinfo->cchan[j]-1].yellowt = 0;
                                dcdata->fd->slg[pinfo->cchan[j]-1].redt = 0;
                                dcdata->fd->slg[pinfo->cchan[j]-1].allrt = 0;
							}
						}
						#endif

						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						if (!wait_write_serial(*(dcdata->fd->bbserial)))
						{
							if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
						}
						else
						{
						#ifdef FULL_DETECT_DEBUG
							printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}//11
				}//if (*(dcdata->fd->auxfunc) & 0x01)	
				if ((pinfo->rtime) > 0)
                {
					memset(&gtime,0,sizeof(gtime));
                	memset(&gftime,0,sizeof(gftime));
                	memset(&ytime,0,sizeof(ytime));
                	memset(&rtime,0,sizeof(rtime));
                	gettimeofday(&rtime,NULL);

					if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            		{
                		memset(&timedown,0,sizeof(timedown));
                		timedown.mode = *(dcdata->fd->contmode);
                		timedown.pattern = *(dcdata->fd->patternid);
                		timedown.lampcolor = 0x00;
                		timedown.lamptime = pinfo->rtime;
                		timedown.phaseid = pinfo->phaseid;
                		timedown.stageline = pinfo->stageline;
                		if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                		{
                		#ifdef FULL_DETECT_DEBUG
                    		printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                		#endif
                		}
            		}
					#ifdef EMBED_CONFIGURE_TOOL
					if (*(dcdata->fd->markbit2) & 0x0200)
					{
						memset(&timedown,0,sizeof(timedown));
                        timedown.mode = *(dcdata->fd->contmode);
                        timedown.pattern = *(dcdata->fd->patternid);
                        timedown.lampcolor = 0x00;
                        timedown.lamptime = pinfo->rtime;
                        timedown.phaseid = pinfo->phaseid;
                        timedown.stageline = pinfo->stageline;	
						if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
					}
					#endif
					//send info to face board
					if (*(dcdata->fd->contmode) < 27)
                		fbdata[1] = *(dcdata->fd->contmode) + 1;
            		else
                		fbdata[1] = *(dcdata->fd->contmode);
					if ((30 == fbdata[1]) || (31 == fbdata[1]))
                	{
                    	fbdata[2] = 0;
                    	fbdata[3] = 0;
                    	fbdata[4] = 0;
                	}
                	else
					{
						fbdata[2] = pinfo->stageline;
            			fbdata[3] = 0x00;
            			fbdata[4] = pinfo->rtime;
					}
            		if (!wait_write_serial(*(dcdata->fd->fbserial)))
            		{
                		if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                		{
                		#ifdef FULL_DETECT_DEBUG
                    		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                		#endif
							*(dcdata->fd->markbit) |= 0x0800;
                    		gettimeofday(&ct,NULL);
                    		update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    		if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
																dcdata->fd->softevent,dcdata->fd->markbit))
                    		{
                    		#ifdef FULL_DETECT_DEBUG
                        		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    		#endif
                    		}
                		}
            		}
            		else
            		{
            		#ifdef FULL_DETECT_DEBUG
                		printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
					sendfaceInfoToBoard(dcdata->fd,fbdata);
					sleep(pinfo->rtime);
				}
				//end red lamp

			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phaseendtime = ct.tv_sec;
			//相位结束处理行人滞留问题
			//待定相位
			roadbit = 0;
			isperdelay	= 0;
			i =0;
			rcnum = 0;
			lcnum = 0;

			if((currenttime - receiveroadtime) > 2)
			{
				roaddata = 0;
			}

			
			memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
			memset(allchannel,0,sizeof(allchannel));
			memset(pinfo->roaddelaychan,0,sizeof(pinfo->roaddelaychan));
			for(roadbit = 4;roadbit < 12; roadbit++)
			{
				if((roaddata >> roadbit) & 0x00000001)
				{
						if(8==roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(13 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}
							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit+1;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("pend phase weizhi 9\n");
							#endif
						}
						else if(9 == roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(16 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}
							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit +1;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("pend phase weizhi 10\n");
							#endif
						}
						else if(10 == roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(15 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}

							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit +1;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("pend phase  weizhi 11\n");
							#endif
						}
						else if(11 == roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(14 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}
							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit +1;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("pend phase weizhi 12\n");
							#endif
						}
	
				}
			}
			
			if(1 == isperdelay)
			{
				reporttoedger(*(dcdata->fd->sockfd->edgersockd),pinfo->roadbit);
				isperdelay = 0;	
				roadreport[0] = 0x21;
				roadreport[1] = 0x85;
				roadreport[2] = 0xFB;
				roadreport[3] = 0x00;
				roadreport[4] = 0x00;
				roadreport[5] = 0x00;
				roadreport[6] = 0x00;
				roadreport[7] = 0x00;
				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->roadbit[i])
					{
						break;
					}
					if( 9 == pinfo->roadbit[i])
					{
						roadreport[6] |= 0x01;
						roadreport[7] |= 0x00;
					}
					else if(10== pinfo->roadbit[i])
					{
						roadreport[6] |= 0x02;
						roadreport[7] |= 0x00;
					}
					else if(11== pinfo->roadbit[i])
					{
						roadreport[6] |= 0x04;
						roadreport[7] |= 0x00;
					}
					else if(12== pinfo->roadbit[i])
					{
						roadreport[6] |= 0x08;
						roadreport[7] |= 0x00;
					}
							
				}
				write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
				#ifdef ROADINFO_DEBUG
				printf("delaye phase roadreport:");
				for(i=0;i<sizeof(roadreport);i++)
				{
					printf("%02x ",roadreport[i]);
				}
				printf("\n");
				#endif
				z = 0;		
 				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->chan[i])
					{
						break;
					}
					if(13 == pinfo->chan[i])
					{

						continue;
					}
					if(14 == pinfo->chan[i])
					{
						continue;
					}
					if(15 == pinfo->chan[i])
					{
						continue;
					}
					if(16 == pinfo->chan[i])
					{
						continue;
					}
					pinfo->roaddelaychan[z] = pinfo->chan[i];
					z++;
										
				}

				//行人清空黄灯处理
				/*if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),personchannelred,0x00))
				{
		#ifdef ROADINFO_DEBUG
					printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
			#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
					}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,personchannelred,0x00, \
																	dcdata->fd->markbit))
				{
		#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
				}


				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->roaddelaychan,0x01))
				{
		#ifdef ROADINFO_DEBUG
					printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
			#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
			#endif
					}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->roaddelaychan,0x01, \
																	dcdata->fd->markbit))
				{
		#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
		#endif
				}



				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					
					sinfo.color = 0x06;
					sinfo.time = 3;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
					memset(sinfo.csta,0,sizeof(sinfo.csta));
					csta = sinfo.csta;
					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == personchannelred[i])
							break;
						sinfo.chans += 1;
						tcsta = personchannelred[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x00;
						*csta = tcsta;
						csta++;
					}

					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == pinfo->roaddelaychan[i])
							break;
						sinfo.chans += 1;
						tcsta = pinfo->roaddelaychan[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x01;
						*csta = tcsta;
						csta++;
					}
					
					
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
					if (SUCCESS != status_info_report(sibuf,&sinfo))
					{
				#ifdef ROADINFO_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					}
					else
					{
						write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
					}
				}
				
				sleep(3);
				20221102 edit 取消这里三秒黄灯
				*/
				//黄灯结束，红灯开始
				unsigned char notrightchanngle[MAX_CHANNEL]={0};
				z =0;
				rcnum = 0;
				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->roaddelaychan[i])
					{
						break;
					}
					if(9 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(9 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 9;
								rcnum++;
								break;
							}
						}
						continue;
					}
					else if(10 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(10 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 10;
								rcnum++;
								break;
							}
						}
						continue;
					}
					else if(11 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(11 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 11;
								rcnum++;
								break;
							}
						}

						continue;
					}
					else if(12 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(12 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 12;
								rcnum++;
								break;
							}
						}						
						continue;
					}
					else
					{
						notrightchanngle[rcnum] = pinfo->roaddelaychan[i];
						rcnum++;
					}
					
										
				}
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),notrightchanngle,0x00))
				{
					#ifdef ROADINFO_DEBUG
					printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
						#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
					}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,notrightchanngle,0x00, \
																	dcdata->fd->markbit))
				{
					#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
				}
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					
					sinfo.color = 0x00;
					sinfo.time = 3;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
					memset(sinfo.csta,0,sizeof(sinfo.csta));
					csta = sinfo.csta;
					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == notrightchanngle[i])
							break;
						sinfo.chans += 1;
						tcsta = notrightchanngle[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x00;
						*csta = tcsta;
						csta++;
					}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
					if (SUCCESS != status_info_report(sibuf,&sinfo))
					{
							#ifdef ROADINFO_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
					}
					else
					{
						write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
					}
				}

				sleep(3);
				roadreport[4] = 0xff;
				roadreport[5] = 0xff;
				roadreport[6] = 0xff;
				roadreport[7] = 0xff;
				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->roadbit[i])
					{
						break;
					}
					if( 9 == pinfo->roadbit[i])
					{
						roadreport[7] = 0xff;
						roadreport[6] = 0xfe;
					}
					else if(10== pinfo->roadbit[i])
					{
						roadreport[6] &= 0xfd;
						roadreport[7] &= 0xff;
					}
					else if(11== pinfo->roadbit[i])
					{
						roadreport[6] &= 0xfb;
						roadreport[7] &= 0xff;
					}
					else if(12== pinfo->roadbit[i])
					{
						roadreport[6] &= 0xf7;
						roadreport[7] &=  0xff;
					}
							
				}
				write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
				*(dcdata->fd->roadinfo) = 0;
				#ifdef ROADINFO_DEBUG
				printf("end delaye pending phase roadreport:");
				for(i=0;i<sizeof(roadreport);i++)
				{
					printf("%02x ",roadreport[i]);
				}
				printf("\n");
				#endif
			}

			//相位结束处理行人滞留问题
			isreport = 0;
			memcpy(lastphasechannel,pinfo->chan,sizeof(lastphasechannel));

			//待定相位
			ni += 1;//20220621
				slnum += 1;
				*(dcdata->fd->slnum) = slnum;
				*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
				if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
				{
					cycarr = 1;
					slnum = 0;
					*(dcdata->fd->slnum) = 0;
					*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
				}
				#ifdef RED_FLASH
				if (rft > (pinfo->ytime + pinfo->rtime))
				{
					sleep(rft - (pinfo->ytime) - (pinfo->rtime));
				}
				#endif
				if (1 == phcon)
            	{
					*(dcdata->fd->markbit) &= 0xfbff;
                	memset(&gtime,0,sizeof(gtime));
                	gettimeofday(&gtime,NULL);
                	memset(&gftime,0,sizeof(gftime));
                	memset(&ytime,0,sizeof(ytime));
                	memset(&rtime,0,sizeof(rtime));
                	phcon = 0;
                	sleep(10);
            	}
				continue;
			}//the pending phase will be passed
			else
			{//the pending phase will be ignored
				#ifdef FULL_DETECT_DEBUG
            	printf("Ignore pass pending phase,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
				slnum += 1;
				*(dcdata->fd->slnum) = slnum;
				*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
				if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
				{
					cycarr = 1;
					slnum = 0;
					*(dcdata->fd->slnum) = 0;
					*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
				}
				if (1 == phcon)
            	{
					*(dcdata->fd->markbit) &= 0xfbff;
                	memset(&gtime,0,sizeof(gtime));
                	gettimeofday(&gtime,NULL);
                	memset(&gftime,0,sizeof(gftime));
                	memset(&ytime,0,sizeof(ytime));
                	memset(&rtime,0,sizeof(rtime));
                	phcon = 0;
                	sleep(10);
            	}
				continue;
			}//the pending phase will be ignored
		}//pending phase
		else
		{//other type phases, for example,flexible phase/其他相位
			#ifdef FULL_DETECT_DEBUG
            printf("Begin to pass other type phase,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
			roaddata = *(dcdata->fd->roadinfo);
			unsigned char personchannelnum = 0;
			unsigned char rcnum = 0,lcnum = 0,z =0,flag = 0;
			unsigned char allchannel[MAX_CHANNEL];
			roadbit = 0;
			isreport = 0;
			memset(pinfo->roaddelaychan,0,sizeof(pinfo->roaddelaychan));
			memset(pinfo->persionroadbit,0,sizeof(pinfo->persionroadbit));
			memset(allchannel,0,sizeof(allchannel));
			memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
			memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
			
			#ifdef FULL_DETECT_DEBUG
            printf("***************other roaddata: %d,File: %s,Line: %d\n",roaddata,__FILE__,__LINE__);
            #endif
			*(dcdata->fd->color) = 0x02;
			*(dcdata->fd->markbit) &= 0xfbff;

			gettimeofday(&ct,NULL);
			currenttime = ct.tv_sec;
			adaptd.phi[ni].phasestarttime = ct.tv_sec;
			receiveroadtime =  *(dcdata->fd->roadinforeceivetime);
			if((currenttime - receiveroadtime) >4)
			{
				roaddata = 0;
			}
			else
			{
				roaddata = *(dcdata->fd->roadinfo);
			}
			//相位开始行人等待处理 
			for(roadbit = 0;roadbit < 4; roadbit++)
			{
				if((roaddata >> roadbit) & 0x00000001)
				{
					//if(1 == pinfo->cpcexist)
					//{
						if(0 ==roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(pinfo->chan[personchannelnum] == 13)
								{
									flag = 1;
									break;
								}
																
							}

							if(0 == flag)
							{
								continue;
							}
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(12 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 12;
									pinfo->persionroadbit[lcnum] = roadbit +1;
									break;
								}
																
							}
								
							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
            				printf("location is 1,File: %s,Line: %d\n",__FILE__,__LINE__);
           					#endif
						}
						else if(1 == roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(16 == pinfo->chan[personchannelnum])
								{
									flag = 1;
									break;
								}
																
							}
							if(0 == flag)
							{
								continue;
							}
					
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(11 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 11;
									pinfo->persionroadbit[lcnum] = roadbit +1;
									break;
								}
																
							}
								

							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
            				printf("location is 2,File: %s,Line: %d\n",__FILE__,__LINE__);
           					#endif
						}
						else if(2 == roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(pinfo->chan[personchannelnum] == 15)
								{
									flag = 1;
									break;

								}
																
							}
							if(0 == flag)
							{
								continue;
							}

							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(10 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 10;	
									pinfo->persionroadbit[lcnum] = roadbit+1;
								}
																
							}
								
							
							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
	    					printf("location is 3,File: %s,Line: %d\n",__FILE__,__LINE__);
	   						#endif
						}
						else if(3 == roadbit)
						{
							unsigned char flag = 0;
							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}
								if(14 == pinfo->chan[personchannelnum])
								{
									flag = 1;
									break;
								}																
							}
							if(0 == flag)
							{
								continue;
							}

							for(personchannelnum = 0;personchannelnum < MAX_CHANNEL;personchannelnum++)
							{
								if(0 == pinfo->chan[personchannelnum])
								{
									break;
								}							
								if(9 == pinfo->chan[personchannelnum])
								{
									allchannel[rcnum] = 9;	
									pinfo->persionroadbit[lcnum] = roadbit+1;
								}
																
							}

							rcnum ++;
							lcnum ++;
							#ifdef ROADINFO_DEBUG
    						printf("location is 4,File: %s,Line: %d\n",__FILE__,__LINE__);
   							#endif							
						}			
					//}
						
				}
			}
			if( 0 != allchannel[0])
			{
				flag = 1;
				z = 0;
				for(i = 0; i<MAX_CHANNEL;i++)
				{	
					if(0 == allchannel[i])
					{
						break;
					} 
					for(roadbit = 0;roadbit<i;roadbit++)
					{
						if(allchannel[i] == allchannel[roadbit])
						{
							flag = 0;
						}
					}
					if(flag)
					{
						pinfo->roaddelaychan[z] = allchannel[i];
						z++;
					}
					flag = 1;	
				}

				if(0 == delaypcyes)
				{
					int dcret = pthread_create(&delaypcpid,NULL,(void *)ms_delay_right_channel,dcdata);
					if (0 != dcret)
					{
						#ifdef ROADINFO_DEBUG
            			printf("create pthread ms_delay_right_channel eeeor,File: %s,Line: %d\n",__FILE__,__LINE__);
           				#endif
						return;
					}
					#ifdef ROADINFO_DEBUG
            		printf("create pthread ms_delay_right_channel,File: %s,Line: %d\n",__FILE__,__LINE__);
           			#endif
					delaypcyes = 1;
				}
			}
			if(0 == pinfo->roaddelaychan[0])
			{
				//unsigned char  notchangletoyellow[MAX_CHANNEL];
				if(0 != currentquenuechannel[0])
				{
					unsigned char q,w,e = 0,flag = 1;
					//memset(notchangletoyellow,0,sizeof(notchangletoyellow));
					for(q = 0;q<MAX_CHANNEL;q++)
					{
						if(0 == pinfo->chan[q])
						{
							break;
						}
						for(w = 0;w<MAX_CHANNEL;w++)
						{
							if(0 == currentquenuechannel[w])
							{
								break;
							}
							if(pinfo->chan[q] != currentquenuechannel[w])
							{
								flag = 0;
								break;
							}
						}
						if(0 == flag)
						{
							yellowtoredchannel[e] = pinfo->chan[q];
							e++;
						}
						flag = 1;
					}
				}
				else
				{
					//memset(notchangletoyellow,0,sizeof(notchangletoyellow));
					memcpy(yellowtoredchannel,pinfo->chan,sizeof(yellowtoredchannel));
				}
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),yellowtoredchannel,0x02))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					gettimeofday(&ct,NULL);
		            update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
		            if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
		            {
		            #ifdef FULL_DETECT_DEBUG
		                printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
		            #endif
		            }
					*(dcdata->fd->markbit) |= 0x0800;
				}
			}
			#ifdef CHANNEL_YELLOW_FLASH
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{		
				if (pinfo->phaseid	== dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel yellow flash
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime -1;//for thread exit
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;
				int yfarg = pthread_create(&yfcpid,NULL,(void *)ms_channel_yellow_flash,&cyft);
				if (0 != yfarg)
				{
				#ifdef TIMING_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
				else
				{//create channel yellow flash thread success;
				#ifdef TIMING_DEBUG
					printf("Create channel yellow flash thread success,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					{//actively report is not probitted and connect successfully
						sinfo.time = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime - 1;
						sinfo.conmode = *(dcdata->fd->contmode);
						sinfo.color = 0x05;//yellow flash
						sinfo.chans = 0;
						memset(sinfo.csta,0,sizeof(sinfo.csta));
						csta = sinfo.csta;
						for (i = 0; i < YFCHANNEL; i++)
						{
							if (0 == cyfc[i])
								break;
							sinfo.chans += 1;
							tcsta = cyfc[i];
							tcsta <<= 2;
							tcsta &= 0xfc;
							tcsta |= 0x00;
							*csta = tcsta;
							csta++;
						}
						memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
						memset(sibuf,0,sizeof(sibuf));
						if (SUCCESS != status_info_report(sibuf,&sinfo))	
						{
						#ifdef TIMING_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
						else
						{
							write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
						}
					}//actively report is not probitted and connect successfully
				}//create channel yellow flash thread success;
			}//exist channel yellow flash
			#endif

			#ifdef CHANNEL_CLOSE
			cyfn = 0;
			cyfe = 0;
			for (cyfn = 0; cyfn < dcdata->td->phaseerror->FactPhaseErrorNum; cyfn++)
			{
				if (pinfo->phaseid  == dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseId)
				{
					cyfe = /*0xfffe1fff &*/ dcdata->td->phaseerror->PhaseErrorList[cyfn].PhaseConflict;
					break;
				}
			}
			memset(cyfc,0,sizeof(cyfc));
			pcyfc = cyfc;
			if (cyfe > 0)
			{//exist channel close lamp
				for (cyfn = 0; cyfn < YFCHANNEL; cyfn++)
				{
					if (cyfe & (0x01 << cyfn))
					{
						*pcyfc = cyfn + 1;
						pcyfc++;
					}
				}
				cyft.cyft = pinfo->gtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
				cyft.chan = cyfc;
				cyft.dc = dcdata;
				cyft.mark = 1;

				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),cyfc,0x03))
				{
				#ifdef TIMING_DEBUG
					printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,cyfc,0x03,dcdata->fd->markbit))
				{
				#ifdef TIMING_DEBUG
					printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				}
				channel_close_begin_report(dcdata->fd->sockfd->csockfd,cyfc);	
			}//exist channel close lamp
			#endif
			if(0 == pinfo->roaddelaychan[0])
			{

//				unsigned char  notchangletoyellow[MAX_CHANNEL];
//				if(0 != currentquenuechannel[0])
//				{
//					unsigned char q,w,e = 0,flag = 0;
//					memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//					for(q = 0;q<MAX_CHANNEL;q++)
//					{
//						if(0 == pinfo->chan[q])
//						{
//							break;
//						}
//						for(w = 0;w<MAX_CHANNEL;w++)
//						{
//							if(0 == currentquenuechannel[w])
//							{
//								break;
//							}
//							if(pinfo->chan[q] == currentquenuechannel[w])
//							{
//								flag = 0;
//								break;
//							}
//							flag = 1;
//						}
//						if(flag)
//						{
//							notchangletoyellow[e] = pinfo->chan[q];
//							e++;
//						}
//						flag = 0;
//					}
//				}
//				else
//				{
//					memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//					memcpy(notchangletoyellow,pinfo->chan,sizeof(notchangletoyellow));
//				}
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x02, \
		                                                dcdata->fd->markbit))
		        {
		        #ifdef FULL_DETECT_DEBUG
		            printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
		        #endif
		        }
			}
			#ifdef V2X_DEBUG
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//if ((30 != *(sadata->fd->contmode)) && (31 != *(sadata->fd->contmode)))
					*(dcdata->fd->v2xmark) &= 0xfe;//V2X
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->chan[j])
							break;
						if ((pinfo->chan[j] < 13) || (pinfo->chan[j] > 16))
						{
							dcdata->fd->slg[(pinfo->chan[j])-1].slgid = pinfo->chan[j];
							dcdata->fd->slg[(pinfo->chan[j])-1].slgstatus= 0x17;
							dcdata->fd->slg[(pinfo->chan[j])-1].countdown = 0xff;
							dcdata->fd->slg[(pinfo->chan[j])-1].nslgstatus = 0x16;

							dcdata->fd->slg[(pinfo->chan[j])-1].greent = 0;//pinfo->gtime + pinfo->gftime;
							dcdata->fd->slg[(pinfo->chan[j])-1].yellowt = 0;//pinfo->ytime;
							dcdata->fd->slg[(pinfo->chan[j])-1].redt = 0;//pinfo->rtime;
							dcdata->fd->slg[(pinfo->chan[j])-1].allrt = 0;
						}
					}
				}////if ((30 != *(sadata->fd->contmode)) && (31 != *(sadata->fd->contmode)))
			}//if (*(dcdata->fd->auxfunc) & 0x01)
			#endif
	
			if (0 == pinfo->cchan[0] && 0 == pinfo->roaddelaychan[0])
			{	
				#ifdef ROADINFO_DEBUG
	            printf("current pinfo->roaddelaychan is 0:,File: %s,Line: %d\n",__FILE__,__LINE__);
	            #endif
//				unsigned char  notchangletoyellow[MAX_CHANNEL];
//				if(0 != currentquenuechannel[0])
//				{
//					unsigned char q,w,e = 0,flag = 0;
//					memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//					for(q = 0;q<MAX_CHANNEL;q++)
//					{
//						if(0 == pinfo->chan[q])
//						{
//							break;
//						}
//						for(w = 0;w<MAX_CHANNEL;w++)
//						{
//							if(0 == currentquenuechannel[w])
//							{
//								break;
//							}
//							if(pinfo->chan[q] == currentquenuechannel[w])
//							{
//								flag = 0;
//								break;
//							}
//							flag = 1;
//						}
//						if(flag)
//						{
//							notchangletoyellow[e] = pinfo->chan[q];
//							e++;
//						}
//						flag = 0;
//					}
//				}

//				else
//				{
//					memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//					memcpy(notchangletoyellow,pinfo->chan,sizeof(notchangletoyellow));
//				}
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->mingtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;	
			//		#ifdef FULL_DOWN_TIME
					if (*(dcdata->fd->auxfunc) & 0x01)
						sinfo.time += *(dcdata->fd->halfdownt);
			//		#endif
					sinfo.color = 0x02;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
           			memset(sinfo.csta,0,sizeof(sinfo.csta));
           			csta = sinfo.csta;      
					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == yellowtoredchannel[i])
							break;
						sinfo.chans += 1;
						tcsta = yellowtoredchannel[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x02;
						*csta = tcsta;
						csta++;
					}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
               			printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
               			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}		
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
			else if(0 != pinfo->cchan[0] && 0 == pinfo->roaddelaychan[0])
			{

//				unsigned char  notchangletoyellow[MAX_CHANNEL];
//				if(0 != currentquenuechannel[0])
//				{
//					unsigned char q,w,e = 0,flag = 0;
//					memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//					for(q = 0;q<MAX_CHANNEL;q++)
//					{
//						if(0 == pinfo->chan[q])
//						{
//							break;
//						}
//						for(w = 0;w<MAX_CHANNEL;w++)
//						{
//							if(0 == currentquenuechannel[w])
//							{
//								break;
//							}
//							if(pinfo->chan[q] == currentquenuechannel[w])
//							{
//								flag = 0;
//								break;
//							}
//							flag = 1;
//						}
//						if(flag)
//						{
//							notchangletoyellow[e] = pinfo->chan[q];
//							e++;
//						}
//						flag = 0;
//					}
//				}
//				else
//				{
//					memset(notchangletoyellow,0,sizeof(notchangletoyellow));
//					memcpy(notchangletoyellow,pinfo->chan,sizeof(notchangletoyellow));
//				}
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->mingtime + pinfo->gftime;	
					if (*(dcdata->fd->auxfunc) & 0x01)
                        sinfo.time += *(dcdata->fd->halfdownt);
					sinfo.color = 0x02;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
           			memset(sinfo.csta,0,sizeof(sinfo.csta));
           			csta = sinfo.csta;
					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == yellowtoredchannel[i])
							break;
						sinfo.chans += 1;
						tcsta = yellowtoredchannel[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x02;
						*csta = tcsta;
						csta++;
					}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
            		memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
               			printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
               			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}		
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			memset(&gtime,0,sizeof(gtime));
			gettimeofday(&gtime,NULL);
            memset(&gftime,0,sizeof(gftime));
            memset(&ytime,0,sizeof(ytime));
            memset(&rtime,0,sizeof(rtime));
		
			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x02;
                timedown.lamptime = pinfo->mingtime + pinfo->gftime;
			//	#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
					timedown.lamptime += *(dcdata->fd->halfdownt);
			//	#endif
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
			#ifdef EMBED_CONFIGURE_TOOL
            if (*(dcdata->fd->markbit2) & 0x0200)
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x02;
                timedown.lamptime = pinfo->mingtime + pinfo->gftime;
            //  #ifdef FULL_DOWN_TIME
                if (*(dcdata->fd->auxfunc) & 0x01)
                    timedown.lamptime += *(dcdata->fd->halfdownt);
            //  #endif
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
            #endif

			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
            	fbdata[3] = 0x02;
            	fbdata[4] = pinfo->mingtime + pinfo->gftime;
			//	#ifdef FULL_DOWN_TIME
				if (*(dcdata->fd->auxfunc) & 0x01)
					fbdata[4] += *(dcdata->fd->halfdownt);
			//	#endif
			}
            if (!wait_write_serial(*(dcdata->fd->fbserial)))
            {
                if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					*(dcdata->fd->markbit) |= 0x0800;
                    gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
            }
            else
            {
            #ifdef FULL_DETECT_DEBUG
                printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			sendfaceInfoToBoard(dcdata->fd,fbdata);
			memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
			while (1)
    		{
        		memset(buf,0,sizeof(buf));
        		if (read(*(dcdata->fd->flowpipe),buf,sizeof(buf)) <= 0)
            		break;
    		}
			if (1 == (pinfo->cpcexist))
			{//have person channels
		//		sleep((pinfo->mingtime) - (pinfo->pdelay));
				sltime = pinfo->mingtime - pinfo->ldeti;
				ffw = 0;
				int max = 0;
				//memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
				unsigned char receivetime = 0;
				while (1)	
				{
					FD_ZERO(&nRead);
					FD_SET(*(dcdata->fd->ffpipe),&nRead);
					FD_SET(*(dcdata->fd->flowpipe),&nRead);
					lasttime.tv_sec = 0;
					lasttime.tv_usec = 0;
					gettimeofday(&lasttime,NULL);
					bakv = sltime;
					mtime.tv_sec = sltime;
					mtime.tv_usec = 0;
					max = MAX(*(dcdata->fd->flowpipe),*(dcdata->fd->ffpipe));
					int mret = select(max+1,&nRead,NULL,NULL,&mtime);
					if (mret < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						break;
					}
					if (0 == mret)
					{
						break;
					}
					if (mret > 0)
					{
						if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
							if (!strncmp(buf,"fastforward",11))
							{
								ffw = 1;
								break;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
									sltime = bakv;
                        		continue;
							}
						}
						else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
							if((0xF4 == buf[0]) && (0xED == buf[len-1]))
							{
								
								memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
								memset(currentquenuelocation,0,sizeof(currentquenuelocation));
								
								unsigned char i =0,k =0,p =0,j=0,w =0;
								
								for (j = 0; j < 1; j++)
								{
									if((buf[3]>>j) & 0x01)
									{
										istrafficlock = 1; 
										#ifdef ROADINFO_DEBUG
										printf("lock location is 17,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
									}
									else
									{
										istrafficlock = 0;
										#ifdef ROADINFO_DEBUG
										//printf("no lock location,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
									}
								
								}
								if(1 == istrafficlock)
								{
									pthread_t   allredpid; 
									int dcret = pthread_create(&allredpid,NULL,(void *)ms_all_red,dcdata);
									if (0 != dcret)
									{
											#ifdef ROADINFO_DEBUG
											printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
											output_log("major_salve_detect_control,create major salve detect thread err");
											#endif
										return ;
									}
								}
								if(1 == istrafficlock)//交通死锁
								{
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
									#ifdef ROADINFO_DEBUG
									printf("jiao tong si suo wait jie chu: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									memset(lastquenuelocation,0,sizeof(lastquenuelocation));
									while(1)
									{
										FD_ZERO(&nRead);
										FD_SET(*(dcdata->fd->flowpipe),&nRead);
										int ret = select(*(dcdata->fd->flowpipe)+1,&nRead,NULL,NULL,NULL);
										if(ret > 0)
										{
											memset(buf,0,sizeof(buf));
											int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
											buf[len] = 0;
											if((0xF4 == buf[0]) && (0xED==buf[len-1])&& (0x01 == buf[3]))
											{
												#ifdef ROADINFO_DEBUG
												printf("continue wait : %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												continue;
											}
											else
											{
												#ifdef ROADINFO_DEBUG
												printf("si suo jie chu : %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												istrafficlock = 0;
												roadreport[0] = 0x21;
												roadreport[1] = 0x85;
												roadreport[2] = 0xFB;
												roadreport[3] = 0x00;
												roadreport[4] = 0xff;
												roadreport[5] = 0xfe; 
												roadreport[6] = 0xff;
												roadreport[7] = 0xff;
												write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
												#ifdef ROADINFO_DEBUG
												printf("send roaddata 1 :");
												for(k=0;k<8;k++)
												{
													printf("%02x ",roadreport[k]);
												}
												printf("\n");
												#endif
												if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
												{
													#ifdef ROADINFO_DEBUG
													printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
													#endif
													gettimeofday(&ct,NULL);
													update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
													if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																						dcdata->fd->softevent,dcdata->fd->markbit))
													{
															#ifdef ROADINFO_DEBUG
															printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
															#endif
													}
													*(dcdata->fd->markbit) |= 0x0800;
												}
												
												if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
																									dcdata->fd->markbit))
												{
													#ifdef ROADINFO_DEBUG
													printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
													#endif
												}
												if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
												{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
													
													sinfo.color = 0x02;
													sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
													sinfo.chans = 0;
													memset(sinfo.csta,0,sizeof(sinfo.csta));
													csta = sinfo.csta;
													for (i = 0; i < MAX_CHANNEL; i++)
													{
														if (0 == pinfo->chan[i])
															break;
														sinfo.chans += 1;
														tcsta = pinfo->chan[i];
														tcsta <<= 2;
														tcsta &= 0xfc;
														tcsta |= 0x02;
														*csta = tcsta;
														csta++;
													}
													memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
													memset(sibuf,0,sizeof(sibuf));
													if (SUCCESS != status_info_report(sibuf,&sinfo))
													{
															#ifdef ROADINFO_DEBUG
															printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
															#endif
													}
													else
													{
														write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
													}
												}				

												break;
											}
										}
										else
										{
											break;
										}
									}
									continue;
								}

								//排队溢出1

								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
									sltime = bakv;
								if(1 == isdelay && (buf[4]>>4 & 0x0f) == 0x00)
								{
									continue;
								}
								if(receivetime == 1)
								{
									if(0 == isreport && (buf[4]>>4 & 0x0f) == 0x00)
									{
										continue;
									}
								}
								receivetime = 1;
								#ifdef ROADINFO_DEBUG
								printf("receive  quenue data: %s,Line: %d\n",__FILE__,__LINE__);	
								#endif
								if(1 == isreport)
								{
									continue;
								}
								iscarquenueonerflow = 1;
								for(i=4;i<8;i++)
								{
									if((buf[4] >> i) & 0x01)
									{
										if(4 == i)
										{	
											pinfo->roadbit[p] = i;
											p++;
											w = 0;
											currentquenuelocation[0] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}
												if(2 == pinfo->chan[j])
												{
													pinfo->xiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(9 == pinfo->chan[j])
												{
												
													pinfo->xiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(7 == pinfo->chan[j])
												{
													pinfo->xiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}
											}
											pinfo->redchannel[k] = 2;
											k++;
											pinfo->redchannel[k] = 9;
											k++;
											pinfo->redchannel[k] = 7;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 13,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
										}
										else if(5 == i)
										{
											pinfo->roadbit[p] = i;
											p++;
											w =0;
											currentquenuelocation[1] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}
												if(12 == pinfo->chan[j])
												{
													pinfo->nanredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(1 == pinfo->chan[j])
												{
												
													pinfo->nanredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(6 == pinfo->chan[j])
												{
													pinfo->nanredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}

											}	
											pinfo->redchannel[k] = 12;
											k++;
											pinfo->redchannel[k] = 1;
											k++;
											pinfo->redchannel[k] = 6;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 14,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif

										}
										else if(6 == i)
										{
											pinfo->roadbit[p] = i;
											p++;
											w= 0;
											currentquenuelocation[2] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}
												if(5 == pinfo->chan[j])
												{
													pinfo->dongredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(4 == pinfo->chan[j])
												{
												
													pinfo->dongredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(11 == pinfo->chan[j])
												{
													pinfo->dongredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}										
											}
											pinfo->redchannel[k] = 5;
											k++;
											pinfo->redchannel[k] = 4;
											k++;
											pinfo->redchannel[k] = 11;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 15,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif

										}
										else if(7 == i)
										{
											pinfo->roadbit[p] = i;
											p++;
											w = 0;
											currentquenuelocation[3] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}	
												if(8== pinfo->chan[j])
												{
													pinfo->beiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(3== pinfo->chan[j])
												{
												
													pinfo->beiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(10 == pinfo->chan[j])
												{
													pinfo->beiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}

											}
											pinfo->redchannel[k] = 8;
											k++;
											pinfo->redchannel[k] = 3;
											k++;
											pinfo->redchannel[k] = 10;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 16,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif

										}			
									}
									else
									{
										continue;
									}
								}
								if(0 ==pinfo->redchannel[0])
								{
									iscarquenueonerflow = 0;
									
								}
								else
								{
									isreport = 1;
								}
								memcpy(currentquenuechannel,pinfo->redchannel,sizeof(currentquenuechannel));
								if(currentquenuelocation[0] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("xi fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[0])
									{
										lastquenuelocation[0] = 1;
										pthread_t    		xipid; 
										int dcret = pthread_create(&xipid,NULL,(void *)ms_phase_monitor_deal_xi,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_xi,create major salve detect thread err");
												#endif
											return ;
										}
									}
									
								}
								if(currentquenuelocation[1] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("nan fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[1])
									{
										lastquenuelocation[1] = 1;
										pthread_t    		nanpid; 
										int dcret = pthread_create(&nanpid,NULL,(void *)ms_phase_monitor_deal_nan,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_nan,create major salve detect thread err");
												#endif
											return ;
										}
									}
									
								}
								if(currentquenuelocation[2] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("dong fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[2])
									{
										lastquenuelocation[2] = 1;
										pthread_t    		dongpid; 
										int dcret = pthread_create(&dongpid,NULL,(void *)ms_phase_monitor_deal_dong,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_dong,create major salve detect thread err");
												#endif
											return ;
										}
									}	
									
								}
								if(currentquenuelocation[3] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("bei fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[3])
									{
										lastquenuelocation[3] = 1;
										pthread_t    		beipid; 
										int dcret = pthread_create(&beipid,NULL,(void *)ms_phase_monitor_deal_bei,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_bei,create major salve detect thread err");
												#endif
											return ;
										}
									}
									
								}
								roadreport[0] = 0x21;
								roadreport[1] = 0x85;
								roadreport[2] = 0xFB;
								roadreport[3] = 0x00;
								roadreport[4] = 0xff;
								roadreport[5] = 0xff;
								roadreport[6] = 0xff;
								roadreport[7] = 0xff;
								unsigned char jiechuchannel[MAX_CHANNEL] = {0};
								unsigned char q= 0,e = 0,flag = 0;
								if(currentquenuelocation[0] == 0 && lastquenuelocation[0] == 1)
								{
									roadreport[6]  &=  0xef;
									flag = 0;
									lastquenuelocation[0] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/*if( 2== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 9== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 7== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}*/
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}
								if(currentquenuelocation[1] == 0 && lastquenuelocation[1] == 1)
								{
									roadreport[6]  &=  0xdf;
									flag = 0;
									lastquenuelocation[1] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/*if( 12== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 1== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 6== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}*/
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}								
								if(currentquenuelocation[2] == 0 && lastquenuelocation[2] == 1)
								{
									roadreport[6]  &=  0xbf;
									flag = 0;
									lastquenuelocation[2] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/*if( 5== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 4== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 11== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}*/
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}								
								if(currentquenuelocation[3] == 0 && lastquenuelocation[3] == 1)
								{
									roadreport[6]  &=  0x7f;
									flag = 0;
									lastquenuelocation[3] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/*if( 3== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 10== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}*/
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}
								if(jiechuchannel[0] != 0)
								{
									iscarquenueonerflow = 0;
								}
								if(currentquenuechannel[0] == 0)
								{
									memset(jiechuchannel,0,sizeof(jiechuchannel));
									memcpy(jiechuchannel,pinfo->chan,sizeof(jiechuchannel));
								}
								if(0 == iscarquenueonerflow)
								{	
									if(0xff == roadreport[6])
									{
										continue;
									}
									write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
									#ifdef ROADINFO_DEBUG
									printf("send jichu  report:");
									for(i=0;i<sizeof(roadreport);i++)
									{
										
										printf("%02x ",roadreport[i]);
									}
									printf("\n");
									#endif
									unsigned char greenchannel[MAX_CHANNEL]={0};
									if(0 != persiondelaychannel[0])
									{
										unsigned char q,w,e = 0,flag = 0;		
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == jiechuchannel[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == persiondelaychannel[w])
												{
													break;
												}
												if(jiechuchannel[q] == persiondelaychannel[w])
												{
													flag = 0;
													break;
												}
												flag = 1;
											}
											if(flag)
											{
												greenchannel[e] = jiechuchannel[q];
												e++;
											}
											flag = 0;
										}
									}
									else
									{
										memcpy(greenchannel,jiechuchannel,sizeof(greenchannel));
									}
									if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),greenchannel,0x02))
									{
										#ifdef ROADINFO_DEBUG
										printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										gettimeofday(&ct,NULL);
										update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
										if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																			dcdata->fd->softevent,dcdata->fd->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
												printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(dcdata->fd->markbit) |= 0x0800;
									}
									
									if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,greenchannel,0x02, \
										                                                dcdata->fd->markbit))
								    {
								    	#ifdef ROADINFO_DEBUG
								        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
								    	#endif
								    }
									if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
									{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
										
										sinfo.color = 0x02;
										sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
										sinfo.chans = 0;
										memset(sinfo.csta,0,sizeof(sinfo.csta));
										csta = sinfo.csta;
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == greenchannel[i])
												break;
											sinfo.chans += 1;
											tcsta = greenchannel[i];
											tcsta <<= 2;
											tcsta &= 0xfc;
											tcsta |= 0x02;
											*csta = tcsta;
											csta++;
										}
										memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
											#ifdef ROADINFO_DEBUG
												printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
										}
										else
										{
											write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}						
									memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));

								}
								continue;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
									sltime = bakv;
								continue;
							}
						}
						else
						{
							nowtime.tv_sec = 0;
							nowtime.tv_usec = 0;
							gettimeofday(&nowtime,NULL);
							leatime = nowtime.tv_sec - lasttime.tv_sec;
							sltime -= leatime;
							if (sltime > bakv)
								sltime = bakv;
							continue;
						}
					}//mret > 0
				}//while (1)

				if (0 == ffw)
				{
				#if 0
					//create thread to pass person channels
					if (0 == dcpcyes)
					{
						memset(&dpdata,0,sizeof(dpdata));
						dpdata.bbserial = dcdata->fd->bbserial;
						dpdata.pchan = pinfo->cpchan;
						dpdata.markbit = dcdata->fd->markbit;
						dpdata.sockfd = dcdata->fd->sockfd;
						dpdata.cs = dcdata->cs;
						dpdata.time = pinfo->pctime;
						int pcret = pthread_create(&dcpcid,NULL,(void *)ms_person_chan_greenflash,&dpdata);
						if (0 != pcret)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("Create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
							output_log("Detect control,create person greenflash thread err");
						#endif
							ms_end_part_child_thread();
							return;
						}
						dcpcyes = 1;
					}
				#endif
					if (0 == pinfo->cchan[0])
					{
						if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							sinfo.time = pinfo->ldeti + pinfo->gftime + pinfo->ytime + pinfo->rtime;	
						//	#ifdef FULL_DOWN_TIME
							if (*(dcdata->fd->auxfunc) & 0x01)
                    			sinfo.time += *(dcdata->fd->halfdownt);
                    	//	#endif
							sinfo.color = 0x02;
							sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
							for (i = 0; i < MAX_CHANNEL; i++)
            				{
               					if (0 == pinfo->cpchan[i])
               						break;
               					for (j = 0; j < sinfo.chans; j++)
               					{
               						if (0 == sinfo.csta[j])
                   						break;
               						tcsta = sinfo.csta[j];
               						tcsta &= 0xfc;
               						tcsta >>= 2;
               						tcsta &= 0x3f;
               						if (tcsta == pinfo->cpchan[i])
               						{
                   						sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x03;
										break;
               						}
               					}
            				}
							memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
            				if (SUCCESS != status_info_report(sibuf,&sinfo))
            				{
            				#ifdef FULL_DETECT_DEBUG
               					printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            				#endif
            				}
            				else
            				{
               					write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            				}	
						}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					}
					else
					{
						if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
						{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
							sinfo.time = pinfo->ldeti + pinfo->gftime;
							if (*(dcdata->fd->auxfunc) & 0x01)
                                sinfo.time += *(dcdata->fd->halfdownt);	
							sinfo.color = 0x02;
							sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
							for (i = 0; i < MAX_CHANNEL; i++)
            				{
               					if (0 == pinfo->cpchan[i])
               						break;
               					for (j = 0; j < sinfo.chans; j++)
               					{
               						if (0 == sinfo.csta[j])
                   						break;
               						tcsta = sinfo.csta[j];
               						tcsta &= 0xfc;
               						tcsta >>= 2;
               						tcsta &= 0x3f;
               						if (tcsta == pinfo->cpchan[i])
               						{
                   						sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x03;
										break;
               						}
               					}
            				}
							memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
            				if (SUCCESS != status_info_report(sibuf,&sinfo))
            				{
            				#ifdef FULL_DETECT_DEBUG
               					printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            				#endif
            				}
            				else
            				{
               					write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            				}	
						}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					}
				}//0 == ffw
			}//have person channels
			else
			{//not have person channels
		//		sleep((pinfo->mingtime) - (pinfo->pdelay));
				sltime = pinfo->mingtime - pinfo->ldeti;
				ffw = 0;
				int max = 0;
				//memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
				unsigned char receivetime = 0;
				while (1)	
				{
					FD_ZERO(&nRead);
					FD_SET(*(dcdata->fd->ffpipe),&nRead);
					FD_SET(*(dcdata->fd->flowpipe),&nRead);
					lasttime.tv_sec = 0;
					lasttime.tv_usec = 0;
					gettimeofday(&lasttime,NULL);
					bakv = sltime;
					mtime.tv_sec = sltime;
					mtime.tv_usec = 0;
					max = MAX(*(dcdata->fd->flowpipe),*(dcdata->fd->ffpipe));
					int mret = select(max+1,&nRead,NULL,NULL,&mtime);
					if (mret < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						break;
					}
					if (0 == mret)
					{
						break;
					}
					if (mret > 0)
					{
						if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
							if (!strncmp(buf,"fastforward",11))
							{
								ffw = 1;
								break;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
									sltime = bakv;
                        		continue;
							}
						}						
						else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
						{
							memset(buf,0,sizeof(buf));
							int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
							if((0xF4 == buf[0]) && (0xED == buf[len-1]))
							{

								memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
								memset(currentquenuelocation,0,sizeof(currentquenuelocation));
								
								unsigned char i =0,k =0,p =0,j=0,w =0;
								
								for (j = 0; j < 1; j++)
								{
									if((buf[3]>>j) & 0x01)
									{
										istrafficlock = 1; 
										#ifdef ROADINFO_DEBUG
										printf("lock location is 17,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
									}
									else
									{
										istrafficlock = 0;
										#ifdef ROADINFO_DEBUG
										//printf("no lock location,File: %s,Line: %d\n",__FILE__,__LINE__);	
										#endif
									}
								
								}
								if(1 == istrafficlock)
								{
									pthread_t   allredpid; 
									int dcret = pthread_create(&allredpid,NULL,(void *)ms_all_red,dcdata);
									if (0 != dcret)
									{
											#ifdef ROADINFO_DEBUG
											printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
											output_log("major_salve_detect_control,create major salve detect thread err");
											#endif
										return ;
									}
								}
								if(1 == istrafficlock)//交通死锁
								{
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									sltime -= leatime;
									if (sltime > bakv)
										sltime = bakv;
									#ifdef ROADINFO_DEBUG
									printf("jiao tong si suo wait jie chu: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									memset(lastquenuelocation,0,sizeof(lastquenuelocation));
									while(1)
									{
										FD_ZERO(&nRead);
										FD_SET(*(dcdata->fd->flowpipe),&nRead);
										int ret = select(*(dcdata->fd->flowpipe)+1,&nRead,NULL,NULL,NULL);
										if(ret > 0)
										{
											memset(buf,0,sizeof(buf));
											int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
											buf[len] = 0;
											if((0xF4 == buf[0]) && (0xED==buf[len-1])&& (0x01 == buf[3]))
											{
												#ifdef ROADINFO_DEBUG
												printf("continue wait : %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												continue;
											}
											else
											{
												#ifdef ROADINFO_DEBUG
												printf("si suo jie chu : %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
												istrafficlock = 0;
												roadreport[0] = 0x21;
												roadreport[1] = 0x85;
												roadreport[2] = 0xFB;
												roadreport[3] = 0x00;
												roadreport[4] = 0xff;
												roadreport[5] = 0xfe; 
												roadreport[6] = 0xff;
												roadreport[7] = 0xff;
												write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
												#ifdef ROADINFO_DEBUG
												printf("send roaddata 1 :");
												for(k=0;k<8;k++)
												{
													printf("%02x ",roadreport[k]);
												}
												printf("\n");
												#endif
												if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
												{
													#ifdef ROADINFO_DEBUG
													printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
													#endif
													gettimeofday(&ct,NULL);
													update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
													if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																						dcdata->fd->softevent,dcdata->fd->markbit))
													{
															#ifdef ROADINFO_DEBUG
															printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
															#endif
													}
													*(dcdata->fd->markbit) |= 0x0800;
												}
												
												if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
																									dcdata->fd->markbit))
												{
													#ifdef ROADINFO_DEBUG
													printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
													#endif
												}
												if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
												{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
													
													sinfo.color = 0x02;
													sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
													sinfo.chans = 0;
													memset(sinfo.csta,0,sizeof(sinfo.csta));
													csta = sinfo.csta;
													for (i = 0; i < MAX_CHANNEL; i++)
													{
														if (0 == pinfo->chan[i])
															break;
														sinfo.chans += 1;
														tcsta = pinfo->chan[i];
														tcsta <<= 2;
														tcsta &= 0xfc;
														tcsta |= 0x02;
														*csta = tcsta;
														csta++;
													}
													memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
													memset(sibuf,0,sizeof(sibuf));
													if (SUCCESS != status_info_report(sibuf,&sinfo))
													{
															#ifdef ROADINFO_DEBUG
															printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
															#endif
													}
													else
													{
														write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
													}
												}				

												break;
											}
										}
										else
										{
											break;
										}
									}
									continue;
								}


								//排队溢出2
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
									sltime = bakv;

								if(1 == isdelay && (buf[4]>>4 & 0x0f) == 0x00)
								{
									continue;
								}
								if(receivetime == 1)
								{
									if(0 == isreport && (buf[4]>>4 & 0x0f) == 0x00)
									{
										continue;
									}
								}
								receivetime = 1;
								#ifdef ROADINFO_DEBUG
								printf("receive  quenue data: %s,Line: %d\n",__FILE__,__LINE__);	
								#endif
								if(1 == isreport)
								{
									continue;
								}
								iscarquenueonerflow = 1;
								for(i=4;i<8;i++)
								{
									if((buf[4] >> i) & 0x01)
									{
										if(4 == i)
										{	
											pinfo->roadbit[p] = i;
											p++;
											w = 0;
											currentquenuelocation[0] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}
												if(2 == pinfo->chan[j])
												{
													pinfo->xiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(9 == pinfo->chan[j])
												{
												
													pinfo->xiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(7 == pinfo->chan[j])
												{
													pinfo->xiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}
											}
											pinfo->redchannel[k] = 2;
											k++;
											pinfo->redchannel[k] = 9;
											k++;
											pinfo->redchannel[k] = 7;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 13,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
										}
										else if(5 == i)
										{
											pinfo->roadbit[p] = i;
											p++;
											w =0;
											currentquenuelocation[1] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}
												if(12 == pinfo->chan[j])
												{
													pinfo->nanredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(1 == pinfo->chan[j])
												{
												
													pinfo->nanredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(6 == pinfo->chan[j])
												{
													pinfo->nanredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}

											}
											pinfo->redchannel[k] = 12;
											k++;
											pinfo->redchannel[k] = 1;
											k++;
											pinfo->redchannel[k] = 6;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 14,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif

										}
										else if(6 == i)
										{
											pinfo->roadbit[p] = i;
											p++;
											w= 0;
											currentquenuelocation[2] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}
												if(5 == pinfo->chan[j])
												{
													pinfo->dongredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(4 == pinfo->chan[j])
												{
												
													pinfo->dongredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(11 == pinfo->chan[j])
												{
													pinfo->dongredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}										
											}
											pinfo->redchannel[k] = 5;
											k++;
											pinfo->redchannel[k] = 4;
											k++;
											pinfo->redchannel[k] = 11;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 15,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif

										}
										else if(7 == i)
										{
											pinfo->roadbit[p] = i;
											p++;
											w = 0;
											currentquenuelocation[3] = 1;
											for(j = 0;j < MAX_CHANNEL;j++)
											{
												if(0 == pinfo->chan[j])
												{
													break;
												}	
												if(8== pinfo->chan[j])
												{
													pinfo->beiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(3== pinfo->chan[j])
												{
												
													pinfo->beiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;
												}
												if(10 == pinfo->chan[j])
												{
													pinfo->beiredchannel[w] = pinfo->chan[j];
													//pinfo->redchannel[k] = pinfo->chan[j];
													//k++;
													w++;											
												}

											}
											pinfo->redchannel[k] = 8;
											k++;
											pinfo->redchannel[k] = 3;
											k++;
											pinfo->redchannel[k] = 10;
											k++;
											#ifdef ROADINFO_DEBUG
											printf("quenue location is 16,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif

										}
									}
									else
									{
										continue;
									}
								}
								if(0 ==pinfo->redchannel[0])
								{
									iscarquenueonerflow = 0;
								}
								else
								{
									isreport = 1;
								}
								memcpy(currentquenuechannel,pinfo->redchannel,sizeof(currentquenuechannel));
								if(currentquenuelocation[0] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("xi fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[0])
									{
										lastquenuelocation[0] = 1;
										pthread_t    		xipid; 
										int dcret = pthread_create(&xipid,NULL,(void *)ms_phase_monitor_deal_xi,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_xi,create major salve detect thread err");
												#endif
											return ;
										}
									}
									
								}
								if(currentquenuelocation[1] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("nan fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[1])
									{
										lastquenuelocation[1] = 1;
										pthread_t    		nanpid; 
										int dcret = pthread_create(&nanpid,NULL,(void *)ms_phase_monitor_deal_nan,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_nan,create major salve detect thread err");
												#endif
											return ;
										}
									}
									
								}
								if(currentquenuelocation[2] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("dong fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[2])
									{
										lastquenuelocation[2] = 1;
										pthread_t    		dongpid; 
										int dcret = pthread_create(&dongpid,NULL,(void *)ms_phase_monitor_deal_dong,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_dong,create major salve detect thread err");
												#endif
											return ;
										}
									}	
									
								}
								if(currentquenuelocation[3] == 1)
								{
									#ifdef ROADINFO_DEBUG
									printf("bei fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
									#endif
									if(1 != lastquenuelocation[3])
									{
										lastquenuelocation[3] = 1;
										pthread_t    		beipid; 
										int dcret = pthread_create(&beipid,NULL,(void *)ms_phase_monitor_deal_bei,dcdata);
										if (0 != dcret)
										{
												#ifdef ROADINFO_DEBUG
												printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("ms_phase_monitor_deal_bei,create major salve detect thread err");
												#endif
											return ;
										}
									}
									
								}
								roadreport[0] = 0x21;
								roadreport[1] = 0x85;
								roadreport[2] = 0xFB;
								roadreport[3] = 0x00;
								roadreport[4] = 0xff;
								roadreport[5] = 0xff;
								roadreport[6] = 0xff;
								roadreport[7] = 0xff;
								unsigned char jiechuchannel[MAX_CHANNEL] = {0};
								unsigned char q= 0,e = 0,flag = 0;
								if(currentquenuelocation[0] == 0 && lastquenuelocation[0] == 1)
								{
									roadreport[6]  &=  0xef;
									flag = 0;
									lastquenuelocation[0] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/*if( 2== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 9== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 7== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}*/
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}
								if(currentquenuelocation[1] == 0 && lastquenuelocation[1] == 1)
								{
									roadreport[6]  &=  0xdf;
									flag = 0;
									lastquenuelocation[1] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/*if( 12== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 1== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 6== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}*/
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}								
								if(currentquenuelocation[2] == 0 && lastquenuelocation[2] == 1)
								{
									roadreport[6]  &=  0xbf;
									flag = 0;
									lastquenuelocation[2] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/* if( 5== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 4== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 11== currentquenuechannel[w])
											{
												flag = 0;
												break;
											} */
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}								
								if(currentquenuelocation[3] == 0 && lastquenuelocation[3] == 1)
								{
									roadreport[6]  &=  0x7f;
									flag = 0;
									lastquenuelocation[3] = 0;
									for(q = 0;q<MAX_CHANNEL;q++)
									{
										if(0 == pinfo->chan[q])
										{
											break;
										}
										for(w = 0;w<MAX_CHANNEL;w++)
										{
											if(0 == currentquenuechannel[w])
											{
												break;
											}
											if( pinfo->chan[q]== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											/* if( 8== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 3== currentquenuechannel[w])
											{
												flag = 0;
												break;
											}
											if( 10== currentquenuechannel[w])
											{
												flag = 0;
												break;
											} */
											flag = 1;
										}
										if(flag)
										{
											jiechuchannel[e] = pinfo->chan[q];
											e++;
										}
										flag = 0;
									}
								}
								if(jiechuchannel[0] != 0)
								{
									iscarquenueonerflow = 0;
								}
								if(currentquenuechannel[0] == 0)
								{
									memset(jiechuchannel,0,sizeof(jiechuchannel));
									memcpy(jiechuchannel,pinfo->chan,sizeof(jiechuchannel));
								}
								if(0 == iscarquenueonerflow)
								{	
									if(0xff == roadreport[6])
									{
										continue;
									}
									write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
									#ifdef ROADINFO_DEBUG
									printf("send jichu2  report:");
									for(i=0;i<sizeof(roadreport);i++)
									{
										
										printf("%02x ",roadreport[i]);
									}
									printf("jie chu channel\n");
									for(i=0;i<sizeof(jiechuchannel);i++)
									{
										if(0 == jiechuchannel[i])
										{
											break;
										}
										printf("%02x ",jiechuchannel[i]);
									}
									printf("\n");
									#endif
									unsigned char greenchannel[MAX_CHANNEL]={0};
									if(0 != persiondelaychannel[0])
									{
										unsigned char q,w,e = 0,flag = 0;		
										for(q = 0;q<MAX_CHANNEL;q++)
										{
											if(0 == jiechuchannel[q])
											{
												break;
											}
											for(w = 0;w<MAX_CHANNEL;w++)
											{
												if(0 == persiondelaychannel[w])
												{
													break;
												}
												if(jiechuchannel[q] == persiondelaychannel[w])
												{
													flag = 0;
													break;
												}
												flag = 1;
											}
											if(flag)
											{
												greenchannel[e] = jiechuchannel[q];
												e++;
											}
											flag = 0;
										}
									}
									else
									{
										memcpy(greenchannel,jiechuchannel,sizeof(greenchannel));
									}
									if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),greenchannel,0x02))
									{
										#ifdef ROADINFO_DEBUG
										printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										gettimeofday(&ct,NULL);
										update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
										if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																			dcdata->fd->softevent,dcdata->fd->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
												printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(dcdata->fd->markbit) |= 0x0800;
									}
									
									if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,greenchannel,0x02, \
										                                                dcdata->fd->markbit))
								    {
								    	#ifdef ROADINFO_DEBUG
								        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
								    	#endif
								    }
									if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
									{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
										
										sinfo.color = 0x02;
										sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
										sinfo.chans = 0;
										memset(sinfo.csta,0,sizeof(sinfo.csta));
										csta = sinfo.csta;
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == greenchannel[i])
												break;
											sinfo.chans += 1;
											tcsta = greenchannel[i];
											tcsta <<= 2;
											tcsta &= 0xfc;
											tcsta |= 0x02;
											*csta = tcsta;
											csta++;
										}
										memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
											#ifdef ROADINFO_DEBUG
												printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
										}
										else
										{
											write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}						
									memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
									
								}
								continue;
							}
							else
							{
								nowtime.tv_sec = 0;
                        		nowtime.tv_usec = 0;
                        		gettimeofday(&nowtime,NULL);
                        		leatime = nowtime.tv_sec - lasttime.tv_sec;
                        		sltime -= leatime;
								if (sltime > bakv)
									sltime = bakv;
								continue;
							}
						}
						else
						{
							nowtime.tv_sec = 0;
							nowtime.tv_usec = 0;
							gettimeofday(&nowtime,NULL);
							leatime = nowtime.tv_sec - lasttime.tv_sec;
							sltime -= leatime;
							if (sltime > bakv)
								sltime = bakv;
							continue;
						}

					}//mret > 0
				}//while (1)
			}//not have person channels
			
			if (0 == ffw)
			{
				#ifdef FULL_DETECT_DEBUG
	            	printf("Begin to monitor vehicle,time: %d,File: %s,Line: %d\n",pinfo->ldeti,__FILE__,__LINE__);
	            #endif
				mt = pinfo->ldeti;
				mintime = pinfo->mingtime;
				int maxv = 0;
				//memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
				unsigned char receivetime = 0;
				while (1)
				{//while loop
					//clean pipe
            		while (1)
            		{
                		memset(buf,0,sizeof(buf));
                		if (read(*(dcdata->fd->flowpipe),buf,sizeof(buf)) <= 0)
                    		break;
            		}
					FD_ZERO(&nRead);
                	FD_SET(*(dcdata->fd->flowpipe),&nRead);
					FD_SET(*(dcdata->fd->ffpipe),&nRead);
                	lasttime.tv_sec = 0;
                	lasttime.tv_usec = 0;
                	gettimeofday(&lasttime,NULL);
					bakv = mt;
                	mtime.tv_sec = mt;
                	mtime.tv_usec = 0;
					maxv = MAX(*(dcdata->fd->flowpipe),*(dcdata->fd->ffpipe));
                	int mret = select(maxv+1,&nRead,NULL,NULL,&mtime);
					if (mret < 0)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						ms_end_part_child_thread();
						return;
					}
					if (0 == mret)
					{//time out
						break;
					}//time out
					if (mret > 0)
					{//have vehicle pass
						if (FD_ISSET(*(dcdata->fd->ffpipe),&nRead))
						{
							num = 0;
                            memset(buf,0,sizeof(buf));
                            pbuf = buf;
                            num = read(*(dcdata->fd->ffpipe),buf,sizeof(buf));
							if (num > sizeof(buf))
                                continue;
                            if (!strncmp(buf,"fastforward",11))
                            {
								ffw = 1;
                                break;
                            }
							else
							{
								nowtime.tv_sec = 0;
                                nowtime.tv_usec = 0;
                                gettimeofday(&nowtime,NULL);
                                leatime = nowtime.tv_sec - lasttime.tv_sec;
                                mt -= leatime;
								if (mt > bakv)
									mt = bakv;
                                continue;
							}
						}
						else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
						{
							num = 0;
							memset(buf,0,sizeof(buf));
							pbuf = buf;
							num = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
							if (num > sizeof(buf))
                                continue;
							if (num <= 0)
							{
								nowtime.tv_sec = 0;
								nowtime.tv_usec = 0;
								gettimeofday(&nowtime,NULL);
								leatime = nowtime.tv_sec - lasttime.tv_sec;
								mt -= leatime;
								if (mt > bakv)
                                    mt = bakv;
								continue;
							}
							else
							{//num > 0
								mark = 0;
                            	caryes = 0;
								bevent = 0;
                            	while (1)
                            	{//inline while loop
                                	if (mark >= num)
                                    	break;
									if((0xF4 == *(pbuf+mark)) && (0xED == *(pbuf+mark+6)))
									{
										
										memset(pinfo->redchannel,0,sizeof(pinfo->redchannel));
										memset(currentquenuelocation,0,sizeof(currentquenuelocation));
										
										unsigned char i =0,k =0,p =0,j=0,w =0;
										
										for (j = 0; j < 1; j++)
										{
											if((buf[3]>>j) & 0x01)
											{
												istrafficlock = 1; 
												#ifdef ROADINFO_DEBUG
												printf("lock location is 17,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
											}
											else
											{
												istrafficlock = 0;
												#ifdef ROADINFO_DEBUG
												//printf("no lock location,File: %s,Line: %d\n",__FILE__,__LINE__);	
												#endif
											}
										
										}
										if(1 == istrafficlock)
										{
											pthread_t   allredpid; 
											int dcret = pthread_create(&allredpid,NULL,(void *)ms_all_red,dcdata);
											if (0 != dcret)
											{
													#ifdef ROADINFO_DEBUG
													printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("major_salve_detect_control,create major salve detect thread err");
													#endif
												return ;
											}
										}
										if(1 == istrafficlock)//交通死锁
										{
	
											nowtime.tv_sec = 0;
											nowtime.tv_usec = 0;
											gettimeofday(&nowtime,NULL);
											leatime = nowtime.tv_sec - lasttime.tv_sec;
											mt -= leatime;
											if (mt > bakv)
			                                    mt = bakv;
											#ifdef ROADINFO_DEBUG
											printf("jiao tong si suo wait jie chu: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
											memset(lastquenuelocation,0,sizeof(lastquenuelocation));
											while(1)
											{
												FD_ZERO(&nRead);
												FD_SET(*(dcdata->fd->flowpipe),&nRead);
												int ret = select(*(dcdata->fd->flowpipe)+1,&nRead,NULL,NULL,NULL);
												if(ret > 0)
												{
													memset(buf,0,sizeof(buf));
													int len = read(*(dcdata->fd->flowpipe),buf,sizeof(buf));
													buf[len] = 0;
													if((0xF4 == buf[0]) && (0xED==buf[len-1])&& (0x01 == buf[3]))
													{
														#ifdef ROADINFO_DEBUG
														printf("continue wait : %s,Line: %d\n",__FILE__,__LINE__);	
														#endif
														continue;
													}
													else
													{
														#ifdef ROADINFO_DEBUG
														printf("si suo jie chu : %s,Line: %d\n",__FILE__,__LINE__);	
														#endif
														istrafficlock = 0;
														roadreport[0] = 0x21;
														roadreport[1] = 0x85;
														roadreport[2] = 0xFB;
														roadreport[3] = 0x00;
														roadreport[4] = 0xff;
														roadreport[5] = 0xfe; 
														roadreport[6] = 0xff;
														roadreport[7] = 0xff;
														write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
														#ifdef ROADINFO_DEBUG
														printf("send roaddata 1 :");
														for(k=0;k<8;k++)
														{
															printf("%02x ",roadreport[k]);
														}
														printf("\n");
														#endif
														if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->chan,0x02))
														{
															#ifdef ROADINFO_DEBUG
															printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
															#endif
															gettimeofday(&ct,NULL);
															update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
															if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																								dcdata->fd->softevent,dcdata->fd->markbit))
															{
																	#ifdef ROADINFO_DEBUG
																	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
																	#endif
															}
															*(dcdata->fd->markbit) |= 0x0800;
														}
														
														if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->chan,0x02, \
																											dcdata->fd->markbit))
														{
															#ifdef ROADINFO_DEBUG
															printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
															#endif
														}
														if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
														{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
															
															sinfo.color = 0x02;
															sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
															sinfo.chans = 0;
															memset(sinfo.csta,0,sizeof(sinfo.csta));
															csta = sinfo.csta;
															for (i = 0; i < MAX_CHANNEL; i++)
															{
																if (0 == pinfo->chan[i])
																	break;
																sinfo.chans += 1;
																tcsta = pinfo->chan[i];
																tcsta <<= 2;
																tcsta &= 0xfc;
																tcsta |= 0x02;
																*csta = tcsta;
																csta++;
															}
															memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
															memset(sibuf,0,sizeof(sibuf));
															if (SUCCESS != status_info_report(sibuf,&sinfo))
															{
																	#ifdef ROADINFO_DEBUG
																	printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
																	#endif
															}
															else
															{
																write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
															}
														}				

														break;
													}
												}
												else
												{
													break;
												}
											}
											break;
										}

										//排队溢出3
//										nowtime.tv_sec = 0;
//										nowtime.tv_usec = 0;
//										gettimeofday(&nowtime,NULL);
//										leatime = nowtime.tv_sec - lasttime.tv_sec;
//										mt -= leatime;
//										if (mt > bakv)
//		                                    mt = bakv;
										
										if(1 == isdelay && (buf[4]>>4 & 0x0f) == 0x00)
										{
											bevent = 1;
											break;
										}
										if(receivetime == 1)
										{
											if(0 == isreport && (buf[4]>>4 & 0x0f) == 0x00)
											{
												bevent = 1;
												break;
											}
										}
										receivetime = 1;
										unsigned char curretlefttime;
										curretlefttime = pinfo->gftime;
										if (*(dcdata->fd->auxfunc) & 0x01)
                                        curretlefttime += *(dcdata->fd->halfdownt);
										if(curretlefttime > 6)
										{
											curretlefttime = 6;
										}

										curretlefttime += mt;
										#ifdef ROADINFO_DEBUG
										printf("receive curretlefttime %d : %s,Line: %d\n",curretlefttime,__FILE__,__LINE__);	
										#endif
										if(curretlefttime < 6)
										{
											bevent = 1;
											break;
										}
										if(1 == isreport)
										{
											bevent = 1;
											break;
										}
										iscarquenueonerflow = 1;
										for(i=4;i<8;i++)
										{
											if((buf[4] >> i) & 0x01)
											{
												if(4 == i)
												{	
													pinfo->roadbit[p] = i;
													p++;
													w = 0;
													currentquenuelocation[0] = 1;
													for(j = 0;j < MAX_CHANNEL;j++)
													{
														if(0 == pinfo->chan[j])
														{
															break;
														}
														if(2 == pinfo->chan[j])
														{
															pinfo->xiredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(9 == pinfo->chan[j])
														{
														
															pinfo->xiredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(7 == pinfo->chan[j])
														{
															pinfo->xiredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;											
														}
													}
													pinfo->redchannel[k] = 2;
													k++;
													pinfo->redchannel[k] = 9;
													k++;
													pinfo->redchannel[k] = 7;
													k++;
													#ifdef ROADINFO_DEBUG
													printf("quenue location is 13,File: %s,Line: %d\n",__FILE__,__LINE__);	
													#endif
												}
												else if(5 == i)
												{
													pinfo->roadbit[p] = i;
													p++;
													w =0;
													currentquenuelocation[1] = 1;
													for(j = 0;j < MAX_CHANNEL;j++)
													{
														if(0 == pinfo->chan[j])
														{
															break;
														}
														if(12 == pinfo->chan[j])
														{
															pinfo->nanredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(1 == pinfo->chan[j])
														{
														
															pinfo->nanredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(6 == pinfo->chan[j])
														{
															pinfo->nanredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;											
														}

													}
													pinfo->redchannel[k] = 12;
													k++;
													pinfo->redchannel[k] = 1;
													k++;
													pinfo->redchannel[k] = 6;
													k++;
													#ifdef ROADINFO_DEBUG
													printf("quenue location is 14,File: %s,Line: %d\n",__FILE__,__LINE__);	
													#endif

												}
												else if(6 == i)
												{
													pinfo->roadbit[p] = i;
													p++;
													w= 0;
													currentquenuelocation[2] = 1;
													for(j = 0;j < MAX_CHANNEL;j++)
													{
														if(0 == pinfo->chan[j])
														{
															break;
														}
														if(5 == pinfo->chan[j])
														{
															pinfo->dongredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(4 == pinfo->chan[j])
														{
														
															pinfo->dongredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(11 == pinfo->chan[j])
														{
															pinfo->dongredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;											
														}										
													}
													pinfo->redchannel[k] = 4;
													k++;
													pinfo->redchannel[k] = 5;
													k++;
													pinfo->redchannel[k] = 11;
													k++;
													#ifdef ROADINFO_DEBUG
													printf("quenue location is 15,File: %s,Line: %d\n",__FILE__,__LINE__);	
													#endif

												}
												else if(7 == i)
												{
													pinfo->roadbit[p] = i;
													p++;
													w = 0;
													currentquenuelocation[3] = 1;
													for(j = 0;j < MAX_CHANNEL;j++)
													{
														if(0 == pinfo->chan[j])
														{
															break;
														}	
														if(8== pinfo->chan[j])
														{
															pinfo->beiredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(3== pinfo->chan[j])
														{
														
															pinfo->beiredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;
														}
														if(10 == pinfo->chan[j])
														{
															pinfo->beiredchannel[w] = pinfo->chan[j];
															//pinfo->redchannel[k] = pinfo->chan[j];
															//k++;
															w++;											
														}

													}
													pinfo->redchannel[k] = 8;
													k++;
													pinfo->redchannel[k] = 3;
													k++;
													pinfo->redchannel[k] = 10;
													k++;
													#ifdef ROADINFO_DEBUG
													printf("quenue location is 16,File: %s,Line: %d\n",__FILE__,__LINE__);	
													#endif

												}
											}
											else
											{
												
												continue;
											}
										}
										//排队溢出1
										if(0 ==pinfo->redchannel[0])
										{
											iscarquenueonerflow = 0;
										}
										else
										{
											isreport = 1;
										}
										memcpy(currentquenuechannel,pinfo->redchannel,sizeof(currentquenuechannel));
										if(currentquenuelocation[0] == 1)
										{
											#ifdef ROADINFO_DEBUG
											printf("xi fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
											if(1 != lastquenuelocation[0])
											{
												lastquenuelocation[0] = 1;
												pthread_t    		xipid; 
												int dcret = pthread_create(&xipid,NULL,(void *)ms_phase_monitor_deal_xi,dcdata);
												if (0 != dcret)
												{
														#ifdef ROADINFO_DEBUG
														printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
														output_log("ms_phase_monitor_deal_xi,create major salve detect thread err");
														#endif
													return ;
												}
											}
											
										}
										if(currentquenuelocation[1] == 1)
										{
											#ifdef ROADINFO_DEBUG
											printf("nan fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
											if(1 != lastquenuelocation[1])
											{
												lastquenuelocation[1] = 1;
												pthread_t    		nanpid; 
												int dcret = pthread_create(&nanpid,NULL,(void *)ms_phase_monitor_deal_nan,dcdata);
												if (0 != dcret)
												{
														#ifdef ROADINFO_DEBUG
														printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
														output_log("ms_phase_monitor_deal_nan,create major salve detect thread err");
														#endif
													return ;
												}
											}
											
										}
										if(currentquenuelocation[2] == 1)
										{
											#ifdef ROADINFO_DEBUG
											printf("dong fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
											if(1 != lastquenuelocation[2])
											{
												lastquenuelocation[2] = 1;
												pthread_t    		dongpid; 
												int dcret = pthread_create(&dongpid,NULL,(void *)ms_phase_monitor_deal_dong,dcdata);
												if (0 != dcret)
												{
														#ifdef ROADINFO_DEBUG
														printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
														output_log("ms_phase_monitor_deal_dong,create major salve detect thread err");
														#endif
													return ;
												}
											}	
											
										}
										if(currentquenuelocation[3] == 1)
										{
											#ifdef ROADINFO_DEBUG
											printf("bei fen zhi  quenue,File: %s,Line: %d\n",__FILE__,__LINE__);	
											#endif
											if(1 != lastquenuelocation[3])
											{
												lastquenuelocation[3] = 1;
												pthread_t    		beipid; 
												int dcret = pthread_create(&beipid,NULL,(void *)ms_phase_monitor_deal_bei,dcdata);
												if (0 != dcret)
												{
														#ifdef ROADINFO_DEBUG
														printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
														output_log("ms_phase_monitor_deal_bei,create major salve detect thread err");
														#endif
													return ;
												}
											}
											
										}
										roadreport[0] = 0x21;
										roadreport[1] = 0x85;
										roadreport[2] = 0xFB;
										roadreport[3] = 0x00;
										roadreport[4] = 0xff;
										roadreport[5] = 0xff;
										roadreport[6] = 0xff;
										roadreport[7] = 0xff;
										unsigned char jiechuchannel[MAX_CHANNEL] = {0};
										unsigned char q= 0,e = 0,flag = 0;
										if(currentquenuelocation[0] == 0 && lastquenuelocation[0] == 1)
										{
											roadreport[6]  &=  0xef;
											flag = 0;
											lastquenuelocation[0] = 0;
											for(q = 0;q<MAX_CHANNEL;q++)
											{
												if(0 == pinfo->chan[q])
												{
													break;
												}
												for(w = 0;w<MAX_CHANNEL;w++)
												{
													if(0 == currentquenuechannel[w])
													{
														break;
													}
													if( pinfo->chan[q]== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													/* if( 2== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 9== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 7== currentquenuechannel[w])
													{
														flag = 0;
														break;
													} */
													flag = 1;
												}
												if(flag)
												{
													jiechuchannel[e] = pinfo->chan[q];
													e++;
												}
												flag = 0;
											}
										}
										if(currentquenuelocation[1] == 0 && lastquenuelocation[1] == 1)
										{
											roadreport[6]  &=  0xdf;
											flag = 0;
											lastquenuelocation[1] = 0;
											for(q = 0;q<MAX_CHANNEL;q++)
											{
												if(0 == pinfo->chan[q])
												{
													break;
												}
												for(w = 0;w<MAX_CHANNEL;w++)
												{
													if(0 == currentquenuechannel[w])
													{
														break;
													}
													if( pinfo->chan[q]== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													/* if( 12== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 1== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 6== currentquenuechannel[w])
													{
														flag = 0;
														break;
													} */
													flag = 1;
												}
												if(flag)
												{
													jiechuchannel[e] = pinfo->chan[q];
													e++;
												}
												flag = 0;
											}
										}								
										if(currentquenuelocation[2] == 0 && lastquenuelocation[2] == 1)
										{
											roadreport[6]  &=  0xbf;
											flag = 0;
											lastquenuelocation[2] = 0;
											for(q = 0;q<MAX_CHANNEL;q++)
											{
												if(0 == pinfo->chan[q])
												{
													break;
												}
												for(w = 0;w<MAX_CHANNEL;w++)
												{
													if(0 == currentquenuechannel[w])
													{
														break;
													}
													if( pinfo->chan[q]== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													/* if( 5== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 4== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 11== currentquenuechannel[w])
													{
														flag = 0;
														break;
													} */
													flag = 1;
												}
												if(flag)
												{
													jiechuchannel[e] = pinfo->chan[q];
													e++;
												}
												flag = 0;
											}
										}								
										if(currentquenuelocation[3] == 0 && lastquenuelocation[3] == 1)
										{
											roadreport[6]  &=  0x7f;
											flag = 0;
											lastquenuelocation[3] = 0;
											for(q = 0;q<MAX_CHANNEL;q++)
											{
												if(0 == pinfo->chan[q])
												{
													break;
												}
												for(w = 0;w<MAX_CHANNEL;w++)
												{
													if(0 == currentquenuechannel[w])
													{
														break;
													}
													if( pinfo->chan[q]== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													/* if( 8== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 3== currentquenuechannel[w])
													{
														flag = 0;
														break;
													}
													if( 10== currentquenuechannel[w])
													{
														flag = 0;
														break;
													} */
													flag = 1;
												}
												if(flag)
												{
													jiechuchannel[e] = pinfo->chan[q];
													e++;
												}
												flag = 0;
											}
										}
										if(jiechuchannel[0] != 0)
										{
											iscarquenueonerflow = 0;
										}
										if(currentquenuechannel[0] == 0)
										{
											memset(jiechuchannel,0,sizeof(jiechuchannel));
											memcpy(jiechuchannel,pinfo->chan,sizeof(jiechuchannel));
										}
										if(0 == iscarquenueonerflow)
										{		
											if(0xff == roadreport[6])
											{	
												bevent = 1;
												break;
											}
											write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
											#ifdef ROADINFO_DEBUG
											printf("send jichu3  report:");
											for(i=0;i<sizeof(roadreport);i++)
											{
												
												printf("%02x ",roadreport[i]);
											}
											printf("\n");
											#endif
											unsigned char greenchannel[MAX_CHANNEL]={0};
											if(0 != persiondelaychannel[0])
											{
												unsigned char q,w,e = 0,flag = 0;		
												for(q = 0;q<MAX_CHANNEL;q++)
												{
													if(0 == jiechuchannel[q])
													{
														break;
													}
													for(w = 0;w<MAX_CHANNEL;w++)
													{
														if(0 == persiondelaychannel[w])
														{
															break;
														}
														if(jiechuchannel[q] == persiondelaychannel[w])
														{
															flag = 0;
															break;
														}
														flag = 1;
													}
													if(flag)
													{
														greenchannel[e] = jiechuchannel[q];
														e++;
													}
													flag = 0;
												}
											}
											else
											{
												memcpy(greenchannel,jiechuchannel,sizeof(greenchannel));
											}
											if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),greenchannel,0x02))
											{
												#ifdef ROADINFO_DEBUG
												printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
												#endif
												gettimeofday(&ct,NULL);
												update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
												if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
																					dcdata->fd->softevent,dcdata->fd->markbit))
												{
												#ifdef FULL_DETECT_DEBUG
														printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
												#endif
												}
												*(dcdata->fd->markbit) |= 0x0800;
											}
											
											if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,greenchannel,0x02, \
												                                                dcdata->fd->markbit))
										    {
										    	#ifdef ROADINFO_DEBUG
										        printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
										    	#endif
										    }
											if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
											{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
												
												sinfo.color = 0x02;
												sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
												sinfo.chans = 0;
												memset(sinfo.csta,0,sizeof(sinfo.csta));
												csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == greenchannel[i])
														break;
													sinfo.chans += 1;
													tcsta = greenchannel[i];
													tcsta <<= 2;
													tcsta &= 0xfc;
													tcsta |= 0x02;
													*csta = tcsta;
													csta++;
												}
												memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
													#ifdef ROADINFO_DEBUG
														printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
													#endif
												}
												else
												{
													write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}						
											memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));		
										}
										break;
									}
									else if ((0xF1 == *(pbuf+mark)) && (0xED == *(pbuf+mark+5)))
                                	{

										
										deteid = *(pbuf+mark+2);
										//pinfo->pdelay = *(pbuf+mark+4);
										if(0xEE != *(pbuf+mark+4))
										{
											pinfo->pdelay = *(pbuf+mark+4);
										}
										printf("************deteid:%d,pinfo->pdelay: %d,line: %d\n",deteid,pinfo->pdelay,__LINE__);
                                    	if (0x01 == *(pbuf+mark+1))
                                    	{//have vehicle pass
                                    		
											//临时定位保存接受时间
											//struct timeval      tv={0};
											//struct tm           p = {0};
											//unsigned char		tbuf[64] = {0};
											//unsigned char       szTmp[50] = {0};
											
		                            		//gettimeofday(&tv, NULL);
											//localtime_r(&tv.tv_sec, &p);
											//strftime(szTmp,50,"%F %H:%M:%S",&p);
											//sprintf(tbuf,"%s %d",szTmp,tv.tv_usec);
											
											//output_log(tbuf);
											//临时定位保存接受时间
											
                                        	for (j = 0; j < (dcdata->td->detector->FactDetectorNum); j++)
                                        	{
                                            	if (0 == (dcdata->td->detector->DetectorList[j].DetectorId))
                                                	break;
												if(deteid==(dcdata->td->detector->DetectorList[j].DetectorId))
												{
													dtype = dcdata->td->detector->DetectorList[j].DetectorType;
													if ((0x40 == dtype) || (0x80 == dtype) || (0x04 == dtype))
													{//request or response detector or bus detector
														mappid = \
														dcdata->td->detector->DetectorList[j].DetectorPhase;
														if (mappid == (pinfo->phaseid))
														{
															caryes = 1;
															break;
														}
													}//request or response detector
													else
													{//unfit detector
														break;
													}//unfit detector
												}
                                        	}//for (j = 0; j < (dcdata->td->detector->FactDetectorNum); j++)
                                        	if (1 == caryes)
											{
                                            	break;
											}
                                    	}//have vehicle pass
                                    	mark += 6;
                                    	continue;//Fit data,break directly
                                	}
                                	else
                                	{
                                    	mark += 1;
                                    	continue;
                                	}
								}//inline while loop
								if(bevent == 1)
								{
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									mt -= leatime;
									if (mt > bakv)
										mt = bakv;
									//printf(" mt %d  leatime %d: bakv : %d %s,Line: %d\n",mt,leatime,bakv,__FILE__,__LINE__);
									continue;
								}
								if (1 == caryes)
								{
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									mt -= leatime;
									if (mt > bakv)
										mt = bakv;
									bakmaxg = 0;
									if (*(dcdata->fd->auxfunc) & 0x01)
										bakmaxg = pinfo->maxgtime1 - (*(dcdata->fd->halfdownt));
									else
										bakmaxg = pinfo->maxgtime1;

									if ((mintime + (pinfo->pdelay)) >= bakmaxg)
									{
										#ifdef FULL_DETECT_DEBUG
											printf("Has arrived max time,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										unsigned char lastdelattime = 0;
										lastdelattime =  bakmaxg - mintime;
										delay_time_report(dcdata->fd->sockfd, lastdelattime);
										if ((!(*(dcdata->fd->markbit) & 0x1000)) && \
                                            	(!(*(dcdata->fd->markbit) & 0x8000)))
                                    	{
											if (0 == pinfo->cchan[0])
											{
												sinfo.time = mt + bakmaxg - mintime + \
															pinfo->gftime + pinfo->ytime + pinfo->rtime;
										//		#ifdef FULL_DOWN_TIME
												if (*(dcdata->fd->auxfunc) & 0x01)
                                            		sinfo.time += *(dcdata->fd->halfdownt);
                                        //    	#endif
											}
											else
											{
                                        		sinfo.time = mt + bakmaxg - mintime + pinfo->gftime;
												//if(pinfo->gftime == 0)
											//	{
													if (*(dcdata->fd->auxfunc) & 0x01)
                                            		sinfo.time += *(dcdata->fd->halfdownt);
											//	}
											}
											memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
                                        	memset(sibuf,0,sizeof(sibuf));
                                        	if (SUCCESS != status_info_report(sibuf,&sinfo))
                                        	{
                                        	#ifdef FULL_DETECT_DEBUG
                                            	printf("status pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        	#endif
                                        	}
                                        	else
                                        	{
                                            	write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
                                       		}
                                    	}		
										//downtime is (mt + (pinfo->maxgtime1 - mintime))
										if((*(dcdata->fd->markbit) & 0x0002)&&(*(dcdata->fd->markbit) & 0x0010))
                						{
                    						memset(&timedown,0,sizeof(timedown));
                    						timedown.mode = *(dcdata->fd->contmode);
                    						timedown.pattern = *(dcdata->fd->patternid);
                    						timedown.lampcolor = 0x02;
                    						timedown.lamptime =mt+bakmaxg-mintime+(pinfo->gftime);
									//		#ifdef FULL_DOWN_TIME
											if (*(dcdata->fd->auxfunc) & 0x01)
												timedown.lamptime += *(dcdata->fd->halfdownt);
									//		#endif
                    						timedown.phaseid = pinfo->phaseid;
                    						timedown.stageline = pinfo->stageline;
                    					if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                    						{
                    						#ifdef FULL_DETECT_DEBUG
                        						printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                    						#endif
                    						}
                						}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(dcdata->fd->markbit2) & 0x0200)
										{
											memset(&timedown,0,sizeof(timedown));
                                            timedown.mode = *(dcdata->fd->contmode);
                                            timedown.pattern = *(dcdata->fd->patternid);
                                            timedown.lampcolor = 0x02;
                                            timedown.lamptime =mt+bakmaxg-mintime+(pinfo->gftime);
                                    //      #ifdef FULL_DOWN_TIME
                                            if (*(dcdata->fd->auxfunc) & 0x01)
                                                timedown.lamptime += *(dcdata->fd->halfdownt);
                                    //      #endif
                                            timedown.phaseid = pinfo->phaseid;
                                            timedown.stageline = pinfo->stageline;	
											if(SUCCESS!=timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										//send info to face board
										if (*(dcdata->fd->contmode) < 27)
                							fbdata[1] = *(dcdata->fd->contmode) + 1;
            							else
                							fbdata[1] = *(dcdata->fd->contmode);
										if ((30 == fbdata[1]) || (31 == fbdata[1]))
                						{
                    						fbdata[2] = 0;
                    						fbdata[3] = 0;
                    						fbdata[4] = 0;
                						}
                						else
										{
											fbdata[2] = pinfo->stageline;
            								fbdata[3] = 0x02;
            								fbdata[4] = mt + bakmaxg - mintime + (pinfo->gftime);
									//		#ifdef FULL_DOWN_TIME
											if (*(dcdata->fd->auxfunc) & 0x01)
												fbdata[4] += *(dcdata->fd->halfdownt);
									//		#endif
										}
            							if (!wait_write_serial(*(dcdata->fd->fbserial)))
            							{
                							if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                							{
                							#ifdef FULL_DETECT_DEBUG
                    							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                							#endif
												*(dcdata->fd->markbit) |= 0x0800;
                    							gettimeofday(&ct,NULL);
                    							update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16, \
																	ct.tv_sec,dcdata->fd->markbit);
                    						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                    							{
                    							#ifdef FULL_DETECT_DEBUG
                        							printf("file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    							#endif
                    							}
                							}
            							}
            							else
            							{
            							#ifdef FULL_DETECT_DEBUG
                						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            							#endif
            							}
										sendfaceInfoToBoard(dcdata->fd,fbdata);
										sleep(mt + bakmaxg - mintime);
										//added on 20220620
            							adaptd.phi[ni].paddt += bakmaxg - mintime;
										//end add
										break;
									}//if ((mintime + (pinfo->pdelay)) >= (pinfo->maxgtime1))
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("Not arrive max green,delay %d sec,File: %s,Line: %d\n",pinfo->pdelay,__FILE__,__LINE__);
									#endif
										delay_time_report(dcdata->fd->sockfd, pinfo->pdelay);
										if ((!(*(dcdata->fd->markbit) & 0x1000)) && \
                                            	(!(*(dcdata->fd->markbit) & 0x8000)))
                                    	{
											if (0 == pinfo->cchan[0])
											{
												sinfo.time = mt + (pinfo->pdelay) + pinfo->gftime + \
															pinfo->ytime + pinfo->rtime;
											//	#ifdef FULL_DOWN_TIME
												if (*(dcdata->fd->auxfunc) & 0x01)
                                            		sinfo.time += *(dcdata->fd->halfdownt);
                                           // 	#endif	
											}
											else
											{
                                        		sinfo.time = mt + (pinfo->pdelay) + pinfo->gftime;
												//if(pinfo->gftime == 0)
												//{
													if (*(dcdata->fd->auxfunc) & 0x01)
                                            		sinfo.time += *(dcdata->fd->halfdownt);
												//}
											}
											memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
                                        	memset(sibuf,0,sizeof(sibuf));
                                        	if (SUCCESS != status_info_report(sibuf,&sinfo))
                                        	{
                                        	#ifdef FULL_DETECT_DEBUG
                                            	printf("status pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        	#endif
                                        	}
                                        	else
                                        	{
                                            	write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
                                        	}
                                    	}	
										//downtime is (mt + pinfo->pdelay)
										if((*(dcdata->fd->markbit) & 0x0002)&&(*(dcdata->fd->markbit)&0x0010))
                						{
                    						memset(&timedown,0,sizeof(timedown));
                    						timedown.mode = *(dcdata->fd->contmode);
                    						timedown.pattern = *(dcdata->fd->patternid);
                    						timedown.lampcolor = 0x02;
                    						timedown.lamptime = mt + (pinfo->pdelay) + (pinfo->gftime);
								//			#ifdef FULL_DOWN_TIME
											if (*(dcdata->fd->auxfunc) & 0x01)
                                            	timedown.lamptime += *(dcdata->fd->halfdownt);
                                //            #endif
                    						timedown.phaseid = pinfo->phaseid;
                    						timedown.stageline = pinfo->stageline;
                    					if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                    						{
                    						#ifdef FULL_DETECT_DEBUG
                        						printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                    						#endif
                    						}
                						}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(dcdata->fd->markbit2) & 0x0200)
										{
											memset(&timedown,0,sizeof(timedown));
                                            timedown.mode = *(dcdata->fd->contmode);
                                            timedown.pattern = *(dcdata->fd->patternid);
                                            timedown.lampcolor = 0x02;
                                            timedown.lamptime = mt + (pinfo->pdelay) + (pinfo->gftime);
                                //          #ifdef FULL_DOWN_TIME
                                            if (*(dcdata->fd->auxfunc) & 0x01)
                                                timedown.lamptime += *(dcdata->fd->halfdownt);
                                //            #endif
                                            timedown.phaseid = pinfo->phaseid;
                                            timedown.stageline = pinfo->stageline;	
											if(SUCCESS!=timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										//send info to face board
										if (*(dcdata->fd->contmode) < 27)
                							fbdata[1] = *(dcdata->fd->contmode) + 1;
            							else
                							fbdata[1] = *(dcdata->fd->contmode);
										if ((30 == fbdata[1]) || (31 == fbdata[1]))
                						{
                    						fbdata[2] = 0;
                    						fbdata[3] = 0;
                    						fbdata[4] = 0;
                						}
                						else
										{
											fbdata[2] = pinfo->stageline;
            								fbdata[3] = 0x02;
            								fbdata[4] = mt + (pinfo->pdelay) + (pinfo->gftime);
									//		#ifdef FULL_DOWN_TIME
											if (*(dcdata->fd->auxfunc) & 0x01)
                                            	fbdata[4] += *(dcdata->fd->halfdownt);
                                    //        #endif
										}
            							if (!wait_write_serial(*(dcdata->fd->fbserial)))
            							{
                							if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                							{
                							#ifdef FULL_DETECT_DEBUG
                    							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                							#endif
												*(dcdata->fd->markbit) |= 0x0800;
                    							gettimeofday(&ct,NULL);
                    							update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16, \
																	ct.tv_sec,dcdata->fd->markbit);
                    							if (SUCCESS != generate_event_file(dcdata->fd->ec, \
												dcdata->fd->el,dcdata->fd->softevent,dcdata->fd->markbit))
                    							{
                    							#ifdef FULL_DETECT_DEBUG
                        							printf("genfileerr,File: %s,Line: %d\n",__FILE__,__LINE__);
                    							#endif
                    							}
                							}
            							}
            							else
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            							#endif
            							}
										sendfaceInfoToBoard(dcdata->fd,fbdata);
										sleep(mt);
										if (pinfo->pdelay > pinfo->ldeti)
										{
											mt = pinfo->pdelay - pinfo->ldeti;
											sleep(mt);
											mt = pinfo->ldeti;
										}
										else
										{
											mt = pinfo->pdelay;
										}
										mintime += pinfo->pdelay;
										//added on 20220620
            							adaptd.phi[ni].paddt += pinfo->pdelay;
										//end add
										#ifdef ROADINFO_DEBUG
										printf("The green lamp is add and wait next delay data\n");
										#endif
										
										continue;
									}
								}//if (1 == caryes)
								else
								{
									nowtime.tv_sec = 0;
									nowtime.tv_usec = 0;
									gettimeofday(&nowtime,NULL);
									leatime = nowtime.tv_sec - lasttime.tv_sec;
									mt -= leatime;
									if (mt > bakv)
										mt = bakv;
									continue;
								}
							}//num > 0
						}//else if (FD_ISSET(*(dcdata->fd->flowpipe),&nRead))
						else
						{
							nowtime.tv_sec = 0;
							nowtime.tv_usec = 0;
							gettimeofday(&nowtime,NULL);
							leatime = nowtime.tv_sec - lasttime.tv_sec;
							mt -= leatime;
							if (mt > bakv)
								mt = bakv;
							continue;
						}
					}//have vehicle pass	
				}//while loop
			}//0 == ffw

	//		#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					for (i = 0; i < MAX_PHASE_LINE; i++)
					{
						if (0 == phdetect[i].stageid)
							break;
						if (pinfo->stageline == phdetect[i].stageid)
							break;
					}
					tchans = 0;
					downti[6] = 0;
					if (i != MAX_PHASE_LINE)
					{
						if (0 == phdetect[i+1].stageid)
						{
							tchans = phdetect[0].chans;
						}
						else
						{
							tchans = phdetect[i+1].chans;
						}
						downti[6] += *(dcdata->fd->halfdownt) + phdetect[i].gftime + \
										phdetect[i].ytime + phdetect[i].rtime;
						for (j = 0; j < MAX_CHANNEL; j++)
						{//for (j = 0; j < MAX_CHANNEL; j++)
							if (0 == (pinfo->chan[j]))
								break;
							if (tchans & (0x00000001 << (pinfo->chan[j] - 1)))
								tchans &= (~(0x00000001 << (pinfo->chan[j] - 1)));
						}//for (j = 0; j < MAX_CHANNEL; j++)
					}//if (i != MAX_PHASE_LINE)
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x00;

					#ifdef V2X_DEBUG
					unsigned char       v2xc[MAX_CHANNEL] = {0};
					unsigned char       *pv2xc = v2xc;
					for (j = 1; j < (MAX_CHANNEL+1); j++)
					{
						if (tchans & (0x00000001 << (j-1)))
						{
							*pv2xc = j;
							pv2xc++;
						}
					}
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == v2xc[j])
							break;
						if ((v2xc[j] < 13) || (v2xc[j] > 16))
						{
							dcdata->fd->slg[v2xc[j]-1].slgid = v2xc[j];
							dcdata->fd->slg[v2xc[j]-1].slgstatus = 0x15;
							dcdata->fd->slg[v2xc[j]-1].countdown = downti[6] + 1;
							dcdata->fd->slg[v2xc[j]-1].nslgstatus = 0x17;

							if (0 == phdetect[i+1].stageid)
                        	{
                            	dcdata->fd->slg[v2xc[j]-1].greent = phdetect[0].gtime + phdetect[0].gftime;
								dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[0].ytime;
								dcdata->fd->slg[v2xc[j]-1].redt = phdetect[0].rtime;
								dcdata->fd->slg[v2xc[j]-1].allrt = 0;
                        	}
                        	else
                        	{
                            	dcdata->fd->slg[v2xc[j]-1].greent = phdetect[i+1].gtime + phdetect[i+1].gftime;
                                dcdata->fd->slg[v2xc[j]-1].yellowt = phdetect[i+1].ytime;
                                dcdata->fd->slg[v2xc[j]-1].redt = phdetect[i+1].rtime;
                                dcdata->fd->slg[v2xc[j]-1].allrt = 0;
                        	}
						}
					}
					#endif

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}

					tchans = 0;
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == (pinfo->cchan[j]))
							break;
						tchans |= (0x00000001 << ((pinfo->cchan[j]) - 1));
					}	
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x02;
					downti[6] = pinfo->gftime + *(dcdata->fd->halfdownt);

					#ifdef V2X_DEBUG
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->cchan[j])
							break;
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
							dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x17;
							dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
							dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x16;

							dcdata->fd->slg[pinfo->cchan[j]-1].greent = pinfo->mingtime + pinfo->gftime;
							dcdata->fd->slg[pinfo->cchan[j]-1].yellowt = pinfo->ytime;
							dcdata->fd->slg[pinfo->cchan[j]-1].redt = pinfo->rtime;
							dcdata->fd->slg[pinfo->cchan[j]-1].allrt = 0;
						}
					}
					#endif

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11	
			}//if (*(dcdata->fd->auxfunc) & 0x01)	
		//	#endif

			if(0 != currentquenuechannel[0])
			{
				unsigned char q,w,e = 0;
				unsigned char flag = 0;
				memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
				for(q = 0;q<MAX_CHANNEL;q++)
				{
					if(0 == pinfo->cchan[q])
					{
						break;
					}
					for(w = 0;w<MAX_CHANNEL;w++)
					{
						if(0 == currentquenuechannel[w])
						{
							break;
						}
						if(pinfo->cchan[q] == currentquenuechannel[w])
						{
							flag = 0;
							break;
						}
						flag = 1;
					}
					if(flag)
					{
						yellowtoredchannel[e] = pinfo->cchan[q];
						e++;
					}
					flag = 0;
				}
			}
			else
			{
				memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
				memcpy(yellowtoredchannel,pinfo->cchan,sizeof(yellowtoredchannel));
			}

//			if(pinfo->gftime > 0)
//			{
//				
//			}
//			else
//			{
//				memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
//				memcpy(yellowtoredchannel,pinfo->cnpchan,sizeof(yellowtoredchannel));
//			}

			//added on 20220620
			adaptd.phi[ni].pfactt = adaptd.phi[ni].paddt + pinfo->mingtime + pinfo->gftime + pinfo->ytime + pinfo->rtime;
			if (*(dcdata->fd->auxfunc) & 0x01)
				adaptd.phi[ni].pfactt += *(dcdata->fd->halfdownt);
			//end add
			
			//green flash
			if ((0 != pinfo->cchan[0]) && (pinfo->gftime > 0))
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->gftime;	
			//		#ifdef FULL_DOWN_TIME
					if (*(dcdata->fd->auxfunc) & 0x01)
						sinfo.time += *(dcdata->fd->halfdownt);
			//		#endif
					sinfo.color = 0x03;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
           				if (0 == yellowtoredchannel[i])
               				break;
           				for (j = 0; j < sinfo.chans; j++)
           				{
               				if (0 == sinfo.csta[j])
               					break;
               				tcsta = sinfo.csta[j];
               				tcsta &= 0xfc;
               				tcsta >>= 2;
               				tcsta &= 0x3f;
               				if (tcsta == yellowtoredchannel[i])
               				{
                   				sinfo.csta[j] &= 0xfc;
								sinfo.csta[j] |= 0x03;
								break;
               				}
            			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
		
	//		#ifdef FULL_DOWN_TIME
			if ((*(dcdata->fd->auxfunc) & 0x01) && (0 == ffw))
				sleep(*(dcdata->fd->halfdownt));
	//		#endif

			if (1 == dcpcyes)
            {
                pthread_cancel(dcpcid);
                pthread_join(dcpcid,NULL);
                dcpcyes = 0;
            }

			memset(&gtime,0,sizeof(gtime));
            memset(&gftime,0,sizeof(gftime));
			gettimeofday(&gftime,NULL);
            memset(&ytime,0,sizeof(ytime));
            memset(&rtime,0,sizeof(rtime));
			*(dcdata->fd->markbit) |= 0x0400;
			
			if (pinfo->gftime > 0)
			{
				num = 0;
				while (1)
				{
					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),yellowtoredchannel,0x02))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						*(dcdata->fd->markbit) |= 0x0800;
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x02, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),yellowtoredchannel,0x03))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
						*(dcdata->fd->markbit) |= 0x0800;
						gettimeofday(&ct,NULL);
						update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
						if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x03, \
														dcdata->fd->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					timeout.tv_sec = 0;
					timeout.tv_usec = 500000;
					select(0,NULL,NULL,NULL,&timeout);

					num += 1;
					if (num >= (pinfo->gftime))
						break;
				}
			}//if (pinfo->gftime > 0)
			//end green flash
			if (1 == phcon)
            {
                *(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			#ifdef RED_FLASH	
			if (0 == dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].StageId)
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][0].SpecFunc & 0xe0) >> 5;
			}
			else
			{
				rft = (dcdata->td->timeconfig->TimeConfigList[tcline][slnum+1].SpecFunc & 0xe0) >> 5;
			}
			if (rft > 0)
			{
				redflash_dc		dc;
				dc.tcline = tcline;
				dc.slnum = slnum;
				dc.snum =	snum;
				dc.rft = rft;
				dc.chan = pinfo->chan;
				dc.dc = dcdata;
				int rfarg = pthread_create(&rfpid,NULL,(void *)ms_red_flash,&dc);
				if (0 != rfarg)
				{
				#ifdef FULL_DETECT_DEBUG
					printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
					return;
				}
			}//if (rft > 0) 
			#endif

			roaddata = *(dcdata->fd->roadinfo);
			gettimeofday(&ct,NULL);
			currenttime = ct.tv_sec;
			receiveroadtime =  *(dcdata->fd->roadinforeceivetime);
			
			if(0 != currentquenuechannel[0])
			{
				unsigned char q,w,e = 0;
				unsigned char flag = 0;
				memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
				for(q = 0;q<MAX_CHANNEL;q++)
				{
					if(0 == pinfo->cchan[q])
					{
						break;
					}
					for(w = 0;w<MAX_CHANNEL;w++)
					{
						if(0 == currentquenuechannel[w])
						{
							break;
						}
						if(pinfo->cnpchan[q] == currentquenuechannel[w])
						{
							flag = 0;
							break;
						}
						flag = 1;
					}
					if(flag)
					{
						yellowtoredchannel[e] = pinfo->cnpchan[q];
						e++;
					}
					flag = 0;
				}
			}
			else
			{
				memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
				memcpy(yellowtoredchannel,pinfo->cnpchan,sizeof(yellowtoredchannel));
			}
			//yellow lamp//黄灯处理
			if (1 == (pinfo->cpcexist))
            {
                if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cpchan,0x00))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
					*(dcdata->fd->markbit) |= 0x0800;
                }
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cpchan,0x00, \
                                                    dcdata->fd->markbit))
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}

//				#ifdef debug
//				printf("currentquenuechannel,File: %s,Line: %d\n",__FILE__,__LINE__);
//	
//				for(i=0;i<sizeof(currentquenuechannel);i++)
//				{
//					if(0 == currentquenuechannel[i])
//					{
//						break;
//					}
//					printf("%02x ",currentquenuechannel[i]);
//				}
//				printf("\n");
//				#endif

//				unsigned char q,w,e = 0;

				
//				if(0 != currentquenuechannel[0])
//				{
//					unsigned char flag = 0;
//					memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
//					for(q = 0;q<MAX_CHANNEL;q++)
//					{
//						if(0 == pinfo->cnpchan[q])
//						{
//							break;
//						}
//						for(w = 0;w<MAX_CHANNEL;w++)
//						{
//							if(0 == currentquenuechannel[w])
//							{
//								break;
//							}
//							if(pinfo->cnpchan[q] == currentquenuechannel[w])
//							{
//								flag = 0;
//								break;
//							}
//							flag = 1;
//						}
//						if(flag)
//						{
//							yellowtoredchannel[e] = pinfo->cnpchan[q];
//							e++;
//						}
//						flag = 0;
//					}
//				}
//				else
//				{
//					memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
//					memcpy(yellowtoredchannel,pinfo->cnpchan,sizeof(yellowtoredchannel));
//				}
				
                if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),yellowtoredchannel,0x01))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
					*(dcdata->fd->markbit) |= 0x0800;
                }
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x01, \
                                                    dcdata->fd->markbit))
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}

            }
            else
            {
//            	unsigned char q,w,e = 0;
//				if(0 != currentquenuechannel[0])
//				{
//					unsigned char flag = 0;
//					memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
//					for(q = 0;q<MAX_CHANNEL;q++)
//					{
//						if(0 == pinfo->cchan[q])
//						{
//							break;
//						}
//						for(w = 0;w<MAX_CHANNEL;w++)
//						{
//							if(0 == currentquenuechannel[w])
//							{
//								break;
//							}
//							if(pinfo->cchan[q] == currentquenuechannel[w])
//							{
//								flag = 0;
//								break;
//							}
//							flag = 1;
//						}
//						if(flag)
//						{
//							yellowtoredchannel[e] = pinfo->cchan[q];
//							e++;
//						}
//						flag = 0;
//					}
//				}
//				else
//				{
//					memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
//					memcpy(yellowtoredchannel,pinfo->cchan,sizeof(yellowtoredchannel));
//				}

				
                if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),yellowtoredchannel,0x01))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
														dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
					*(dcdata->fd->markbit) |= 0x0800;
                }
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,yellowtoredchannel,0x01, \
                                                    dcdata->fd->markbit))
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
													
            }
			
	//		#ifdef FULL_DOWN_TIME
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) |= 0x01;//V2X
					tchans = 0;
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == (pinfo->cnpchan[j]))
							break;
						tchans |= (0x00000001 << ((pinfo->cnpchan[j]) - 1));
					}
					downti[1] = 0;
					downti[1] |= (tchans & 0x000000ff);
					downti[2] = 0;
					downti[2] |= (((tchans & 0x0000ff00) >> 8) & 0x000000ff);
					downti[3] = 0;
					downti[3] |= (((tchans & 0x00ff0000) >> 16) & 0x000000ff);
					downti[4] = 0;
					downti[4] |= (((tchans & 0xff000000) >> 24) & 0x000000ff);	
					downti[5] = 0x01;
					downti[6] = pinfo->ytime;

					#ifdef V2X_DEBUG
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->cchan[j])
							break;
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
							dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x16;
							dcdata->fd->slg[pinfo->cchan[j]-1].countdown = downti[6] + 1;
							dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x15;
						}
					}
					#endif	

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11
			}//if (*(dcdata->fd->auxfunc) & 0x01)		
		//	#endif


			*(dcdata->fd->color) = 0x01;
			memset(&gtime,0,sizeof(gtime));
            memset(&gftime,0,sizeof(gftime));
            memset(&ytime,0,sizeof(ytime));
			gettimeofday(&ytime,NULL);
            memset(&rtime,0,sizeof(rtime));

			if ((0 != pinfo->cchan[0]) && (pinfo->ytime > 0))
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->ytime;	
					sinfo.color = 0x01;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
            			if (0 == pinfo->cnpchan[i])
               				break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
               				if (0 == sinfo.csta[j])
               					break;
               				tcsta = sinfo.csta[j];
               				tcsta &= 0xfc;
               				tcsta >>= 2;
               				tcsta &= 0x3f;
               				if (tcsta == pinfo->cnpchan[i])
               				{
                   				sinfo.csta[j] &= 0xfc;
								sinfo.csta[j] |= 0x01;
								break;
               				}
               			}
            		}
					for (i = 0; i < MAX_CHANNEL; i++)
               		{
               			if (0 == pinfo->cpchan[i])
                   			break;
               			for (j = 0; j < sinfo.chans; j++)
               			{
                   			if (0 == sinfo.csta[j])
                       			break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cpchan[i])
                   			{
                       			sinfo.csta[j] &= 0xfc;
								break;
                   			}
               			}
              		}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t)); 
					memset(sibuf,0,sizeof(sibuf));
            		if (SUCCESS != status_info_report(sibuf,&sinfo))
            		{
            		#ifdef FULL_DETECT_DEBUG
               			printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
               			write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}

			if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
            {
                memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x01;
                timedown.lamptime = pinfo->ytime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;
                if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                #endif
                }
            }
			#ifdef EMBED_CONFIGURE_TOOL
			if (*(dcdata->fd->markbit2) & 0x0200)
			{
				memset(&timedown,0,sizeof(timedown));
                timedown.mode = *(dcdata->fd->contmode);
                timedown.pattern = *(dcdata->fd->patternid);
                timedown.lampcolor = 0x01;
                timedown.lamptime = pinfo->ytime;
                timedown.phaseid = pinfo->phaseid;
                timedown.stageline = pinfo->stageline;	
				if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
				{
				#ifdef FULL_DETECT_DEBUG
					printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
				#endif
				}
			}
			#endif

			//send info to face board
			if (*(dcdata->fd->contmode) < 27)
                fbdata[1] = *(dcdata->fd->contmode) + 1;
            else
                fbdata[1] = *(dcdata->fd->contmode);
			if ((30 == fbdata[1]) || (31 == fbdata[1]))
            {
                fbdata[2] = 0;
                fbdata[3] = 0;
                fbdata[4] = 0;
            }
            else
			{
				fbdata[2] = pinfo->stageline;
            	fbdata[3] = 0x01;
            	fbdata[4] = pinfo->ytime;
			}
            if (!wait_write_serial(*(dcdata->fd->fbserial)))
            {
                if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
					*(dcdata->fd->markbit) |= 0x0800;
                    gettimeofday(&ct,NULL);
                    update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
            }
            else
            {
            #ifdef FULL_DETECT_DEBUG
                printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			sendfaceInfoToBoard(dcdata->fd,fbdata);
            sleep(pinfo->ytime);
			//end yellow lamp
			
			//red lamp
			if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->cchan,0x00))
			{
				#ifdef FULL_DETECT_DEBUG
					printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
				#endif
				gettimeofday(&ct,NULL);
                update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
                if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
													dcdata->fd->softevent,dcdata->fd->markbit))
                {
                #ifdef FULL_DETECT_DEBUG
                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                #endif
                }
				*(dcdata->fd->markbit) |= 0x0800;
			}
			if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->cchan,0x00, \
                                                    dcdata->fd->markbit))
            {
            #ifdef FULL_DETECT_DEBUG
                printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
            #endif
            }
			*(dcdata->fd->color) = 0x00;
			if (0 != pinfo->cchan[0])
			{
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					sinfo.time = pinfo->rtime;	
					sinfo.color = 0x00;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					for (i = 0; i < MAX_CHANNEL; i++)
           			{
           				if (0 == pinfo->cchan[i])
              				break;
           				for (j = 0; j < sinfo.chans; j++)
           				{
               				if (0 == sinfo.csta[j])
               					break;
                   			tcsta = sinfo.csta[j];
                   			tcsta &= 0xfc;
                   			tcsta >>= 2;
                   			tcsta &= 0x3f;
                   			if (tcsta == pinfo->cchan[i])
                   			{
                   				sinfo.csta[j] &= 0xfc;
								break;
                   			}
               			}
           			}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));	
					memset(sibuf,0,sizeof(sibuf));
           			if (SUCCESS != status_info_report(sibuf,&sinfo))
           			{
           			#ifdef FULL_DETECT_DEBUG
                		printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            		#endif
            		}
            		else
            		{
                		write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
            		}	
				}//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
			}
	
			if (*(dcdata->fd->auxfunc) & 0x01)
			{//if (*(dcdata->fd->auxfunc) & 0x01)
				if ((30 != *(dcdata->fd->contmode)) && (31 != *(dcdata->fd->contmode)))
				{//11
					*(dcdata->fd->v2xmark) &= 0xfe;//V2X
					downti[5] = 0x00;
					downti[6] = pinfo->rtime;

					#ifdef V2X_DEBUG
					for (j = 0; j < MAX_CHANNEL; j++)
					{
						if (0 == pinfo->cchan[j])
							break;
						if ((pinfo->cchan[j] < 13) || (pinfo->cchan[j] > 16))
						{
							dcdata->fd->slg[pinfo->cchan[j]-1].slgid = pinfo->cchan[j];
							dcdata->fd->slg[pinfo->cchan[j]-1].slgstatus = 0x15;
							dcdata->fd->slg[pinfo->cchan[j]-1].countdown = 0xff;
							dcdata->fd->slg[pinfo->cchan[j]-1].nslgstatus = 0x17;

							dcdata->fd->slg[pinfo->cchan[j]-1].greent = 0;
                            dcdata->fd->slg[pinfo->cchan[j]-1].yellowt = 0;
                            dcdata->fd->slg[pinfo->cchan[j]-1].redt = 0;
                            dcdata->fd->slg[pinfo->cchan[j]-1].allrt = 0;
						}
					}
					#endif	

					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),downti,sizeof(downti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
					if (!wait_write_serial(*(dcdata->fd->bbserial)))
					{
						if (write(*(dcdata->fd->bbserial),edownti,sizeof(edownti)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}
				}//11
			}//if (*(dcdata->fd->auxfunc) & 0x01)		
			if ((pinfo->rtime) > 0)
            {
				memset(&gtime,0,sizeof(gtime));
            	memset(&gftime,0,sizeof(gftime));
            	memset(&ytime,0,sizeof(ytime));
            	memset(&rtime,0,sizeof(rtime));
            	gettimeofday(&rtime,NULL);

				if ((*(dcdata->fd->markbit) & 0x0002) && (*(dcdata->fd->markbit) & 0x0010))
                {
                    memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x00;
                    timedown.lamptime = pinfo->rtime;
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;
                    if (SUCCESS != timedown_data_to_conftool(dcdata->fd->sockfd,&timedown))
                    {
                    #ifdef FULL_DETECT_DEBUG
                        printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                    #endif
                    }
                }
				#ifdef EMBED_CONFIGURE_TOOL
				if (*(dcdata->fd->markbit2) & 0x0200)
				{
					memset(&timedown,0,sizeof(timedown));
                    timedown.mode = *(dcdata->fd->contmode);
                    timedown.pattern = *(dcdata->fd->patternid);
                    timedown.lampcolor = 0x00;
                    timedown.lamptime = pinfo->rtime;
                    timedown.phaseid = pinfo->phaseid;
                    timedown.stageline = pinfo->stageline;	
					if (SUCCESS != timedown_data_to_embed(dcdata->fd->sockfd,&timedown))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
					}
				}
				#endif
				//send info to face board
				if (*(dcdata->fd->contmode) < 27)
                	fbdata[1] = *(dcdata->fd->contmode) + 1;
            	else
                	fbdata[1] = *(dcdata->fd->contmode);
				if ((30 == fbdata[1]) || (31 == fbdata[1]))
                {
                    fbdata[2] = 0;
                    fbdata[3] = 0;
                    fbdata[4] = 0;
                }
                else
				{
					fbdata[2] = pinfo->stageline;
            		fbdata[3] = 0x00;
            		fbdata[4] = pinfo->rtime;
				}
            	if (!wait_write_serial(*(dcdata->fd->fbserial)))
            	{
                	if (write(*(dcdata->fd->fbserial),fbdata,sizeof(fbdata)) < 0)
                	{
                	#ifdef FULL_DETECT_DEBUG
                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                	#endif
						*(dcdata->fd->markbit) |= 0x0800;
                    	gettimeofday(&ct,NULL);
                    	update_event_list(dcdata->fd->ec,dcdata->fd->el,1,16,ct.tv_sec,dcdata->fd->markbit);
                    	if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el,\
															dcdata->fd->softevent,dcdata->fd->markbit))
                    	{
                    	#ifdef FULL_DETECT_DEBUG
                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                    	#endif
                    	}
                	}
            	}
            	else
            	{
            	#ifdef FULL_DETECT_DEBUG
                	printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
            	#endif
            	}
				sendfaceInfoToBoard(dcdata->fd,fbdata);
				sleep(pinfo->rtime);
			}
			//end red lamp

			gettimeofday(&ct,NULL);
			adaptd.phi[ni].phaseendtime = ct.tv_sec;

			
			//相位结束处理行人滞留问题
			//其他相位
			roadbit = 0;
			isperdelay  = 0;
			i =0;
			rcnum = 0;
			lcnum = 0;

			if((currenttime - receiveroadtime) > 2)
			{
				roaddata = 0;
			}
			memset(pinfo->roadbit,0,sizeof(pinfo->roadbit));
			memset(allchannel,0,sizeof(allchannel));
			memset(pinfo->roaddelaychan,0,sizeof(pinfo->roaddelaychan));
			for(roadbit = 4;roadbit < 12; roadbit++)
			{
				if((roaddata >> roadbit) & 0x00000001)
				{
						if(8==roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(13 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}
							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit+1;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("weizhi 9\n");
							#endif
						}
						else if(9 == roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(16 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}
							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit +1;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("weizhi 10\n");
							#endif
						}
						else if(10 == roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(15 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}
							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit +1;
							rcnum++;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("weizhi 11\n");
							#endif
						}
						else if(11 == roadbit)
						{
							unsigned char flag = 0;
							for(i = 0;i<MAX_CHANNEL;i++)
							{
								if(0 == pinfo->chan[i])
								{
									break;
								}
								if(14 == pinfo->chan[i])
								{
									flag = 1;
									break;
								}
							}
							if(flag == 0)
							{
								continue;
							}
							isperdelay = 1;
							pinfo->roadbit[lcnum] = roadbit +1;
							lcnum++;
							#ifdef ROADINFO_DEBUG
							printf("weizhi 12\n");
							#endif
						}				
						
				}
			}
			if(1 == isperdelay)
			{

				reporttoedger(*(dcdata->fd->sockfd->edgersockd),pinfo->roadbit);
			
				isperdelay = 0;	
				roadreport[0] = 0x21;
				roadreport[1] = 0x85;
				roadreport[2] = 0xFB;
				roadreport[3] = 0x00;
				roadreport[4] = 0x00;
				roadreport[5] = 0x00;
				roadreport[6] = 0x00;
				roadreport[7] = 0x00;
				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->roadbit[i])
					{
						break;
					}
					if( 9 == pinfo->roadbit[i])
					{
						roadreport[6] |= 0x01;
						roadreport[7] |= 0x00;
					}
					else if(10== pinfo->roadbit[i])
					{
						roadreport[6] |= 0x02;
						roadreport[7] |= 0x00;
					}
					else if(11== pinfo->roadbit[i])
					{
						roadreport[6] |= 0x04;
						roadreport[7] |= 0x00;
					}
					else if(12== pinfo->roadbit[i])
					{
						roadreport[6] |= 0x08;
						roadreport[7] |= 0x00;
					}
							
				}
				write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
				#ifdef ROADINFO_DEBUG_1
				printf("delaye phase roadreport:");
				for(i=0;i<sizeof(roadreport);i++)
				{
					printf("%02x ",roadreport[i]);
				}
				printf("\n");
				#endif
				z = 0;		
 				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->chan[i])
					{
						break;
					}
					if(13 == pinfo->chan[i])
					{

						continue;
					}
					if(14 == pinfo->chan[i])
					{
						continue;
					}
					if(15 == pinfo->chan[i])
					{
						continue;
					}
					if(16 == pinfo->chan[i])
					{
						continue;
					}
					pinfo->roaddelaychan[z] = pinfo->chan[i];
					z++;
										
				}

				//行人清空黄灯处理
				/*if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),personchannelred,0x00))
				{
					#ifdef ROADINFO_DEBUG
					printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
						#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
					}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,personchannelred,0x00, \
																	dcdata->fd->markbit))
				{
					#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
				}


				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),pinfo->roaddelaychan,0x01))
				{
					#ifdef ROADINFO_DEBUG
					printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
						#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
					}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,pinfo->roaddelaychan,0x01, \
																	dcdata->fd->markbit))
				{
					#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
				}



				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					
					sinfo.color = 0x06;
					sinfo.time = 3;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
					memset(sinfo.csta,0,sizeof(sinfo.csta));
					csta = sinfo.csta;
					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == personchannelred[i])
							break;
						sinfo.chans += 1;
						tcsta = personchannelred[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x00;
						*csta = tcsta;
						csta++;
					}

					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == pinfo->roaddelaychan[i])
							break;
						sinfo.chans += 1;
						tcsta = pinfo->roaddelaychan[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x01;
						*csta = tcsta;
						csta++;
					}
					
					
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
					if (SUCCESS != status_info_report(sibuf,&sinfo))
					{
							#ifdef ROADINFO_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
					}
					else
					{
						write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
					}
				}
				
				sleep(3);
				20221102 edit 取消这里三秒黄灯
				*/
				//黄灯结束，红灯开始
				unsigned char notrightchanngle[MAX_CHANNEL]={0};
				z =0;
				rcnum = 0;
				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->roaddelaychan[i])
					{
						break;
					}
					if(9 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(9 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 9;
								rcnum++;
								break;
							}
						}
						continue;
					}
					else if(10 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(10 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 10;
								rcnum++;
								break;
							}
						}
						continue;
					}
					else if(11 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(11 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 11;
								rcnum++;
								break;
							}
						}

						continue;
					}
					else if(12 == pinfo->roaddelaychan[i])
					{
						for(z = 0;z<MAX_CHANNEL;z++)
						{
							if(0 == yellowtoredchannel[z])
							{
								break;
							}
							if(12 == yellowtoredchannel[z])
							{
								notrightchanngle[rcnum] = 12;
								rcnum++;
								break;
							}
						}						
						continue;
					}
					else
					{
						notrightchanngle[rcnum] = pinfo->roaddelaychan[i];
						rcnum++;
					}
					
										
				}
				if (SUCCESS != ms_set_lamp_color(*(dcdata->fd->bbserial),notrightchanngle,0x00))
				{
					#ifdef ROADINFO_DEBUG
					printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					gettimeofday(&ct,NULL);
					update_event_list(dcdata->fd->ec,dcdata->fd->el,1,15,ct.tv_sec,dcdata->fd->markbit);
					if (SUCCESS != generate_event_file(dcdata->fd->ec,dcdata->fd->el, \
														dcdata->fd->softevent,dcdata->fd->markbit))
					{
						#ifdef ROADINFO_DEBUG
						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
					}
					*(dcdata->fd->markbit) |= 0x0800;
				}
				
				if (SUCCESS != update_channel_status(dcdata->fd->sockfd,dcdata->cs,notrightchanngle,0x00, \
																	dcdata->fd->markbit))
				{
					#ifdef ROADINFO_DEBUG
					printf("update chan err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
				}
				if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
				{//if ((!(*(dcdata->fd->markbit) & 0x1000)) && (!(*(dcdata->fd->markbit) & 0x8000)))
					
					sinfo.color = 0x00;
					sinfo.time = 3;
					sinfo.conmode = *(dcdata->fd->contmode);//added on 20150529
					sinfo.chans = 0;
					memset(sinfo.csta,0,sizeof(sinfo.csta));
					csta = sinfo.csta;
					for (i = 0; i < MAX_CHANNEL; i++)
					{
						if (0 == notrightchanngle[i])
							break;
						sinfo.chans += 1;
						tcsta = notrightchanngle[i];
						tcsta <<= 2;
						tcsta &= 0xfc;
						tcsta |= 0x00;
						*csta = tcsta;
						csta++;
					}
					memcpy(dcdata->fd->sinfo,&sinfo,sizeof(statusinfo_t));
					memset(sibuf,0,sizeof(sibuf));
					if (SUCCESS != status_info_report(sibuf,&sinfo))
					{
							#ifdef ROADINFO_DEBUG
							printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
					}
					else
					{
						write(*(dcdata->fd->sockfd->csockfd),sibuf,sizeof(sibuf));
					}
				}

				sleep(3);
				roadreport[4] = 0xff;
				roadreport[5] = 0xff;
				roadreport[6] = 0xff;
				roadreport[7] = 0xff;
				for(i=0;i<MAX_CHANNEL;i++)
				{
					if(0 == pinfo->roadbit[i])
					{
						break;
					}
					if( 9 == pinfo->roadbit[i])
					{
						roadreport[7] = 0xff;
						roadreport[6] = 0xfe;
					}
					else if(10== pinfo->roadbit[i])
					{
						roadreport[6] &= 0xfd;
						roadreport[7] &= 0xff;
					}
					else if(11== pinfo->roadbit[i])
					{
						roadreport[6] &= 0xfb;
						roadreport[7] &= 0xff;
					}
					else if(12== pinfo->roadbit[i])
					{
						roadreport[6] &= 0xf7;
						roadreport[7] &=  0xff;
					}
							
				}
				write(*(dcdata->fd->sockfd->csockfd),roadreport,sizeof(roadreport));
				*(dcdata->fd->roadinfo) = 0;
				#ifdef ROADINFO_DEBUG
				printf("end delaye phase roadreport:");
				for(i=0;i<sizeof(roadreport);i++)
				{
					printf("%02x ",roadreport[i]);
				}
				printf("\n");
				#endif
			}
			//相位结束处理行人滞留问题
			isreport = 0;
			
			memcpy(lastphasechannel,pinfo->chan,sizeof(lastphasechannel));
			ni += 1;
			slnum += 1;
			*(dcdata->fd->slnum) = slnum;
			*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			if (0 == (dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId))
			{
				cycarr = 1;
				slnum = 0;
				*(dcdata->fd->slnum) = 0;
				*(dcdata->fd->stageid) = dcdata->td->timeconfig->TimeConfigList[tcline][slnum].StageId;
			}
			#ifdef RED_FLASH
            if (rft > (pinfo->ytime + pinfo->rtime))
            {
                sleep(rft - (pinfo->ytime) - (pinfo->rtime));
            }
            #endif
			if (1 == phcon)
            {
				*(dcdata->fd->markbit) &= 0xfbff;
                memset(&gtime,0,sizeof(gtime));
                gettimeofday(&gtime,NULL);
                memset(&gftime,0,sizeof(gftime));
                memset(&ytime,0,sizeof(ytime));
                memset(&rtime,0,sizeof(rtime));
                phcon = 0;
                sleep(10);
            }
			continue;
		}//other type phases, for example,flexible phase
	}//while loop

	pthread_exit(NULL);
}

/*color: 0x00 means red,0x01 means yellow,0x02 means green,0x12 means green flash*/
int get_ms_status(unsigned char *color,unsigned char *leatime)
{
	if ((NULL == color) || (NULL == leatime))
	{
	#ifdef FULL_DETECT_DEBUG
		printf("pointer address is null,File: %s,Line: %d\n",__FILE__,__LINE__);
		output_log("Detect control,pointer address is null");
	#endif
		return MEMERR;
	}

	struct timeval			ntime;
	memset(&ntime,0,sizeof(ntime));
	gettimeofday(&ntime,NULL);
	if (0 != rtime.tv_sec)
	{
		*color = 0x00;
		*leatime = ntime.tv_sec - rtime.tv_sec;
	}
	if (0 != ytime.tv_sec)
	{
		*color = 0x01;
		*leatime = ntime.tv_sec - ytime.tv_sec;
	}
	if (0 != gftime.tv_sec)
	{
		*color = 0x12;
		*leatime = ntime.tv_sec - gftime.tv_sec;
	}
	if (0 != gtime.tv_sec)
	{
		*color = 0x02;
		*leatime = ntime.tv_sec - gtime.tv_sec;
	}

	return SUCCESS;
}

int major_salve_detect_control(fcdata_t *fcdata, tscdata_t *tscdata,ChannelStatus_t *chanstatus)
{
	if ((NULL == fcdata) || (NULL == tscdata) || (NULL == chanstatus))
	{
	#ifdef FULL_DETECT_DEBUG
		printf("Pointer address is NULL,File: %s,Line: %d\n",__FILE__,__LINE__);
		output_log("major_salve_detect_control,pointer address is null");
	#endif
		return MEMERR;
	}

	//initial static variable
	dcyes = 0;
	dcpcyes = 0;
	ppmyes = 0;
	dcyfyes = 0;
	cpdyes = 0;
	delaypcyes = 0;
	memset(&gtime,0,sizeof(gtime));
	memset(&gftime,0,sizeof(gftime));
	memset(&ytime,0,sizeof(ytime));
	memset(&rtime,0,sizeof(rtime));
	phcon = 0;
	rettl = 0;
	degrade = 0;
	//安慧全息路口
	iscarquenueonerflow = 0;
	istrafficlock = 0;
	isreport = 0;
	
	memset(currentquenuechannel,0,sizeof(currentquenuechannel));
	memset(yellowtoredchannel,0,sizeof(yellowtoredchannel));
	memset(lastphasechannel,0,sizeof(lastphasechannel));
	memset(lastquenuelocation,0,sizeof(lastquenuelocation));
	memset(persiondelaychannel,0,sizeof(persiondelaychannel));
	memset(currentquenuelocation,0,sizeof(currentquenuelocation));





	
	//安慧全息路口
	memset(fcdata->sinfo,0,sizeof(statusinfo_t));
	//end initial static variable

	dcdata_t					dcdata;
	dcpinfo_t					pinfo;
	unsigned char				contmode = *(fcdata->contmode);//save control mode
	if (0 == dcyes)
	{
		memset(&dcdata,0,sizeof(dcdata));
		memset(&pinfo,0,sizeof(pinfo));
		dcdata.fd = fcdata;
		dcdata.td = tscdata;
		dcdata.pi = &pinfo;
		dcdata.cs = chanstatus;
		int dcret = pthread_create(&dcpid,NULL,(void *)start_major_salve_control,&dcdata);
		if (0 != dcret)
		{
		#ifdef FULL_DETECT_DEBUG
			printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
			output_log("major_salve_detect_control,create major salve detect thread err");
		#endif
			return FAIL;
		}
		dcyes = 1;
	}

	sleep(1);

	unsigned char			rpc = 0; //running phase
	unsigned int			rpi = 0;//running phase
	unsigned char           netlock = 0;//network lock,'1'means lock,'0' means unlock
	unsigned char           close = 0;//'1' means lamps have been status of all close;
	unsigned char			cc[32] = {0};//channels of current phase;
	unsigned char			nc[32] = {0};//channels of next phase;
	unsigned char			wcc[32] = {0};//channels of will change;
	unsigned char			wnpcc[32] = {0};//not person channels of will change
	unsigned char			wpcc[32] = {0};//person channels of will change
	unsigned char			fpc = 0;//first phase control
	unsigned char			cp = 0;//current phase
	unsigned char			*pcc = NULL;
	unsigned char			ce = 0;//channel exist
	unsigned char			pce = 0;//person channel exist
	unsigned char			pex = 0;//phase exist in phase list
	unsigned char			i = 0, j = 0,z = 0,k = 0,s = 0;
	unsigned short			factovs = 0;
	unsigned char			cbuf[1024] = {0};
	infotype_t				itype;
	memset(&itype,0,sizeof(itype));
	itype.highbit = 0x01;
	itype.objectn = 0;
	itype.opertype = 0x05;
	objectinfo_t			objecti[8] = {0};
	objecti[0].objectid = 0xD4;
	objecti[0].objects = 1;
	objecti[0].indexn = 0;
	objecti[0].cobject = 0;
	objecti[0].cobjects = 0;
	objecti[0].index[0] = 0;
	objecti[0].index[1] = 0;
	objecti[0].index[2] = 0;
	objecti[0].objectvs = 1;
	yfdata_t				acdata;
	memset(&acdata,0,sizeof(acdata));
	acdata.second = 0;
	acdata.markbit = fcdata->markbit;
	acdata.markbit2 = fcdata->markbit2;
	acdata.serial = *(fcdata->bbserial);
	acdata.sockfd = fcdata->sockfd;
	acdata.cs = chanstatus;
	
	unsigned char           dcdownti[8] = {0xA6,0xff,0xff,0xff,0xff,0x03,0,0xED};
    unsigned char           dcedownti[3] = {0xA5,0xA5,0xED};
	fd_set					nread;
	unsigned char			keylock = 0;//key lock or unlock
	unsigned char			wllock = 0;//wireless terminal lock or unlock
	unsigned char			tcbuf[32] = {0};
	unsigned char			color = 3; //lamp is default closed;
	unsigned char			leatime = 0;
	unsigned char			dcred = 0; //'1' means lamp has been status of all red
	timedown_t				dctd;
	unsigned char			ngf = 0;
	struct timeval			to,ct;
//	struct timeval			wut;
	struct timeval			mont,ltime;
	yfdata_t				yfdata;//data of yellow flash
	yfdata_t				ardata;//data of all red
	unsigned char           fbdata[6] = {0};
	fbdata[0] = 0xC1;
	fbdata[5] = 0xED;
	unsigned char			dcecho[3] = {0};//send traffic control info to face board;
	dcecho[0] = 0xCA;
	dcecho[2] = 0xED;
	memset(&ardata,0,sizeof(ardata));
	ardata.second = 0;
	ardata.markbit = fcdata->markbit;
	ardata.markbit2 = fcdata->markbit2;
	ardata.serial = *(fcdata->bbserial);
	ardata.sockfd = fcdata->sockfd;
	ardata.cs = chanstatus;	

	unsigned char               sibuf[64] = {0};
//	statusinfo_t                sinfo;
//    memset(&sinfo,0,sizeof(statusinfo_t));
	unsigned char               *csta = NULL;
    unsigned char               tcsta = 0;
    sinfo.pattern = *(fcdata->patternid);
	unsigned char               ncmode = *(fcdata->contmode);

	unsigned char				wtlock = 0;
	struct timeval				wtltime;
	unsigned char				pantn = 0;
	unsigned char           	dirc = 0; //direct control
	unsigned char				kstep = 0;
	unsigned char				cktem = 0;
	//channes of eight direction mapping;
  	//left and right lamp all close
	unsigned char 		dirch1[8][8] = {{1,3,13,15,0,0,0,0},{0,0,0,0,0,0,0,0},
                                    {2,4,14,16,0,0,0,0},{0,0,0,0,0,0,0,0},
                                    {1,13,0,0,0,0,0,0},{2,14,0,0,0,0,0,0},
                                    {3,15,0,0,0,0,0,0},{4,16,0,0,0,0,0,0}};

	unsigned char       lkch1[4][8] = {{1,3,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
                                        {2,4,0,0,0,0,0,0},{0,0,0,0,0,0,0,0}};
	unsigned char		clch1[12] = {5,6,7,8,9,10,11,12,17,18,19,20};
	//only close left lamp
	unsigned char 		dirch2[8][8] = {{1,3,9,11,13,15,0,0},{9,11,0,0,0,0,0,0},
                                      {2,4,14,16,0,0,0,0},{10,12,0,0,0,0,0,0},
                                      {1,9,13,0,0,0,0,0},{2,10,14,0,0,0,0,0},
                                      {3,11,15,0,0,0,0,0},{4,12,16,0,0,0,0,0}};

	unsigned char       lkch2[4][8] = {{1,3,9,11,0,0,0,0},{9,11,0,0,0,0,0,0},
                                        {2,4,10,12,0,0,0,0},{10,12,0,0,0,0,0,0}};
	unsigned char		clch2[12] = {5,6,7,8,17,18,19,20,0,0,0,0};
	//only close right lamp
	unsigned char 		dirch3[8][8] = {{1,3,13,15,0,0,0,0},{5,7,17,19,0,0,0,0},
                                      {2,4,14,16,0,0,0,0},{6,8,18,20,0,0,0,0},
                                      {1,5,13,17,0,0,0,0},{2,6,14,18,0,0,0,0},
                                      {3,7,15,19,0,0,0,0},{4,8,16,20,0,0,0,0}};

	unsigned char       lkch3[4][8] = {{1,3,0,0,0,0,0,0},{5,7,17,19,0,0,0,0},
                                        {2,4,0,0,0,0,0,0},{6,8,18,20,0,0,0,0}};
	unsigned char		clch3[12] = {9,10,11,12,0,0,0,0,0,0,0,0};
	//Not close left and right lamp
	unsigned char		dirch0[8][8] = {{1,3,9,11,13,15,0,0},{5,7,9,11,17,19,0,0},
                                      {2,4,10,12,14,16,0,0},{6,8,10,12,18,20,0,0},
                                      {1,5,9,13,17,0,0,0},{2,6,10,14,18,0,0,0},
                                      {3,7,11,15,19,0,0,0},{4,8,12,16,20,0,0,0}};
	unsigned char       lkch0[4][8] = {{1,3,9,11,0,0,0,0},{5,7,9,11,17,19,0,0},
                                        {2,4,10,12,0,0,0,0},{6,8,10,12,18,20,0,0}};
	unsigned char	dirch[8][8] = {0};
	unsigned char	lkch[4][8] = {0};
	unsigned char	clch[12] = {0};
	#ifdef CLOSE_LAMP
	unsigned char       clch0[12] = {5,6,7,8,9,10,11,12,17,18,19,20};
	z = 0;
	k = 0;
	for (i = 0; i < 8; i++)
	{
		for (j = 0; j < 8; j++)
		{
			//left and right lamp
			if ((dirch0[i][j] >= 5) && (dirch0[i][j] <= 12))
			{
				if (*(fcdata->specfunc) & (0x01 << (dirch0[i][j] - 5)))
					continue;
			}
			//turn round lamp
			if ((dirch0[i][j] >= 17) && (dirch0[i][j] <= 20))
			{
				if (*(fcdata->specfunc) & (0x01 << (dirch0[i][j] - 17)))
					continue;
			}
			dirch[z][k] = dirch0[i][j];
			k++;	
		}
		z++;
		k = 0;
	}
	j = 0;
	for (i = 0; i < 12; i++)
	{
		if ((clch0[i] >= 5) && (clch0[i] <= 12))
		{
			if (*(fcdata->specfunc) & (0x01 << (clch0[i] - 5)))
			{
				clch[j] = clch0[i];
				j++;
			}
		}
		if ((clch0[i] >= 17) && (clch0[i] <= 20))
		{
			if (*(fcdata->specfunc) & (0x01 << (clch0[i] - 17)))
			{
				clch[j] = clch0[i];
				j++;
			}
		}
	}

	z = 0;
    k = 0;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 8; j++)
        {
            //left and right lamp
            if ((lkch0[i][j] >= 5) && (lkch0[i][j] <= 12))
            {
                if (*(fcdata->specfunc) & (0x01 << (lkch0[i][j] - 5)))
                    continue;
            }
            //turn round lamp
            if ((lkch0[i][j] >= 17) && (lkch0[i][j] <= 20))
            {
                if (*(fcdata->specfunc) & (0x01 << (lkch0[i][j] - 17)))
                    continue;
            }
            lkch[z][k] = lkch0[i][j];
            k++;
        }
        z++;
        k = 0;
    }	
	#else
	if ((*(fcdata->specfunc) & 0x10) && (*(fcdata->specfunc) & 0x20))
	{
		for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 8; j++)
			{
				dirch[i][j] = dirch1[i][j];
			}
		}
		for (i = 0; i < 4; i++)
        {
            for (j = 0; j < 8; j++)
            {
                lkch[i][j] = lkch1[i][j];
            }
        }
		for (i = 0; i < 12; i++)
		{
			clch[i] = clch1[i];
		}
	}
	if ((*(fcdata->specfunc) & 0x10) && (!(*(fcdata->specfunc) & 0x20)))
	{
		for (i = 0; i < 8; i++)
        {
            for (j = 0; j < 8; j++)
            {
                dirch[i][j] = dirch2[i][j];
            }
        }
		for (i = 0; i < 4; i++)
        {
            for (j = 0; j < 8; j++)
            {
                lkch[i][j] = lkch2[i][j];
            }
        }
		for (i = 0; i < 12; i++)
		{
			clch[i] = clch2[i];
		}	
	}
	if ((*(fcdata->specfunc) & 0x20) && (!(*(fcdata->specfunc) & 0x10)))
	{
		for (i = 0; i < 8; i++)
        {
            for (j = 0; j < 8; j++)
            {
                dirch[i][j] = dirch3[i][j];
            }
        }
		for (i = 0; i < 4; i++)
        {
            for (j = 0; j < 8; j++)
            {
                lkch[i][j] = lkch3[i][j];
            }
        }
		for (i = 0; i < 12; i++)
        {
            clch[i] = clch3[i];
        }
	}	
	if ((!(*(fcdata->specfunc) & 0x20)) && (!(*(fcdata->specfunc) & 0x10)))
	{
		for (i = 0; i < 8; i++)
		{
			for (j = 0; j < 8; j++)
			{
				dirch[i][j] = dirch0[i][j];
			}
		}
		for (i = 0; i < 4; i++)
		{
			for (j = 0; j < 8; j++)
			{
				lkch[i][j] = lkch0[i][j];
			}
		}
		memset(clch,0,sizeof(clch));
	}
	#endif  

	unsigned char				wltc[10] = {0};
	unsigned char				err[10] = {0};
	unsigned char               wlinfo[13] = {0};
	terminalpp_t                tpp;
    unsigned char               terbuf[11] = {0};
    tpp.head = 0xA9;
    tpp.size = 4;
    tpp.id = *(fcdata->lip);
    tpp.type = 0x04;
    tpp.func[0] = 0;
    tpp.func[1] = 0;
    tpp.func[2] = 0;
    tpp.func[3] = 0;
    tpp.end = 0xED;

	markdata_c					mdt;
	unsigned char               dircon = 0;//mobile direction control
    unsigned char               firdc = 1;//mobile first direction control
    unsigned char               fdirch[MAX_CHANNEL] = {0};//front direction control channel
    unsigned char               fdirn = 0;
    unsigned char               cdirch[MAX_CHANNEL] = {0};//current direction control channel
    unsigned char               cdirn = 0;
	unsigned char				tclc = 0;
	unsigned char				ccon[MAX_CHANNEL] = {0};
	unsigned char               maj_phase = 0;
	while (1)
	{//while loop
		FD_ZERO(&nread);
		FD_SET(*(fcdata->conpipe),&nread);
		int	max = *(fcdata->conpipe);
#if 0
		//for WuXi check
		wut.tv_sec = 0;
		wut.tv_usec = 0;
		gettimeofday(&wut,NULL);
		//end WuXi check
#endif
		wtltime.tv_sec = RFIDT;
		wtltime.tv_usec = 0;
		int cpret = select(max+1,&nread,NULL,NULL,&wtltime);
		if (cpret < 0)
		{
		#ifdef FULL_DETECT_DEBUG
			printf("select call err,File: %s,Line: %d\n",__FILE__,__LINE__);
			output_log("detect control,select call err");
		#endif
			ms_end_part_child_thread();
			return FAIL;
		}
		if (0 == cpret)
		{//time out
			if (*(fcdata->markbit2) & 0x0100)
                continue; //rfid is controlling
			*(fcdata->markbit2) &= 0xfffe;
//			printf("***********************Time out,File: %s,Line: %d\n",__FILE__,__LINE__);
			if (1 == wtlock)
            {//if (1 == wtlock)
            //    pantn += 1;
            //    if (3 == pantn)
            //    {//wireless terminal has disconnected with signaler machine;
//				printf("***********************Time out,File: %s,Line: %d\n",__FILE__,__LINE__);
				if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
				{
					memset(wlinfo,0,sizeof(wlinfo));
					gettimeofday(&ct,NULL);
					if (SUCCESS != wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x20))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
					}
					else
					{
						write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
					}
					update_event_list(fcdata->ec,fcdata->el,1,68,ct.tv_sec,fcdata->markbit);   
				}
				else
				{
					gettimeofday(&ct,NULL);
					update_event_list(fcdata->ec,fcdata->el,1,68,ct.tv_sec,fcdata->markbit);
				}

				wtlock = 0;
				*(fcdata->markbit2) &= 0xfffe;
				dcred = 0;
				close = 0;
				fpc = 0;
				pantn = 0;
				cp = 0;

				if (1 == dcyfyes)
				{
					pthread_cancel(dcyfid);
					pthread_join(dcyfid,NULL);
					dcyfyes = 0;
				}
						
				if ((dirc >= 0x05) && (dirc <= 0x0c))
				{//direct control happen
					rpc = 0;
					rpi = tscdata->timeconfig->TimeConfigList[rettl][0].PhaseId;
					get_phase_id(rpi,&rpc);

					memset(nc,0,sizeof(nc));
					pcc = nc;
					for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
					{
						if (0 == (tscdata->channel->ChannelList[i].ChannelId))
							break;
						if (rpc == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
						{
							#ifdef CLOSE_LAMP
							tclc = tscdata->channel->ChannelList[i].ChannelId;
							if ((tclc >= 0x05) && (tclc <= 0x0c))
							{
								if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
									continue;
							}
							#else
							if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
							{
								tclc = tscdata->channel->ChannelList[i].ChannelId;
								if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
									continue;
							}
							if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
							{
								tclc = tscdata->channel->ChannelList[i].ChannelId;
								if ((5 <= tclc) && (tclc <= 8))
									continue;
							}
							if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
							{
								tclc = tscdata->channel->ChannelList[i].ChannelId;
								if ((9 <= tclc) && (tclc <= 12))
									continue;
							}
							#endif
							*pcc = tscdata->channel->ChannelList[i].ChannelId;
							pcc++;
						}
					}
					memset(wcc,0,sizeof(wcc));
					memset(wnpcc,0,sizeof(wnpcc));
					memset(wpcc,0,sizeof(wpcc));
					z = 0;
					k = 0;
					s = 0;
					pce = 0;
					for (i = 0; i < MAX_CHANNEL; i++)
					{//for (i = 0; i < MAX_CHANNEL; i++)
						if (0 == dirch[dirc-5][i])
							break;
						ce = 0;
						for (j = 0; j < MAX_CHANNEL; j++)
						{//for (j = 0; j < MAX_CHANNEL; j++)
							if (0 == nc[j])
								break;
							if (dirch[dirc-5][i] == nc[j])
							{
								ce = 1;
								break;
							}
						}//for (j = 0; j < MAX_CHANNEL; j++)
						if (0 == ce)
						{
							wcc[z] = dirch[dirc-5][i];
							z++;
							if ((0x0d <= dirch[dirc-5][i]) && (dirch[dirc-5][i] <= 0x10))
							{
								wpcc[k] = dirch[dirc-5][i];
								k++;
								pce = 1;
								continue;
							}
							else
							{
								wnpcc[s] = dirch[dirc-5][i];
								s++;
								continue;
							}		
						}
					}//for (i = 0; i < MAX_CHANNEL; i++)

					if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
					{
						if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
						{
							sinfo.conmode = 28;
							sinfo.color = 0x02;
							sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
							sinfo.stage = 0;
							sinfo.cyclet = 0;
							sinfo.phase = 0;
							sinfo.chans = 0;
							memset(sinfo.csta,0,sizeof(sinfo.csta));
							csta = sinfo.csta;
							for (i = 0; i < MAX_CHANNEL; i++)
							{
								if (0 == dirch[dirc-5][i])
									break;
								sinfo.chans += 1;
								tcsta = dirch[dirc-5][i];
								tcsta <<= 2;
								tcsta &= 0xfc;
								tcsta |= 0x02; //00000010-green 
								*csta = tcsta;
								csta++;
							}
							memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
							if (SUCCESS != status_info_report(sibuf,&sinfo))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
							else
							{
								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
							}
						}
					}//if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
					if ((0 != wcc[0]) && (pinfo.gftime > 0))	
					{			
						if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
						{//report info to server actively
							sinfo.conmode = 28;
							sinfo.color = 0x03;
							sinfo.time = pinfo.gftime;
							sinfo.stage = 0;
							sinfo.cyclet = 0;
							sinfo.phase = 0;
														
							for (i = 0; i < MAX_CHANNEL; i++)
							{
								if (0 == wcc[i])
									break;
								for (j = 0; j < sinfo.chans; j++)
								{
									if (0 == sinfo.csta[j])
										break;
									tcsta = sinfo.csta[j];
									tcsta &= 0xfc;
									tcsta >>= 2;
									tcsta &= 0x3f;
									if (wcc[i] == tcsta)
									{
										sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x03; //00000011-green flash
										break;
									}
								}
							}
							memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
							if (SUCCESS != status_info_report(sibuf,&sinfo))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
							else
							{
								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
							}
						}//report info to server actively
					}//if ((0 != wcc[0]) && (pinfo.gftime > 0))

					//green flash
					if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
					{
						memset(&dctd,0,sizeof(dctd));
						dctd.mode = 28;//traffic control
						dctd.pattern = *(fcdata->patternid);
						dctd.lampcolor = 0x02;
						dctd.lamptime = pinfo.gftime;
						dctd.phaseid = 0;
						dctd.stageline = pinfo.stageline;
						if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
					}
					#ifdef EMBED_CONFIGURE_TOOL
					if (*(fcdata->markbit2) & 0x0200)
					{
						memset(&dctd,0,sizeof(dctd));
                        dctd.mode = 28;//traffic control
                        dctd.pattern = *(fcdata->patternid);
                        dctd.lampcolor = 0x02;
                        dctd.lamptime = pinfo.gftime;
                        dctd.phaseid = 0;
                        dctd.stageline = pinfo.stageline;		
						if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
					}
					#endif
					fbdata[1] = 28;
					fbdata[2] = pinfo.stageline;
					fbdata[3] = 0x02;
					fbdata[4] = pinfo.gftime;
					if (!wait_write_serial(*(fcdata->fbserial)))
					{
						if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							*(fcdata->markbit) |= 0x0800;
							gettimeofday(&ct,NULL);
							update_event_list(fcdata->ec,fcdata->el,1,16, \
													ct.tv_sec,fcdata->markbit);
							if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
														fcdata->softevent,fcdata->markbit))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board serial port cannot write,Line:%d\n",__LINE__);
					#endif
					}
					sendfaceInfoToBoard(fcdata,fbdata);
					if (pinfo.gftime > 0)
					{
						ngf = 0;
						while (1)
						{
							if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
								*(fcdata->markbit) |= 0x0800;
							}
							if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																	wcc,0x03,fcdata->markbit))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
							to.tv_sec = 0;
							to.tv_usec = 500000;
							select(0,NULL,NULL,NULL,&to);
							if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
								*(fcdata->markbit) |= 0x0800;
							}
							if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																		wcc,0x02,fcdata->markbit))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
							to.tv_sec = 0;
							to.tv_usec = 500000;
							select(0,NULL,NULL,NULL,&to);
							
							ngf += 1;
							if (ngf >= pinfo.gftime)
								break;
						}
					}//if (pinfo.gftime > 0)
					if (1 == pce)
					{
					//current phase begin to yellow lamp
						if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							*(fcdata->markbit) |= 0x0800;
						}
						if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																wnpcc,0x01, fcdata->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
						if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							*(fcdata->markbit) |= 0x0800;
						}
						if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																wpcc,0x00,fcdata->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
					}
					else
					{
						if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							*(fcdata->markbit) |= 0x0800;
						}
						if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																wcc,0x01,fcdata->markbit))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
					}

					if ((0 != wcc[0]) && (pinfo.ytime > 0))
					{
						if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
						{//report info to server actively
							sinfo.conmode = 28;
							sinfo.color = 0x01;
							sinfo.time = pinfo.ytime;
							sinfo.stage = 0;
							sinfo.cyclet = 0;
							sinfo.phase = 0;
											
							for (i = 0; i < MAX_CHANNEL; i++)
							{
								if (0 == wnpcc[i])
									break;
								for (j = 0; j < sinfo.chans; j++)
								{
									if (0 == sinfo.csta[j])
										break;
									tcsta = sinfo.csta[j];
									tcsta &= 0xfc;
									tcsta >>= 2;
									tcsta &= 0x3f;
									if (wnpcc[i] == tcsta)
									{
										sinfo.csta[j] &= 0xfc;
										sinfo.csta[j] |= 0x01; //00000001-yellow
										break;
									}
								}
							}
							for (i = 0; i < MAX_CHANNEL; i++)
							{
								if (0 == wpcc[i])
									break;
								for (j = 0; j < sinfo.chans; j++)
								{
									if (0 == sinfo.csta[j])
										break;
									tcsta = sinfo.csta[j];
									tcsta &= 0xfc;
									tcsta >>= 2;
									tcsta &= 0x3f;
									if (wpcc[i] == tcsta)
									{
										sinfo.csta[j] &= 0xfc;
										break;
									}
								}
							}
							memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
							if (SUCCESS != status_info_report(sibuf,&sinfo))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
							else
							{
								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
							}
						}//report info to server actively
					}//if ((0 != wcc[0]) && (pinfo.ytime > 0))

					if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
					{
						memset(&dctd,0,sizeof(dctd));
						dctd.mode = 28;//traffic control
						dctd.pattern = *(fcdata->patternid);
						dctd.lampcolor = 0x01;
						dctd.lamptime = pinfo.ytime;
						dctd.phaseid = 0;
						dctd.stageline = pinfo.stageline;
						if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
					}
					#ifdef EMBED_CONFIGURE_TOOL
					if (*(fcdata->markbit2) & 0x0200)
					{
						memset(&dctd,0,sizeof(dctd));
                        dctd.mode = 28;//traffic control
                        dctd.pattern = *(fcdata->patternid);
                        dctd.lampcolor = 0x01;
                        dctd.lamptime = pinfo.ytime;
                        dctd.phaseid = 0;
                        dctd.stageline = pinfo.stageline;		
						if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
						{
						#ifdef FULL_DETECT_DEBUG
							printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
						#endif
						}
					}
					#endif
					fbdata[1] = 28;
					fbdata[2] = pinfo.stageline;
					fbdata[3] = 0x01;
					fbdata[4] = pinfo.ytime;
					if (!wait_write_serial(*(fcdata->fbserial)))
					{
						if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
						{
						#ifdef FULL_DETECT_DEBUG
							printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
						#endif
							*(fcdata->markbit) |= 0x0800;
							gettimeofday(&ct,NULL);
							update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
							if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																	fcdata->softevent,fcdata->markbit))
							{	
							#ifdef FULL_DETECT_DEBUG
								printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
						}
					}
					else
					{
					#ifdef FULL_DETECT_DEBUG
						printf("face board serial port cannot write,Line:%d\n",__LINE__);
					#endif
					}
					sendfaceInfoToBoard(fcdata,fbdata);
					sleep(pinfo.ytime);

					//current phase begin to red lamp
					if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
					#endif
						*(fcdata->markbit) |= 0x0800;
					}
					if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																		wcc,0x00,fcdata->markbit))
					{
					#ifdef FULL_DETECT_DEBUG
						printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
					#endif
					}

					if ((0 != wcc[0]) && (pinfo.rtime > 0))
					{
						if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
						{//report info to server actively
							sinfo.conmode = 28;
							sinfo.color = 0x00;
							sinfo.time = pinfo.rtime;
							sinfo.stage = 0;
							sinfo.cyclet = 0;
							sinfo.phase = 0;
														
							for (i = 0; i < MAX_CHANNEL; i++)
							{
								if (0 == wcc[i])
									break;
								for (j = 0; j < sinfo.chans; j++)
								{
									if (0 == sinfo.csta[j])
										break;
									tcsta = sinfo.csta[j];
									tcsta &= 0xfc;
									tcsta >>= 2;
									tcsta &= 0x3f;
									if (wcc[i] == tcsta)
									{
										sinfo.csta[j] &= 0xfc;
										break;
									}
								}
							}
							memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
							memset(sibuf,0,sizeof(sibuf));
							if (SUCCESS != status_info_report(sibuf,&sinfo))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
							else
							{
								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
							}
						}//report info to server actively
					}//if ((0 != wcc[0]) && (pinfo.rtime > 0))
					*(fcdata->slnum) = 0;
					*(fcdata->stageid) = tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
				}//if (0 != directc)
				new_all_red(&ardata);

				*(fcdata->contmode) = contmode; //restore control mode;
				cp = 0;
				dirc = 0;
				*(fcdata->markbit2) &= 0xfffb;
				if (0 == dcyes)
				{
					memset(&dcdata,0,sizeof(dcdata));
					memset(&pinfo,0,sizeof(pinfo));
					dcdata.fd = fcdata;
					dcdata.td = tscdata;
					dcdata.pi = &pinfo;
					dcdata.cs = chanstatus;
					int dcret = pthread_create(&dcpid,NULL,(void *)start_major_salve_control,&dcdata);
					if (0 != dcret)
					{
					#ifdef FULL_DETECT_DEBUG
						printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
						output_log("Detect control,create full detect thread err");
					#endif
						return FAIL;
					}
					dcyes = 1;
				}
				continue;
            //    }//wireless terminal has disconnected with signaler machine;
            }//if (1 == wtlock)
            continue;
		}//time out
		if (cpret > 0)
		{//cpret > 0
			if (FD_ISSET(*(fcdata->conpipe),&nread))
			{
				memset(tcbuf,0,sizeof(tcbuf));
				read(*(fcdata->conpipe),tcbuf,sizeof(tcbuf));
				if ((0xB9==tcbuf[0]) && ((0xED==tcbuf[8]) || (0xED==tcbuf[4]) || (0xED==tcbuf[5])))
                {//wireless terminal control
					pantn = 0;
                    if (0x02 == tcbuf[3])
                    {//pant
				//		printf("Receive pant of main module,File: %s,LIne: %d\n",__FILE__,__LINE__);
                        continue;
                    }//pant
                    if ((0 == wllock) && (0 == keylock) && (0 == netlock))
                    {//terminal control is valid only when wireless and key and net control is invalid;
						if (0x04 == tcbuf[3])
                        {//control function
                            if ((0x01 == tcbuf[4]) && (0 == wtlock))
                            {//control will happen
								get_ms_status(&color,&leatime);
								if (0x02 != color)
								{
									struct timeval          spacetime;
									unsigned char           endlock = 0;
									
									while (1)
									{//while loop,000000
										spacetime.tv_sec = 0;
										spacetime.tv_usec = 200000;
										select(0,NULL,NULL,NULL,&spacetime);

										memset(tcbuf,0,sizeof(tcbuf));
										read(*(fcdata->conpipe),tcbuf,sizeof(tcbuf));
										if ((0xB9 == tcbuf[0]) && (0xED == tcbuf[5]))
										{
											if (0x00 == tcbuf[4])
											{
												endlock = 1;
												break;
											}
										}
										
										get_ms_status(&color,&leatime);
										if (0x02 == color)
										{
											break;
										}
										else
										{
											continue;
										}
									}//while loop,000000
									if (1 == endlock)
									{
										continue;
									}
								}//if (0x02 != color)
								tpp.func[0] = tcbuf[4];
                                memset(terbuf,0,sizeof(terbuf));
                                if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
                                {
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),terbuf,sizeof(terbuf)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write base board serial err,File: %s,Line: %d\n", \
                                                        __FILE__,__LINE__);
                                        #endif
                                        }
										else
										{
											#ifdef FULL_DETECT_DEBUG   
                                        	printf("0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x \
                                                    0x%02x 0x%02x 0x%02x,File: %s,Line: %d\n",\
                                                    terbuf[0],terbuf[1],terbuf[2],terbuf[3], \
                                                    terbuf[4],terbuf[5],terbuf[6],terbuf[7], \
                                                    terbuf[8],__FILE__,__LINE__);
                                        	#endif
										}
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("base board serial cannot write,File: %s,Line: %d\n", \
                                                __FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (SUCCESS == terminal_protol_pack(terbuf,&tpp))	

								wtlock = 1;
								dcred = 0;
								close = 0;
								fpc = 0;
								cp = 0;
								dirc = 0;
								ms_end_child_thread();//end main thread and its child thread

								*(fcdata->markbit2) |= 0x0004;
							#if 0
								new_all_red(&ardata);
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
        						{
        						#ifdef FULL_DETECT_DEBUG
            						printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        						#endif
									*(fcdata->markbit) |= 0x0800;
        						}
							#endif
								*(fcdata->contmode) = 28;//wireless terminal control mode
								
								if (*(fcdata->auxfunc) & 0x01)
                                {//if (*(fcdata->auxfunc) & 0x01)
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcdownti,sizeof(dcdownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcedownti,sizeof(dcedownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (*(fcdata->auxfunc) & 0x01)

								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x02;
									sinfo.time = 0;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						if (0 == pinfo.chan[i])
                    						break;
                						sinfo.chans += 1;
                						tcsta = pinfo.chan[i];
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						tcsta |= 0x02; //00000010-green
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
									memset(wlinfo,0,sizeof(wlinfo));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x04))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,40,ct.tv_sec,fcdata->markbit);
								}//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
                        			update_event_list(fcdata->ec,fcdata->el,1,40,ct.tv_sec,fcdata->markbit);
								}
						
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 0x02;
								fbdata[4] = 0;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
                						update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                						if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																fcdata->softevent,fcdata->markbit))
                						{
                						#ifdef FULL_DETECT_DEBUG
                   							printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                						#endif
                						}
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face board serial port cannot write,Line:%d\n",__LINE__);
								#endif
								}
								sendfaceInfoToBoard(fcdata,fbdata);
								//send down time to configure tool
                            	if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            	{
								#ifdef FULL_DETECT_DEBUG
									printf("send control info to configure tool,File: %s,Line: %d\n", \
											__FILE__,__LINE__);
								#endif
                                	memset(&dctd,0,sizeof(dctd));
                                	dctd.mode = 28;
                                	dctd.pattern = *(fcdata->patternid);
                                	dctd.lampcolor = 0x02;
                                	dctd.lamptime = 0;
                                	dctd.phaseid = pinfo.phaseid;
                                	dctd.stageline = pinfo.stageline;
                                	if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                	#endif
                                	}
                            	}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 28;
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x02;
                                    dctd.lamptime = 0;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;		
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
                            	if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    				pinfo.chan,0x02,fcdata->markbit))
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            	#endif
                            	}
							
								continue;
                            }//control will happen
                            else if ((0x00 == tcbuf[4]) && (1 == wtlock))
                            {//cancel control
								wtlock = 0;
								dcred = 0;
								close = 0;
								fpc = 0;
								cp = 0;

								tpp.func[0] = tcbuf[4];
                                memset(terbuf,0,sizeof(terbuf));
                                if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
                                {
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),terbuf,sizeof(terbuf)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write base board serial err,File: %s,Line: %d\n", \
                                                        __FILE__,__LINE__);
                                        #endif
                                        }
										else
										{
										#ifdef FULL_DETECT_DEBUG   
                                            printf("0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x \
                                                    0x%02x 0x%02x 0x%02x,File: %s,Line: %d\n",\
                                                    terbuf[0],terbuf[1],terbuf[2],terbuf[3], \
                                                    terbuf[4],terbuf[5],terbuf[6],terbuf[7], \
                                                    terbuf[8],__FILE__,__LINE__);
                                            #endif
										}
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("base board serial cannot write,File: %s,Line: %d\n", \
                                                __FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
								if (1 == dcyfyes)
								{
									pthread_cancel(dcyfid);
									pthread_join(dcyfid,NULL);
									dcyfyes = 0;
								}
							
								if ((dirc >= 5) && (dirc <= 0x0c))
								{//direction control happen
									rpc = 0;
                                	rpi = tscdata->timeconfig->TimeConfigList[rettl][0].PhaseId;
                                	get_phase_id(rpi,&rpc);

									memset(nc,0,sizeof(nc));
                                    pcc = nc;
                                    for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
                                    {
                                        if (0 == (tscdata->channel->ChannelList[i].ChannelId))
                                            break;
                                        if (rpc == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
                                        {
											#ifdef CLOSE_LAMP
											tclc = tscdata->channel->ChannelList[i].ChannelId;
											if ((tclc >= 0x05) && (tclc <= 0x0c))
											{
												if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
													continue;
											}
											#else
											if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
													continue;
											}
											if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((5 <= tclc) && (tclc <= 8))
													continue;
											}
											if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((9 <= tclc) && (tclc <= 12))
													continue;
											}
											#endif
                                            *pcc = tscdata->channel->ChannelList[i].ChannelId;
                                            pcc++;
                                        }
                                    }
									memset(wcc,0,sizeof(wcc));
									memset(wnpcc,0,sizeof(wnpcc));
									memset(wpcc,0,sizeof(wpcc));
									z = 0;
									k = 0;
									s = 0;
									pce = 0;
									for (i = 0; i < MAX_CHANNEL; i++)
									{//for (i = 0; i < MAX_CHANNEL; i++)
										if (0 == dirch[dirc-5][i])
											break;
										ce = 0;
										for (j = 0; j < MAX_CHANNEL; j++)
										{//for (j = 0; j < MAX_CHANNEL; j++)
											if (0 == nc[j])
												break;
											if (dirch[dirc-5][i] == nc[j])
											{
												ce = 1;
												break;
											}
										}//for (j = 0; j < MAX_CHANNEL; j++)
										if (0 == ce)
										{
											wcc[z] = dirch[dirc-5][i];
											z++;
											if ((0x0d <= dirch[dirc-5][i]) && (dirch[dirc-5][i] <= 0x10))
											{
												wpcc[k] = dirch[dirc-5][i];
												k++;
												pce = 1;
												continue;
											}
											else
											{
												wnpcc[s] = dirch[dirc-5][i];
												s++;
												continue;
											}		
										}
									}//for (i = 0; i < MAX_CHANNEL; i++)

									if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{
											sinfo.conmode = 28;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == dirch[dirc-5][i])
                    								break;
                								sinfo.chans += 1;
                								tcsta = dirch[dirc-5][i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
                								tcsta |= 0x02; //00000010-green 
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
											memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}
									}//if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									if ((0 != wcc[0]) && (pinfo.gftime > 0))	
									{			
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x03; //00000011-green flash
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.gftime > 0))
	
									//green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = 0;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wpcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wpcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.ytime > 0))

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                            			memset(&dctd,0,sizeof(dctd));
                            			dctd.mode = 28;//traffic control
                            			dctd.pattern = *(fcdata->patternid);
                            			dctd.lampcolor = 0x01;
                            			dctd.lamptime = pinfo.ytime;
                            			dctd.phaseid = 0;
                            			dctd.stageline = pinfo.stageline;
                            			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            			#endif
                            			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                            			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}

									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.rtime > 0))
									*(fcdata->slnum) = 0;
                                    *(fcdata->stageid) = tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
								}//direction control happen
								
								new_all_red(&ardata);

								*(fcdata->contmode) = contmode; //restore control mode;
								cp = 0;
								dirc = 0;
								*(fcdata->markbit2) &= 0xfffb;
								if (0 == dcyes)
								{
									memset(&dcdata,0,sizeof(dcdata));
									memset(&pinfo,0,sizeof(pinfo));
									dcdata.fd = fcdata;
									dcdata.td = tscdata;
									dcdata.pi = &pinfo;
									dcdata.cs = chanstatus;
									int dcret = pthread_create(&dcpid,NULL, \
													(void *)start_major_salve_control,&dcdata);
									if (0 != dcret)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
										output_log("Detect control,create full detect thread err");
									#endif
										return FAIL;
									}
									dcyes = 1;
								}
								if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
								{
									memset(wlinfo,0,sizeof(wlinfo));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x06))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,42,ct.tv_sec,fcdata->markbit);
								}
								else
								{
									gettimeofday(&ct,NULL);
                        			update_event_list(fcdata->ec,fcdata->el,1,42,ct.tv_sec,fcdata->markbit);
								}

								continue;
                            }//cancel control
                            else if (((0x05 <= tcbuf[4]) && (tcbuf[4] <= 0x0c)) && (1 == wtlock))
                            {//direction control
								tpp.func[0] = tcbuf[4];
                                memset(terbuf,0,sizeof(terbuf));
                                if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
                                {
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),terbuf,sizeof(terbuf)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write base board serial err,File: %s,Line: %d\n", \
                                                        __FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("base board serial cannot write,File: %s,Line: %d\n", \
                                                __FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
								if ((1 == dcred) || (1 == dcyfyes) || (1 == close))
                            	{//if ((1 == tcred) || (1 == tcyfyes) || (1 == close))
									dirc = tcbuf[4];
									if ((dirc < 5) && (dirc > 0x0c))
                                    {
                                        continue;
                                    }
									fpc = 1;
									cp = 0;
                                	if (1 == dcyfyes)
                                	{
                                    	pthread_cancel(dcyfid);
                                    	pthread_join(dcyfid,NULL);
                                    	dcyfyes = 0;
                                	}
									if (1 != dcred)
									{
										new_all_red(&ardata);
									}
									dcred = 0;
                                    close = 0;
			//						#ifdef CLOSE_LAMP
									ms_set_lamp_color(*(fcdata->bbserial),clch,0x03);
									update_channel_status(fcdata->sockfd,chanstatus,clch,0x03,fcdata->markbit);
			//						#endif
                                	if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dirch[dirc-5],0x02))
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                	#endif
                                    	*(fcdata->markbit) |= 0x0800;
                                	}
                                	if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                                        				dirch[dirc-5],0x02,fcdata->markbit))
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                	#endif
                                	}
						
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
								/*	
										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							sinfo.chans += 1;
                							tcsta = i + 1;
                							tcsta <<= 2;
                							tcsta &= 0xfc;
											for (j = 0; j < MAX_CHANNEL; j++)
											{
												if (0 == dirch[dirc-5][j])
													break;
												if ((i+1) == dirch[dirc-5][j])
												{
													tcsta |= 0x02;
													break;
												}
											}
                							*csta = tcsta;
                							csta++;
            							}
								*/
										sinfo.chans = 0;
										memset(sinfo.csta,0,sizeof(sinfo.csta));
                                        csta = sinfo.csta;
                                        for (i = 0; i < MAX_CHANNEL; i++)
                                        {
                                            if (0 == dirch[dirc-5][i])
                                                break;
                                            sinfo.chans += 1;
                                            tcsta = dirch[dirc-5][i];
                                            tcsta <<= 2;
                                            tcsta &= 0xfc;
                                            tcsta |= 0x02; //00000010-green 
                                            *csta = tcsta;
                                            csta++;
                                        }
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
									unsigned char				dce = 0;
									unsigned char				val = 0;
									if (0x05 == tcbuf[4])
									{
										dce = 0x10;
										val = 52;
									}
									else if (0x06 == tcbuf[4])
									{
										dce = 0x12;
										val = 54;
									}
									else if (0x07 == tcbuf[4])
									{
										dce = 0x14;
										val = 56;
									}
									else if (0x08 == tcbuf[4])
									{
                                    	dce = 0x16;
										val = 58;
									}
									else if (0x09 == tcbuf[4])
									{
                                    	dce = 0x18;
										val = 60;
									}
									else if (0x0a == tcbuf[4])
									{
                                    	dce = 0x1a;
										val = 62;
									}
									else if (0x0b == tcbuf[4])
									{
                                    	dce = 0x1c;
										val = 64;
									}
									else if (0x0c == tcbuf[4])
									{
                                    	dce = 0x1e;
										val = 66;
									}
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
                                	{
                                    	memset(wlinfo,0,sizeof(wlinfo));
                                    	gettimeofday(&ct,NULL);
                                    	if(SUCCESS!=wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,dce))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
                                    	else
                                    	{
                                        	write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    	}
									  update_event_list(fcdata->ec,fcdata->el,1,val,ct.tv_sec,fcdata->markbit);
                                	}
									else
									{
										gettimeofday(&ct,NULL);
                        			  update_event_list(fcdata->ec,fcdata->el,1,val,ct.tv_sec,fcdata->markbit);
									}

                                	continue;
                            	}//if ((1 == dcred) || (1 == dcyfyes) || (1 == close))
								if (0 == fpc)
								{//if (0 == fpc)
									fpc = 1;
									cp = pinfo.phaseid;
									memset(cc,0,sizeof(cc));
                        			pcc = cc;
                        			for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
                        			{
                    	    			if (0 == (tscdata->channel->ChannelList[i].ChannelId))
                        	    			break;
                            			if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
                            			{
											#ifdef CLOSE_LAMP
											tclc = tscdata->channel->ChannelList[i].ChannelId;
											if ((tclc >= 0x05) && (tclc <= 0x0c))
											{
												if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
													continue;
											}
											#else
											if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
													continue;
											}
											if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((5 <= tclc) && (tclc <= 8))
													continue;
											}
											if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((9 <= tclc) && (tclc <= 12))
													continue;
											}
											#endif
                            				*pcc = tscdata->channel->ChannelList[i].ChannelId;
                                			pcc++;
                            			}
                        			}
									dirc = tcbuf[4];
									memset(wcc,0,sizeof(wcc));
									memset(wnpcc,0,sizeof(wnpcc));
									memset(wpcc,0,sizeof(wpcc));
									z = 0;
									k = 0;
									s = 0;
									pce = 0;
									for (i = 0; i < MAX_CHANNEL; i++)
									{//for (i = 0; i < MAX_CHANNEL; i++)
										if (0 == cc[i])
											break;
										ce = 0;
										for (j = 0; j < MAX_CHANNEL; j++)
										{//for (j = 0; j < MAX_CHANNEL; j++)
											if (0 == dirch[dirc-5][j])
												break;
											if (cc[i] == dirch[dirc-5][j])
											{
												ce = 1;
												break;
											}
										}//for (j = 0; j < MAX_CHANNEL; j++)
										if (0 == ce)
										{
											wcc[z] = cc[i];
											z++;
											if ((0x0d <= cc[i]) && (cc[i] <= 0x10))
											{
												wpcc[k] = cc[i];
												k++;
												pce = 1;
												continue;
											}
											else
											{
												wnpcc[s] = cc[i];
												s++;
												continue;
											}		
										}
									}//for (i = 0; i < MAX_CHANNEL; i++)
									if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{
											sinfo.conmode = 28;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (cp - 1));
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == cc[i])
                    								break;
                								sinfo.chans += 1;
                								tcsta = cc[i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
                								tcsta |= 0x02; //00000010-green 
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
											memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}
									}//if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									if ((0 != wcc[0]) && (pinfo.gftime > 0))	
									{			
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (cp - 1));
	
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x03; //00000011-green flash
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.gftime > 0))
	
									//green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = cp;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = cp;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (cp - 1));
				
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wpcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wpcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.ytime > 0))

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                            			memset(&dctd,0,sizeof(dctd));
                            			dctd.mode = 28;//traffic control
                            			dctd.pattern = *(fcdata->patternid);
                            			dctd.lampcolor = 0x01;
                            			dctd.lamptime = pinfo.ytime;
                            			dctd.phaseid = cp;
                            			dctd.stageline = pinfo.stageline;
                            			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            			#endif
                            			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = cp;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                            			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}

									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (cp - 1));
	
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.rtime > 0))									
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dirch[dirc-5],0x02))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
						
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																		dirch[dirc-5],0x02,fcdata->markbit))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;

										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == dirch[dirc-5][i])
                    							break;
                							sinfo.chans += 1;
                							tcsta = dirch[dirc-5][i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
                							tcsta |= 0x02;
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively									
	
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = 0;
										dctd.stageline = 0;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = 0;
                                        dctd.phaseid = 0;
                                        dctd.stageline = 0;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = 0;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									cp = 0;
								}//if (0 == fpc)
								else if (1 == fpc)
								{//else if (1 == fpc)
									if (dirc == tcbuf[4])
									{//control is current phase
										continue;
									}//control is current phase
									unsigned char		*pcc = dirch[dirc-5];
									dirc = tcbuf[4];
									unsigned char		*pnc = dirch[dirc-5];

									memset(wcc,0,sizeof(wcc));
									memset(wnpcc,0,sizeof(wnpcc));
									memset(wpcc,0,sizeof(wpcc));
									z = 0;
									k = 0;
									s = 0;
									pce = 0;
									for (i = 0; i < MAX_CHANNEL; i++)
									{//for (i = 0; i < MAX_CHANNEL; i++)
										if (0 == pcc[i])
											break;
										ce = 0;
										for (j = 0; j < MAX_CHANNEL; j++)
										{//for (j = 0; j < MAX_CHANNEL; j++)
											if (0 == pnc[j])
												break;
											if (pcc[i] == pnc[j])
											{
												ce = 1;
												break;
											}
										}//for (j = 0; j < MAX_CHANNEL; j++)
										if (0 == ce)
										{
											wcc[z] = pcc[i];
											z++;
											if ((0x0d <= pcc[i]) && (pcc[i] <= 0x10))
											{
												wpcc[k] = pcc[i];
												k++;
												pce = 1;
												continue;
											}
											else
											{
												wnpcc[s] = pcc[i];
												s++;
												continue;
											}		
										}
									}//for (i = 0; i < MAX_CHANNEL; i++)
									
									if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{
											sinfo.conmode = 28;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == cc[i])
                    								break;
                								sinfo.chans += 1;
                								tcsta = cc[i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
                								tcsta |= 0x02; //00000010-green 
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
											memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}
									}//if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									if ((0 != wcc[0]) && (pinfo.gftime > 0))	
									{			
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
	
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x03; //00000011-green flash
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.gftime > 0))
	
									//green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = 0;
										dctd.stageline = 0;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = 0;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = 0;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
				
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wpcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wpcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.ytime > 0))

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                            			memset(&dctd,0,sizeof(dctd));
                            			dctd.mode = 28;//traffic control
                            			dctd.pattern = *(fcdata->patternid);
                            			dctd.lampcolor = 0x01;
                            			dctd.lamptime = pinfo.ytime;
                            			dctd.phaseid = 0;
                            			dctd.stageline = 0;
                            			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            			#endif
                            			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = 0;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = 0;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                            			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}

									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
	
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != wcc[0]) && (pinfo.rtime > 0))									
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pnc,0x02))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
						
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			pnc,0x02,fcdata->markbit))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;

										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == pnc[i])
                    							break;
                							sinfo.chans += 1;
                							tcsta = pnc[i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
                							tcsta |= 0x02;
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));					
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively									
	
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = 0;
										dctd.stageline = 0;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = 0;
                                        dctd.phaseid = 0;
                                        dctd.stageline = 0;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = 0;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
									}
								}//else if (1 == fpc)
								unsigned char				dce = 0;
								unsigned char				val = 0;
								if (0x05 == tcbuf[4])
								{
									dce = 0x10;
									val = 52;
								}
								else if (0x06 == tcbuf[4])
								{
									dce = 0x12;
									val = 54;
								}
								else if (0x07 == tcbuf[4])
								{
									dce = 0x14;
									val = 56;
								}
								else if (0x08 == tcbuf[4])
								{
                                   	dce = 0x16;
									val = 58;
								}
								else if (0x09 == tcbuf[4])
								{
                                   	dce = 0x18;
									val = 60;
								}
								else if (0x0a == tcbuf[4])
								{
                                   	dce = 0x1a;
									val = 62;
								}
								else if (0x0b == tcbuf[4])
								{
                                   	dce = 0x1c;
									val = 64;
								}
								else if (0x0c == tcbuf[4])
								{
                                   	dce = 0x1e;
									val = 66;
								}
								if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
                                {
                                   	memset(wlinfo,0,sizeof(wlinfo));
                                   	gettimeofday(&ct,NULL);
                                   	if(SUCCESS!=wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,dce))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
                                   	else
                                   	{
                                       	write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                   	}
								  	update_event_list(fcdata->ec,fcdata->el,1,val,ct.tv_sec,fcdata->markbit);
                                }
								else
								{
									gettimeofday(&ct,NULL);
                        		    update_event_list(fcdata->ec,fcdata->el,1,val,ct.tv_sec,fcdata->markbit);
								}
								
								continue;
                            }//direction control
                            else if ((0x02 == tcbuf[4]) && (1 == wtlock))
                            {//step by step
								cp = 0;
								fpc = 0;

								tpp.func[0] = tcbuf[4];
                                memset(terbuf,0,sizeof(terbuf));
                                if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
                                {
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),terbuf,sizeof(terbuf)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write base board serial err,File: %s,Line: %d\n", \
                                                        __FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("base board serial cannot write,File: %s,Line: %d\n", \
                                                __FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
								if ((1 == dcred) || (1 == dcyfyes) || (1 == close))
								{//if ((1 == tcred) || (1 == tcyfyes) || (1 == close))
									if (1 == dcyfyes)
                                    {
                                        pthread_cancel(dcyfid);
                                        pthread_join(dcyfid,NULL);
                                        dcyfyes = 0;
                                    }
                                    if (1 != dcred)
                                    {
                                        new_all_red(&ardata);
                                    }
                                    dcred = 0;
                                    close = 0;
				//					#ifdef CLOSE_LAMP
                                    ms_set_lamp_color(*(fcdata->bbserial),clch,0x03);
									update_channel_status(fcdata->sockfd,chanstatus,clch,0x03,fcdata->markbit);
                //                    #endif	
									if ((dirc < 0x05) || (dirc > 0x0c))
									{//not have phase control
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
                                    		*(fcdata->markbit) |= 0x0800;
                                		}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    									pinfo.chan,0x02,fcdata->markbit))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               			#endif
                                		}

										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x02;
											sinfo.time = 0;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
									/*				
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								sinfo.chans += 1;
                								tcsta = i + 1;
                								tcsta <<= 2;
                								tcsta &= 0xfc;
												for (j = 0; j < MAX_CHANNEL; j++)
												{
													if (0 == pinfo.chan[j])
														break;
													if ((i+1) == pinfo.chan[j])
													{
														tcsta |= 0x02;
														break;
													}
												}
                								*csta = tcsta;
                								csta++;
            								}
										*/
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
                                            csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == pinfo.chan[i])
													break;
												sinfo.chans += 1;
												tcsta = pinfo.chan[i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02; //00000010-green 
												*csta = tcsta;
												csta++;
											}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//not have phase control
									else
									{//have direction control
										if (SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),dirch[dirc-5],0x02))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
                                    		*(fcdata->markbit) |= 0x0800;
                                		}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    									dirch[dirc-5],0x02,fcdata->markbit))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               			#endif
                                		}

										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x02;
											sinfo.time = 0;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
									/*				
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								sinfo.chans += 1;
                								tcsta = i + 1;
                								tcsta <<= 2;
                								tcsta &= 0xfc;
												for (j = 0; j < MAX_CHANNEL; j++)
												{
													if (0 == dirch[dirc-5][j])
														break;
													if ((i+1) == dirch[dirc-5][j])
													{
														tcsta |= 0x02;
														break;
													}
												}
                								*csta = tcsta;
                								csta++;
            								}
										*/
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
                                            csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == dirch[dirc-5][i])
													break;
												sinfo.chans += 1;
												tcsta = dirch[dirc-5][i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02; //00000010-green 
												*csta = tcsta;
												csta++;
											}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//have direction control
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
                                	{
                                    	memset(wlinfo,0,sizeof(wlinfo));
                                    	gettimeofday(&ct,NULL);
                                    	if(SUCCESS!=wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x08))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
                                    	else
                                    	{
                                        	write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    	}
                                     	update_event_list(fcdata->ec,fcdata->el,1,44,ct.tv_sec,fcdata->markbit);
                                	}
                                	else
                                	{
                                    	gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,44,ct.tv_sec,fcdata->markbit);
                                	}	

									continue;
								}//if ((1 == dcred) || (1 == dcyfyes) || (1 == close))
								if ((dirc < 0x05) || (dirc > 0x0c))
								{//not have direction control
									if((0==pinfo.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
												if (0 == pinfo.chan[i])
													break;
                								sinfo.chans += 1;
                								tcsta = pinfo.chan[i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
												tcsta |= 0x02;
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//info.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))

									if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
									
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == pinfo.cchan[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (pinfo.cchan[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
                                           				sinfo.csta[j] |= 0x03; //00000001-green flash
														break;
                                        			}
                                    			}
                                			}								
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));	
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))

									//current phase begin to green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = pinfo.phaseid;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                                		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                    		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                    		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
                                    		}
                                		}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{	
									ngf = 0;
									while (1)
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x03))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.cchan,0x03,fcdata->markbit))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
        								#endif
        								}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);

										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x02))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    									pinfo.cchan,0x02,fcdata->markbit))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                		#endif
                                		}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);
								
										ngf += 1;
										if (ngf >= pinfo.gftime)
											break;
									}
									}//if (pinfo.gftime > 0)
									if (1 == (pinfo.cpcexist))
									{
										//current phase begin to yellow lamp
										if (SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),pinfo.cnpchan,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
													pinfo.cnpchan,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),pinfo.cpchan,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																	pinfo.cpchan,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														pinfo.cchan,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == pinfo.cnpchan[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (pinfo.cnpchan[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == pinfo.cpchan[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (pinfo.cpchan[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
														break;
                                        			}
                                    			}
                                			}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                               			memset(&dctd,0,sizeof(dctd));
                               			dctd.mode = 28;//traffic control
                               			dctd.pattern = *(fcdata->patternid);
                               			dctd.lampcolor = 0x01;
                               			dctd.lamptime = pinfo.ytime;
                               			dctd.phaseid = pinfo.phaseid;
                               			dctd.stageline = pinfo.stageline;
                               			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               			#endif
                               			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.cchan,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}

									if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == pinfo.cchan[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (pinfo.cchan[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))

									if (pinfo.rtime > 0)
									{
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            			{
                                			memset(&dctd,0,sizeof(dctd));
                                			dctd.mode = 28;//traffic control
                                			dctd.pattern = *(fcdata->patternid);
                                			dctd.lampcolor = 0x00;
                                			dctd.lamptime = pinfo.rtime;
                                			dctd.phaseid = pinfo.phaseid;
                                			dctd.stageline = pinfo.stageline;
                                			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                    			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                            			}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 28;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x00;
                                            dctd.lamptime = pinfo.rtime;
                                            dctd.phaseid = pinfo.phaseid;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 28;
                                		fbdata[2] = pinfo.stageline;
                                		fbdata[3] = 0x00;
                                		fbdata[4] = pinfo.rtime;
                                		if (!wait_write_serial(*(fcdata->fbserial)))
                                		{
                                    		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
                                        		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                        		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                        		{
                                        		#ifdef FULL_DETECT_DEBUG
                                            		printf("genfile err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                        		#endif
                                        		}
                                    		}
                                		}
                                		else
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                		#endif
                                		}
										sleep(pinfo.rtime);
									}

									*(fcdata->slnum) += 1;
									*(fcdata->stageid) = \
										tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
								if (0==(tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId))
									{
										*(fcdata->slnum) = 0;
										*(fcdata->stageid) = \
										tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
									}
									//get phase info of next phase
									memset(&pinfo,0,sizeof(dcpinfo_t));
        							if(SUCCESS!=ms_get_phase_info(fcdata,tscdata,rettl,*(fcdata->slnum),&pinfo))
        							{
        							#ifdef FULL_DETECT_DEBUG
            							printf("get phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
										output_log("Timing control,get phase info err");
        							#endif
										ms_end_part_child_thread();
            							return FAIL;
        							}
        							*(fcdata->phaseid) = 0;
        							*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));

									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
						
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																pinfo.chan,0x02,fcdata->markbit))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									ncmode = *(fcdata->contmode);
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
											if (0 == pinfo.chan[i])
												break;
                							sinfo.chans += 1;
                							tcsta = pinfo.chan[i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
											tcsta |= 0x02;
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
	
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = pinfo.phaseid;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = 0;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = 0;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                                		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
                                    		}
                                		}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
								}// not have direction control
								else
								{//have direction control
									//default return to first stage;
									*(fcdata->slnum) = 0;
									*(fcdata->stageid) = \
                                               tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
                                    memset(&pinfo,0,sizeof(dcpinfo_t));
                                    if(SUCCESS != ms_get_phase_info(fcdata,tscdata,rettl,0,&pinfo))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        output_log("Timing control,get phase info err");
                                    #endif
                                        ms_end_part_child_thread();
                                        return FAIL;
                                    }
                                    *(fcdata->phaseid) = 0;
                                    *(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));

									memset(wcc,0,sizeof(wcc));
									memset(wnpcc,0,sizeof(wnpcc));
									memset(wpcc,0,sizeof(wpcc));
									z = 0;
									k = 0;
									s = 0;
									pce = 0;
									for (i = 0; i < MAX_CHANNEL; i++)
									{//for (i = 0; i < MAX_CHANNEL; i++)
										if (0 == dirch[dirc-5][i])
											break;
										ce = 0;
										for (j = 0; j < MAX_CHANNEL; j++)
										{//for (j = 0; j < MAX_CHANNEL; j++)
											if (0 == pinfo.chan[j])
												break;
											if (dirch[dirc-5][i] == pinfo.chan[j])
											{
												ce = 1;
												break;
											}
										}//for (j = 0; j < MAX_CHANNEL; j++)
										if (0 == ce)
										{
											wcc[z] = dirch[dirc-5][i];
											z++;
											if ((dirch[dirc-5][i]>=13) && (dirch[dirc-5][i]<=16))
											{
												wpcc[k] = dirch[dirc-5][i];
												k++;
												pce = 1;
												continue;
											}
											else
											{
												wnpcc[s] = dirch[dirc-5][i];
												s++;
												continue;
											}
										}
									}//for (i = 0; i < MAX_CHANNEL; i++)

									if((0==wcc[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
												if (0 == dirch[dirc-5][i])
													break;
                								sinfo.chans += 1;
                								tcsta = dirch[dirc-5][i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
												tcsta |= 0x02;
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//info.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))

									if ((0 != wcc[0]) && (pinfo.gftime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
									
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == wcc[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (wcc[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
                                           				sinfo.csta[j] |= 0x03; //00000001-green flash
														break;
                                        			}
                                    			}
                                			}								
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))

									//current phase begin to green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = 0;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;	
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                                		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                    		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                    		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
                                    		}
                                		}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{	
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("updatechannelerr,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("setgreenlamperr,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("updatechannelerr,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == wpcc[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (wpcc[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
														break;
                                        			}
                                    			}
                                			}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                               			memset(&dctd,0,sizeof(dctd));
                               			dctd.mode = 28;//traffic control
                               			dctd.pattern = *(fcdata->patternid);
                               			dctd.lampcolor = 0x01;
                               			dctd.lamptime = pinfo.ytime;
                               			dctd.phaseid = 0;
                               			dctd.stageline = pinfo.stageline;
                               			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               			#endif
                               			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}

									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 28;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))

									if (pinfo.rtime > 0)
									{
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            			{
                                			memset(&dctd,0,sizeof(dctd));
                                			dctd.mode = 28;//traffic control
                                			dctd.pattern = *(fcdata->patternid);
                                			dctd.lampcolor = 0x00;
                                			dctd.lamptime = pinfo.rtime;
                                			dctd.phaseid = 0;
                                			dctd.stageline = pinfo.stageline;
                                			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                    			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                            			}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 28;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x00;
                                            dctd.lamptime = pinfo.rtime;
                                            dctd.phaseid = 0;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 28;
                                		fbdata[2] = pinfo.stageline;
                                		fbdata[3] = 0x00;
                                		fbdata[4] = pinfo.rtime;
                                		if (!wait_write_serial(*(fcdata->fbserial)))
                                		{
                                    		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
                                        		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                        		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                        		{
                                        		#ifdef FULL_DETECT_DEBUG
                                            		printf("file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        		#endif
                                        		}
                                    		}
                                		}
                                		else
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                		#endif
                                		}
										sleep(pinfo.rtime);
									}
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
						
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			pinfo.chan,0x02,fcdata->markbit))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (pinfo.phaseid - 1));

										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == pinfo.chan[i])
                    							break;
                							sinfo.chans += 1;
                							tcsta = pinfo.chan[i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
                							tcsta |= 0x02;
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));				
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively									
	
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = pinfo.phaseid;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 28;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = 0;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = 0;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}	
								}//have direction control		
								if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
                                {
                                    memset(wlinfo,0,sizeof(wlinfo));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x08))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,44,ct.tv_sec,fcdata->markbit);
                                }
								else
								{
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,44,ct.tv_sec,fcdata->markbit);
								}
					
								dirc = 0;
                                continue;
                            }//step by step
                            else if ((0x03 == tcbuf[4]) && (1 == wtlock))
                            {//yellow flash
								dirc = 0;
								dcred = 0;
								close = 0;
								cp = 0;
				
								tpp.func[0] = tcbuf[4];
                                memset(terbuf,0,sizeof(terbuf));
                                if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
                                {
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),terbuf,sizeof(terbuf)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write base board serial err,File: %s,Line: %d\n", \
                                                        __FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("base board serial cannot write,File: %s,Line: %d\n", \
                                                __FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
								if (0 == dcyfyes)
								{
									memset(&yfdata,0,sizeof(yfdata));
									yfdata.second = 0;
									yfdata.markbit = fcdata->markbit;
									yfdata.markbit2 = fcdata->markbit2;
									yfdata.serial = *(fcdata->bbserial);
									yfdata.sockfd = fcdata->sockfd;
									yfdata.cs = chanstatus;	
#ifdef FLASH_DEBUG
									char szInfo[32] = {0};
									char szInfoT[64] = {0};
									snprintf(szInfo,sizeof(szInfo)-1,"%s",__FUNCTION__);
									snprintf(szInfoT,sizeof(szInfoT)-1,"%d",__LINE__);
									tsc_save_eventlog(szInfo,szInfoT);
#endif
									int yfret = pthread_create(&dcyfid,NULL,(void *)ms_yellow_flash,&yfdata);
									if (0 != yfret)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
										output_log("Timing control,create yellow flash err");
									#endif
										ms_end_part_child_thread();

										return FAIL;
									}
									dcyfyes = 1;
								}

								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x05;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;

									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i+1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));						
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
									memset(wlinfo,0,sizeof(wlinfo));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x0a))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    }
                                    update_event_list(fcdata->ec,fcdata->el,1,46,ct.tv_sec,fcdata->markbit);
								}//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,46,ct.tv_sec,fcdata->markbit);
								}

								continue;
                            }//yellow flash
                            else if ((0x04 == tcbuf[4]) && (1 == wtlock))
                            {//all red
								dirc = 0;
								close = 0;
								cp = 0;
								if (1 == dcyfyes)
								{
									pthread_cancel(dcyfid);
									pthread_join(dcyfid,NULL);
									dcyfyes = 0;
								}
					
								if (0 == dcred)
								{	
									new_all_red(&ardata);
									dcred = 1;
								}
							
								tpp.func[0] = tcbuf[4];
                                memset(terbuf,0,sizeof(terbuf));
                                if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
                                {
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),terbuf,sizeof(terbuf)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write base board serial err,File: %s,Line: %d\n", \
                                                        __FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("base board serial cannot write,File: %s,Line: %d\n", \
                                                __FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (SUCCESS == terminal_protol_pack(terbuf,&tpp))	
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x00;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;

									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i+1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));					
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
									memset(wlinfo,0,sizeof(wlinfo));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x0c))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,48,ct.tv_sec,fcdata->markbit);
								}//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,48,ct.tv_sec,fcdata->markbit);
								}

								continue;
                            }//all red
                            else if ((0x0d == tcbuf[4]) && (1 == wtlock))
                            {//close
								dirc = 0;
								dcred = 0;
								cp = 0;
								if (1 == dcyfyes)
                                {
                                    pthread_cancel(dcyfid);
                                    pthread_join(dcyfid,NULL);
                                    dcyfyes = 0;
                                }
								if (0 == close)
                                {
                                    new_all_close(&acdata);
                                    close = 1;
                                }
								tpp.func[0] = tcbuf[4];
                                memset(terbuf,0,sizeof(terbuf));
                                if (SUCCESS == terminal_protol_pack(terbuf,&tpp))
                                {
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),terbuf,sizeof(terbuf)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write base board serial err,File: %s,Line: %d\n", \
                                                        __FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("base board serial cannot write,File: %s,Line: %d\n", \
                                                __FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (SUCCESS == terminal_protol_pack(terbuf,&tpp))

								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x04;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;

									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i+1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
									memset(wlinfo,0,sizeof(wlinfo));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != wireless_info_report(wlinfo,ct.tv_sec,fcdata->wlmark,0x0e))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("wireless_info_report,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),wlinfo,sizeof(wlinfo));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,50,ct.tv_sec,fcdata->markbit);
								}//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,50,ct.tv_sec,fcdata->markbit);
								}
								continue;
                            }//close 
                        }//control function
                    }//terminal control is valid only when wireless and key and net control is invalid;
					continue;
                }//wireless terminal control	
				else if ((0xCC == tcbuf[0]) && (0xED == tcbuf[2]))
				{//network control
					if ((0 == wllock) && (0 == keylock) && (0 == wtlock))
					{//net control is valid only when wireless and key control is invalid;
						if ((0xf0 == tcbuf[1]) && (0 == netlock))
						{//net control will happen
							get_ms_status(&color,&leatime);
							maj_phase = 0;
							if (0x02 != color)
							{
								struct timeval          spacetime;
								unsigned char           endlock = 0;
								phcon = 1;
								while (1)
								{//while loop,000000
									spacetime.tv_sec = 0;
									spacetime.tv_usec = 200000;
									select(0,NULL,NULL,NULL,&spacetime);

									memset(tcbuf,0,sizeof(tcbuf));
									read(*(fcdata->conpipe),tcbuf,sizeof(tcbuf));
									if ((0xCC == tcbuf[0]) && (0xED == tcbuf[2]))
									{
										if (0xf1 == tcbuf[1])
										{
											endlock = 1;
											phcon = 0;
											break;
										}
										else
										{
											maj_phase = tcbuf[1];
										}
									}
								
									get_ms_status(&color,&leatime);
									if (0x02 == color)
									{
										break;
									}
									else
									{
										continue;
									}
								}//while loop,000000
								if (1 == endlock)
								{
									*(fcdata->markbit) &= 0xbfff;
									continue;
								}
							}//if (0x02 != color)
							netlock = 1;
							dcred = 0;
							close = 0;
							fpc = 0;
							cp = 0;
							ms_end_child_thread();//end main thread and its child thread

							*(fcdata->markbit2) |= 0x0008;
						#if 0
							new_all_red(&ardata);
						#endif
							if (0 == phcon)
							{
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
        						{
        						#ifdef FULL_DETECT_DEBUG
            						printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        						#endif
									*(fcdata->markbit) |= 0x0800;
        						}
							}
						
							*(fcdata->markbit) |= 0x4000;								
							*(fcdata->contmode) = 29;//network control mode
				//			phcon = 0;

					#if 0
							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 29;
								sinfo.color = 0x02;
								sinfo.time = 0;
								sinfo.stage = pinfo.stageline;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
								sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					if (0 == pinfo.chan[i])
                    					break;
                					sinfo.chans += 1;
                					tcsta = pinfo.chan[i];
                					tcsta <<= 2;
                					tcsta &= 0xfc;
                					tcsta |= 0x02; //00000010-green
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
							}//report info to server actively
					#endif
							fbdata[1] = 29;
							fbdata[2] = pinfo.stageline;
							fbdata[3] = 0x02;
							fbdata[4] = 0;
							if (!wait_write_serial(*(fcdata->fbserial)))
							{
								if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
								{
								#ifdef FULL_DETECT_DEBUG
									printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									*(fcdata->markbit) |= 0x0800;
									gettimeofday(&ct,NULL);
                					update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                					if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																fcdata->softevent,fcdata->markbit))
                					{
                					#ifdef FULL_DETECT_DEBUG
                   						printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                					#endif
                					}
								}
							}
							else
							{
							#ifdef FULL_DETECT_DEBUG
								printf("face board serial port cannot write,Line:%d\n",__LINE__);
							#endif
							}
							sendfaceInfoToBoard(fcdata,fbdata);
							if (*(fcdata->auxfunc) & 0x01)
                                {//if (*(fcdata->auxfunc) & 0x01)
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcdownti,sizeof(dcdownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcedownti,sizeof(dcedownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (*(fcdata->auxfunc) & 0x01)	
							//send down time to configure tool
                            if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
							#ifdef FULL_DETECT_DEBUG
								printf("send control info to configure tool,File: %s,Line: %d\n", \
											__FILE__,__LINE__);
							#endif
                                memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 29;
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x02;
                                dctd.lamptime = 0;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;
                                if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
                            }
							#ifdef EMBED_CONFIGURE_TOOL
                            if (*(fcdata->markbit2) & 0x0200)
                            {
                                memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 29;
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x02;
                                dctd.lamptime = 0;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;  
                                if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
                            }
                            #endif
                            if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    pinfo.chan,0x02,fcdata->markbit))
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            #endif
                            }
							
							objecti[0].objectv[0] = 0xf2;
							factovs = 0;
							memset(cbuf,0,sizeof(cbuf));
							if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                            {
                            #ifdef FULL_DETECT_DEBUG
                            	printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
							if (!(*(fcdata->markbit) & 0x1000))
							{
                            	write(*(fcdata->sockfd->csockfd),cbuf,factovs);
							}
							gettimeofday(&ct,NULL);
                            update_event_list(fcdata->ec,fcdata->el,1,84,ct.tv_sec,fcdata->markbit);
                           	if(0 == maj_phase)
							{
								continue;
							}
							else
							{
								tcbuf[1] = maj_phase;
								ms_get_last_phaseinfo(fcdata,tscdata,rettl,&pinfo);
							}
						}//net control will happen
						if ((0xf0 == tcbuf[1]) && (1 == netlock))
                        {//has been status of net control
                            objecti[0].objectv[0] = 0xf2;
                            factovs = 0;
                            memset(cbuf,0,sizeof(cbuf));
                            if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
                            if (!(*(fcdata->markbit) & 0x1000))
                            {
                                write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                            }
                        }//has been status of net control
						if ((0xf1 == tcbuf[1]) && (0 == netlock))
                        {//not fit control or restrore
                            objecti[0].objectv[0] = 0xf3;
                            factovs = 0;
                            memset(cbuf,0,sizeof(cbuf));
                            if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x00))
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
                            if (!(*(fcdata->markbit) & 0x1000))
                            {
                                write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                            }
                        }//not fit control or restrore
						if ((0xf1 == tcbuf[1]) && (1 == netlock))
						{//net control will end
							netlock = 0;
							phcon = 0;
					//		dcred = 0;
					//		close = 0;
							fpc = 0;
					/*
							if (1 == dcyfyes)
							{
								pthread_cancel(dcyfid);
								pthread_join(dcyfid,NULL);
								dcyfyes = 0;
							}
					*/
							*(fcdata->markbit) &= 0xbfff;
							if (0 == cp)
                            {//not have phase control
                                if ((0 == dcred) && (0 == dcyfyes) && (0 == close))
                                {//not have all red/yellow flash/close
									if((0==pinfo.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 29;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
												if (0 == pinfo.chan[i])
													break;
                								sinfo.chans += 1;
                								tcsta = pinfo.chan[i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
												tcsta |= 0x02;
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0==pinfo.cchan[0])&&(pinfo.gftime>0) 
									//||(pinfo.ytime>0)||(pinfo.rtime>0))

									if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 29;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
									
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == pinfo.cchan[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (pinfo.cchan[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
                                           				sinfo.csta[j] |= 0x03; //00000001-green flash
														break;
                                        			}
                                    			}
                                			}								
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))

									//current phase begin to green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = pinfo.phaseid;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                                		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                    		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                    		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
                                    		}
                                		}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{	
									ngf = 0;
									while (1)
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x03))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.cchan,0x03,fcdata->markbit))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
        								#endif
        								}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);

										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x02))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    									pinfo.cchan,0x02,fcdata->markbit))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                		#endif
                                		}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);
								
										ngf += 1;
										if (ngf >= pinfo.gftime)
											break;
									}
									}//if (pinfo.gftime > 0)
									if (1 == (pinfo.cpcexist))
									{
										//current phase begin to yellow lamp
										if(SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),pinfo.cnpchan,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
													pinfo.cnpchan,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cpchan,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																	pinfo.cpchan,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														pinfo.cchan,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 29;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == pinfo.cnpchan[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (pinfo.cnpchan[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == pinfo.cpchan[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (pinfo.cpchan[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
														break;
                                        			}
                                    			}
                                			}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                               			memset(&dctd,0,sizeof(dctd));
                               			dctd.mode = 29;//traffic control
                               			dctd.pattern = *(fcdata->patternid);
                               			dctd.lampcolor = 0x01;
                               			dctd.lamptime = pinfo.ytime;
                               			dctd.phaseid = pinfo.phaseid;
                               			dctd.stageline = pinfo.stageline;
                               			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               			#endif
                               			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.cchan,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}

									if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 29;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == pinfo.cchan[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (pinfo.cchan[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))

									if (pinfo.rtime > 0)
									{
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            			{
                                			memset(&dctd,0,sizeof(dctd));
                                			dctd.mode = 29;//traffic control
                                			dctd.pattern = *(fcdata->patternid);
                                			dctd.lampcolor = 0x00;
                                			dctd.lamptime = pinfo.rtime;
                                			dctd.phaseid = pinfo.phaseid;
                                			dctd.stageline = pinfo.stageline;
                                			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                    			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                            			}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x00;
                                            dctd.lamptime = pinfo.rtime;
                                            dctd.phaseid = pinfo.phaseid;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
                                		fbdata[2] = pinfo.stageline;
                                		fbdata[3] = 0x00;
                                		fbdata[4] = pinfo.rtime;
                                		if (!wait_write_serial(*(fcdata->fbserial)))
                                		{
                                    		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
                                        		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                        		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                        		{
                                        		#ifdef FULL_DETECT_DEBUG
                                            		printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                        		#endif
                                        		}
                                    		}
                                		}
                                		else
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                		#endif
                                		}
										sleep(pinfo.rtime);
									}

									*(fcdata->slnum) += 1;
									*(fcdata->stageid) = \
									tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
								if (0 == (tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId))
									{
										*(fcdata->slnum) = 0;
										*(fcdata->stageid) = \
										tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
									}
                                }//not have all red/yellow flash/close
                                else
                                {//have all red or yellow flash or all close
                                    dcred = 0;
                                    close = 0;
                                    if (1 == dcyfyes)
                                    {
                                        pthread_cancel(dcyfid);
                                        pthread_join(dcyfid,NULL);
                                        dcyfyes = 0;
                                    }
                                }//have all red or yellow flash or all close
                            }//not have phase control
							else if (0 != cp)
							{//phase control happen
								if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
								{//if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
									rpc = 0;
                                    rpi = tscdata->timeconfig->TimeConfigList[rettl][0].PhaseId;
                                    get_phase_id(rpi,&rpc);
									memset(nc,0,sizeof(nc));
                                    pcc = nc;
                                    for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
                                    {
                                        if (0 == (tscdata->channel->ChannelList[i].ChannelId))
                                            break;
                                        if (rpc == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
                                        {
											#ifdef CLOSE_LAMP
											tclc = tscdata->channel->ChannelList[i].ChannelId;
											if ((tclc >= 0x05) && (tclc <= 0x0c))
											{
												if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
													continue;
											}
											#else
											if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
													continue;
											}
											if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((5 <= tclc) && (tclc <= 8))
													continue;
											}
											if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((9 <= tclc) && (tclc <= 12))
													continue;
											}
											#endif
                                            *pcc = tscdata->channel->ChannelList[i].ChannelId;
                                            pcc++;
                                        }
                                    }
									memset(wcc,0,sizeof(wcc));
									memset(wnpcc,0,sizeof(wnpcc));
									memset(wpcc,0,sizeof(wpcc));
									z = 0;
									k = 0;
									s = 0;
									pce = 0;
									if ((0x5a <= cp) && (cp <= 0x5d))
                                    {//if ((0x5a <= cp) && (cp <= 0x5d))
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == lkch[cp-0x5a][i])
												break;
											ce = 0;
											for (j = 0; j < MAX_CHANNEL; j++)
											{
												if (0 == nc[j])
													break;
												if (nc[j] == lkch[cp-0x5a][i])
												{
													ce = 1;
													break;
												}
											}
											if (0 == ce)
											{
												wcc[z] = lkch[cp-0x5a][i];
												z++;
												if ((0x0d <= lkch[cp-0x5a][i]) && (lkch[cp-0x5a][i] <= 0x10))
												{
													wpcc[k] = lkch[cp-0x5a][i];
													k++;
													pce = 1;
													continue;
												}
												else
												{
													wnpcc[s] = lkch[cp-0x5a][i];
													s++;
													continue;
												}
											}//if (0 == ce)
										}								
									}//if ((0x5a <= cp) && (cp <= 0x5d))
                                   	if (0xC8 == cp)
									{//if (0xC8 == cp)
										for (i = 0; i < MAX_CHANNEL; i++)
                                        {
                                            if (*(fcdata->ccontrol) & (0x00000001 << i))
                                            {
                                                tclc = i + 1;
                                                #ifdef CLOSE_LAMP
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
                                                #else
                                                if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
                                                {
                                                    if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                                                        continue;
                                                }
                                                if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
                                                {
                                                    if ((5 <= tclc) && (tclc <= 8))
                                                        continue;
                                                }
                                                if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
                                                {
                                                    if ((9 <= tclc) && (tclc <= 12))
                                                        continue;
                                                }
                                                #endif
                                                ce = 0;
                                                for (j = 0; j < MAX_CHANNEL; j++)
                                                {
													if (0 == nc[j])
                                                        break;
                                                    if (nc[j] == tclc)
                                                    {
                                                        ce = 1;
                                                        break;
                                                    }
                                                }
                                                if (0 == ce)
                                                {
                                                    wcc[z] = i+1;
                                                    z++;
                                                    if ((0x0d <= tclc) && (tclc <= 0x10))
                                                    {
                                                        wpcc[k] = tclc;
                                                        k++;
                                                        pce = 1;
                                                        continue;
                                                    }
                                                    else
                                                    {
                                                        wnpcc[s] = tclc;
                                                        s++;
                                                        continue;
                                                    }
                                                }
                                            }
                                        }	
									}//if (0xC8 == cp)
 	
									if((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
                                            else
                                                sinfo.conmode = 29;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == lkch[cp-0x5a][i])
                    								break;
                								sinfo.chans += 1;
                								tcsta = lkch[cp-0x5a][i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
                								tcsta |= 0x02; //00000010-green 
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}
									if ((0 != wcc[0]) && (pinfo.gftime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
                                            else
                                                sinfo.conmode = 29;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x03; //00000011-green flash
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively								
									}
									//green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = 0;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
                                            else
                                                sinfo.conmode = 29;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wpcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wpcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                            			memset(&dctd,0,sizeof(dctd));
                            			dctd.mode = 29;//traffic control
                            			dctd.pattern = *(fcdata->patternid);
                            			dctd.lampcolor = 0x01;
                            			dctd.lamptime = pinfo.ytime;
                            			dctd.phaseid = 0;
                            			dctd.stageline = pinfo.stageline;
                            			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            			#endif
                            			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                            			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
                                            else
                                                sinfo.conmode = 29;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
															
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}
									*(fcdata->slnum) = 0;
                                    *(fcdata->stageid) = tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
								}//if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
								else if ((0x01 <= cp) && (cp <= 0x20))
								{//else if ((0x01 <= cp) && (cp <= 0x20))
									unsigned char			tsl = 0;
									unsigned char			pexist = 0;
									for (i = 0; i < (tscdata->timeconfig->FactStageNum); i++)
									{
										if (0 == (tscdata->timeconfig->TimeConfigList[rettl][i].StageId))
											break;
										rpi = tscdata->timeconfig->TimeConfigList[rettl][i].PhaseId;
										rpc = 0;
										get_phase_id(rpi,&rpc);
										if (cp == rpc)
										{
											pexist = 1;	
											break;
										}
									}	
									if (1 == pexist)
									{//control phase belong to phase list;
										if (0 == tscdata->timeconfig->TimeConfigList[rettl][i+1].StageId)
										{
											*(fcdata->slnum) = 0;
											*(fcdata->stageid) = \
												tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
											rpc = 0;
											rpi = tscdata->timeconfig->TimeConfigList[rettl][0].PhaseId;
											get_phase_id(rpi,&rpc);
										}
										else
										{
											*(fcdata->slnum) = i + 1;
											*(fcdata->stageid) = \
												tscdata->timeconfig->TimeConfigList[rettl][i+1].StageId;
											rpc = 0;
											rpi = tscdata->timeconfig->TimeConfigList[rettl][i+1].PhaseId;
											get_phase_id(rpi,&rpc);
										}
										memset(nc,0,sizeof(nc));
										pcc = nc;
										for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
										{
											if (0 == (tscdata->channel->ChannelList[i].ChannelId))
												break;
											if (rpc == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
											{
												#ifdef CLOSE_LAMP
                                                tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
            									{
                									tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                    									continue;
            									}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((5 <= tclc) && (tclc <= 8))
														continue;
												}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if ((9 <= tclc) && (tclc <= 12))
                    									continue;
												}
                                                #endif
												*pcc = tscdata->channel->ChannelList[i].ChannelId;
												pcc++;
											}
										}
										memset(cc,0,sizeof(cc));
										pcc = cc;
										memset(wcc,0,sizeof(wcc));
										memset(wnpcc,0,sizeof(wnpcc));
										memset(wpcc,0,sizeof(wpcc));
										z = 0;
										k = 0;
										s = 0;
										pce = 0;
										for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
										{
											if (0 == (tscdata->channel->ChannelList[i].ChannelId))
												break;
											if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
											{
												#ifdef CLOSE_LAMP
                                                tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
            									{
                									tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                    									continue;
            									}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((5 <= tclc) && (tclc <= 8))
														continue;
												}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if ((9 <= tclc) && (tclc <= 12))
                    									continue;
												}
                                                #endif
												*pcc = tscdata->channel->ChannelList[i].ChannelId;
												pcc++;
												ce = 0;
												for (j = 0; j < MAX_CHANNEL; j++)
												{
													if (0 == nc[j])
														break;
													if (nc[j] == tscdata->channel->ChannelList[i].ChannelId)
													{
														ce = 1;
														break;
													}
												}
												if (0 == ce)
												{
													wcc[z] = tscdata->channel->ChannelList[i].ChannelId;
													z++;
													if (3 == tscdata->channel->ChannelList[i].ChannelType)
													{
														wpcc[k] = tscdata->channel->ChannelList[i].ChannelId;
														k++;
														pce = 1;
														continue;
													}
													else
													{
														wnpcc[s] = tscdata->channel->ChannelList[i].ChannelId;
														s++;
														continue;
													}		
												}
											}
										}
										if((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x02;
												sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												sinfo.chans = 0;
												memset(sinfo.csta,0,sizeof(sinfo.csta));
												csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == cc[i])
														break;
													sinfo.chans += 1;
													tcsta = cc[i];
													tcsta <<= 2;
													tcsta &= 0xfc;
													tcsta |= 0x02; //00000010-green 
													*csta = tcsta;
													csta++;
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}
										if ((0 != wcc[0]) && (pinfo.gftime > 0))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x03;
												sinfo.time = pinfo.gftime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															sinfo.csta[j] |= 0x03; //00000011-green flash
															break;
														}
													}
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively								
										}
										//green flash
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
										{
											memset(&dctd,0,sizeof(dctd));
											dctd.mode = 29;//traffic control
											dctd.pattern = *(fcdata->patternid);
											dctd.lampcolor = 0x02;
											dctd.lamptime = pinfo.gftime;
											dctd.phaseid = cp;
											dctd.stageline = pinfo.stageline;
											if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x02;
                                            dctd.lamptime = pinfo.gftime;
                                            dctd.phaseid = cp;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
										fbdata[2] = pinfo.stageline;
										fbdata[3] = 0x02;
										fbdata[4] = pinfo.gftime;
										if (!wait_write_serial(*(fcdata->fbserial)))
										{
											if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
											{
											#ifdef FULL_DETECT_DEBUG
												printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
												update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
												if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
											}
										}
										else
										{
										#ifdef FULL_DETECT_DEBUG
											printf("face board serial port cannot write,Line:%d\n",__LINE__);
										#endif
										}
										if (pinfo.gftime > 0)
										{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
										}//if (pinfo.gftime > 0)
										if (1 == pce)
										{
											//current phase begin to yellow lamp
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wnpcc,0x01, fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wpcc,0x00,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										else
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wcc,0x01,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										if ((0 != wcc[0]) && (pinfo.ytime > 0))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x01;
												sinfo.time = pinfo.ytime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wnpcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wnpcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															sinfo.csta[j] |= 0x01; //00000001-yellow
															break;
														}
													}
												}
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wpcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wpcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															break;
														}
													}
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}

										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
										{
											memset(&dctd,0,sizeof(dctd));
											dctd.mode = 29;//traffic control
											dctd.pattern = *(fcdata->patternid);
											dctd.lampcolor = 0x01;
											dctd.lamptime = pinfo.ytime;
											dctd.phaseid = cp;
											dctd.stageline = pinfo.stageline;
											if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x01;
                                            dctd.lamptime = pinfo.ytime;
                                            dctd.phaseid = cp;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
										fbdata[2] = pinfo.stageline;
										fbdata[3] = 0x01;
										fbdata[4] = pinfo.ytime;
										if (!wait_write_serial(*(fcdata->fbserial)))
										{
											if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
											{
											#ifdef FULL_DETECT_DEBUG
												printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
												update_event_list(fcdata->ec,fcdata->el,1,16, \
																		ct.tv_sec,fcdata->markbit);
												if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
											}
										}
										else
										{
										#ifdef FULL_DETECT_DEBUG
											printf("face board serial port cannot write,Line:%d\n",__LINE__);
										#endif
										}
										sleep(pinfo.ytime);

										//current phase begin to red lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										if ((0 != wcc[0]) && (pinfo.rtime > 0))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x00;
												sinfo.time = pinfo.rtime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															break;
														}
													}
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}
									}//control phase belong to phase list;
									else
									{//control phase don't belong to phase list;
										rpc = 0;
										rpi = tscdata->timeconfig->TimeConfigList[rettl][0].PhaseId;
										get_phase_id(rpi,&rpc);

										memset(nc,0,sizeof(nc));
										pcc = nc;
										for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
										{
											if (0 == (tscdata->channel->ChannelList[i].ChannelId))
												break;
											if (rpc == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
											{
												#ifdef CLOSE_LAMP
                                                tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
            									{
                									tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                    									continue;
            									}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((5 <= tclc) && (tclc <= 8))
														continue;
												}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if ((9 <= tclc) && (tclc <= 12))
                    									continue;
												}
                                                #endif
												*pcc = tscdata->channel->ChannelList[i].ChannelId;
												pcc++;
											}
										}
										memset(cc,0,sizeof(cc));
										pcc = cc;
										memset(wcc,0,sizeof(wcc));
										memset(wnpcc,0,sizeof(wnpcc));
										memset(wpcc,0,sizeof(wpcc));
										z = 0;
										k = 0;
										s = 0;
										pce = 0;
										for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
										{
											if (0 == (tscdata->channel->ChannelList[i].ChannelId))
												break;
											if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
											{
												#ifdef CLOSE_LAMP
                                                tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
            									{
                									tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                    									continue;
            									}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((5 <= tclc) && (tclc <= 8))
														continue;
												}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if ((9 <= tclc) && (tclc <= 12))
                    									continue;
												}
                                                #endif
												*pcc = tscdata->channel->ChannelList[i].ChannelId;
												pcc++;
												ce = 0;
												for (j = 0; j < MAX_CHANNEL; j++)
												{
													if (0 == nc[j])
														break;
													if (nc[j] == tscdata->channel->ChannelList[i].ChannelId)
													{
														ce = 1;
														break;
													}
												}
												if (0 == ce)
												{
													wcc[z] = tscdata->channel->ChannelList[i].ChannelId;
													z++;
													if (3 == tscdata->channel->ChannelList[i].ChannelType)
													{
														wpcc[k] = tscdata->channel->ChannelList[i].ChannelId;
														k++;
														pce = 1;
														continue;
													}
													else
													{
														wnpcc[s] = tscdata->channel->ChannelList[i].ChannelId;
														s++;
														continue;
													}		
												}
											}
										}
										if((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x02;
												sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												sinfo.chans = 0;
												memset(sinfo.csta,0,sizeof(sinfo.csta));
												csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == cc[i])
														break;
													sinfo.chans += 1;
													tcsta = cc[i];
													tcsta <<= 2;
													tcsta &= 0xfc;
													tcsta |= 0x02; //00000010-green 
													*csta = tcsta;
													csta++;
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}
										if ((0 != wcc[0]) && (pinfo.gftime > 0))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x03;
												sinfo.time = pinfo.gftime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															sinfo.csta[j] |= 0x03; //00000011-green flash
															break;
														}
													}
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("Info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively								
										}
										//green flash
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
										{
											memset(&dctd,0,sizeof(dctd));
											dctd.mode = 29;//traffic control
											dctd.pattern = *(fcdata->patternid);
											dctd.lampcolor = 0x02;
											dctd.lamptime = pinfo.gftime;
											dctd.phaseid = cp;
											dctd.stageline = pinfo.stageline;
											if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x02;
                                            dctd.lamptime = pinfo.gftime;
                                            dctd.phaseid = cp;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
										fbdata[2] = pinfo.stageline;
										fbdata[3] = 0x02;
										fbdata[4] = pinfo.gftime;
										if (!wait_write_serial(*(fcdata->fbserial)))
										{
											if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
											{
											#ifdef FULL_DETECT_DEBUG
												printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
												update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
												if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
											}
										}
										else
										{
										#ifdef FULL_DETECT_DEBUG
											printf("face board serial port cannot write,Line:%d\n",__LINE__);
										#endif
										}
										if (pinfo.gftime > 0)
										{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
										}//if (pinfo.gftime > 0)
										if (1 == pce)
										{
											//current phase begin to yellow lamp
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wnpcc,0x01, fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wpcc,0x00,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										else
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wcc,0x01,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										if ((0 != wcc[0]) && (pinfo.ytime > 0))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x01;
												sinfo.time = pinfo.ytime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wnpcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wnpcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															sinfo.csta[j] |= 0x01; //00000001-yellow
															break;
														}
													}
												}
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wpcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wpcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															break;
														}
													}
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}

										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
										{
											memset(&dctd,0,sizeof(dctd));
											dctd.mode = 29;//traffic control
											dctd.pattern = *(fcdata->patternid);
											dctd.lampcolor = 0x01;
											dctd.lamptime = pinfo.ytime;
											dctd.phaseid = cp;
											dctd.stageline = pinfo.stageline;
											if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x01;
                                            dctd.lamptime = pinfo.ytime;
                                            dctd.phaseid = cp;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
										fbdata[2] = pinfo.stageline;
										fbdata[3] = 0x01;
										fbdata[4] = pinfo.ytime;
										if (!wait_write_serial(*(fcdata->fbserial)))
										{
											if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
											{
											#ifdef FULL_DETECT_DEBUG
												printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
												update_event_list(fcdata->ec,fcdata->el,1,16, \
																		ct.tv_sec,fcdata->markbit);
												if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
											}
										}
										else
										{
										#ifdef FULL_DETECT_DEBUG
											printf("face board serial port cannot write,Line:%d\n",__LINE__);
										#endif
										}
										sleep(pinfo.ytime);

										//current phase begin to red lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										if ((0 != wcc[0]) && (pinfo.rtime > 0))
										{
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x00;
												sinfo.time = pinfo.rtime;
												sinfo.stage = 0;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
																
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == wcc[i])
														break;
													for (j = 0; j < sinfo.chans; j++)
													{
														if (0 == sinfo.csta[j])
															break;
														tcsta = sinfo.csta[j];
														tcsta &= 0xfc;
														tcsta >>= 2;
														tcsta &= 0x3f;
														if (wcc[i] == tcsta)
														{
															sinfo.csta[j] &= 0xfc;
															break;
														}
													}
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}
										*(fcdata->slnum) = 0;
										*(fcdata->stageid) = \
											tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
									}//control phase don't belong to phase list;
								}//else if ((0x01 <= cp) && (cp <= 0x20)) 
							}//if (0 != cp)
							new_all_red(&ardata);
									
							*(fcdata->contmode) = contmode; //restore control mode;
							cp = 0;
							ncmode = *(fcdata->contmode);
							*(fcdata->markbit2) &= 0xfff7;
							*(fcdata->fcontrol) = 0;
							*(fcdata->ccontrol) = 0;
							*(fcdata->trans) = 0;
							if (0 == dcyes)
                            {
                                memset(&dcdata,0,sizeof(dcdata));
                                memset(&pinfo,0,sizeof(pinfo));
                                dcdata.fd = fcdata;
                                dcdata.td = tscdata;
                                dcdata.pi = &pinfo;
                                dcdata.cs = chanstatus;
                                int dcret = pthread_create(&dcpid,NULL, \
                                                    (void *)start_major_salve_control,&dcdata);
                                if (0 != dcret)
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    output_log("detect control,create full detect thread err");
                                #endif
                                    ms_end_part_child_thread();
                                    return FAIL;
                                }
                                dcyes = 1;
                            }	
							
							objecti[0].objectv[0] = 0xf3;
							factovs = 0;
							memset(cbuf,0,sizeof(cbuf));
							if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                            {
                            #ifdef FULL_DETECT_DEBUG
                            	printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
							if (!(*(fcdata->markbit) & 0x1000))
							{
                            	write(*(fcdata->sockfd->csockfd),cbuf,factovs);
							}
							gettimeofday(&ct,NULL);
                            update_event_list(fcdata->ec,fcdata->el,1,85,ct.tv_sec,fcdata->markbit);
							continue;
						}//net control will end
						if ((1 == netlock) && ((0xf0 != tcbuf[1]) || (0xf1 != tcbuf[1])))
						{//status of network control
							if (((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d)) || (0xC8 == tcbuf[1]))
							{//if (((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d)) || (0xC8 == tcbuf[1]))
								if ((1 == dcred) || (1 == dcyfyes) || (1 == close) || (1 == phcon))
                            	{//if ((1 == tcred) || (1 == tcyfyes) || (1 == close))
									fpc = 1;
									phcon = 0;
									cp = tcbuf[1];
                                	if (1 == dcyfyes)
                                	{
                                    	pthread_cancel(dcyfid);
                                    	pthread_join(dcyfid,NULL);
                                    	dcyfyes = 0;
                                	}
									if (1 != dcred)
									{
										new_all_red(&ardata);
									}
									dcred = 0;
									close = 0;
					//				#ifdef CLOSE_LAMP
                                    ms_set_lamp_color(*(fcdata->bbserial),clch,0x03);
									update_channel_status(fcdata->sockfd,chanstatus,clch,0x03,fcdata->markbit);
                    //                #endif
									if (0xC8 == tcbuf[1])
									{//if (0xC8 == tcbuf[1])
										memset(ccon,0,sizeof(ccon));
                                        j = 0;
                                        for (i = 0; i < MAX_CHANNEL; i++)
                                        {
                                            if (*(fcdata->ccontrol) & (0x00000001 << i))
                                            {
                                                #ifdef CLOSE_LAMP
                                                if (((i+1) >= 5) && ((i+1) <= 12))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << ((i+1) - 5)))
                                                        continue;
                                                }
                                                #else
                                                if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
                                                {
                                                    tclc = i + 1;
                                                    if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                                                        continue;
                                                }
                                                if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
                                                {
                                                    tclc = i + 1;
                                                    if ((5 <= tclc) && (tclc <= 8))
                                                        continue;
                                                }
                                                if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
                                                {
                                                    tclc = i + 1;
                                                    if ((9 <= tclc) && (tclc <= 12))
                                                        continue;
                                                }
												#endif
                                                ccon[j] = i + 1;
                                                j++;
                                            }
                                        }
                                        if(SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),ccon,0x02))
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                            *(fcdata->markbit) |= 0x0800;
                                        }
                                        if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                                                            ccon,0x02,fcdata->markbit))
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                        if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
                                        {//report info to server actively
                                            sinfo.conmode = 29;
                                            sinfo.color = 0x02;
                                            sinfo.time = 0;
                                            sinfo.stage = 0;
                                            sinfo.cyclet = 0;
                                            sinfo.phase = 0;
                                            sinfo.chans = 0;
                                            memset(sinfo.csta,0,sizeof(sinfo.csta));
                                            csta = sinfo.csta;
                                            for (i = 0; i < MAX_CHANNEL; i++)
											{
                                                if (0 == ccon[i])
                                                    break;
                                                sinfo.chans += 1;
                                                tcsta = ccon[i];
                                                tcsta <<= 2;
                                                tcsta &= 0xfc;
                                                tcsta |= 0x02; //00000010-green 
                                                *csta = tcsta;
                                                csta++;
                                            }

                                            memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
                                            memset(sibuf,0,sizeof(sibuf));
                                            if (SUCCESS != status_info_report(sibuf,&sinfo))
                                            {
                                            #ifdef FULL_DETECT_DEBUG
                                                printf("status info pack err,File:%s,Line:%d\n", \
                                                        __FILE__,__LINE__);
                                            #endif
                                            }
                                            else
                                            {
                                                write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
                                            }
                                        }//report info to server actively
                                        gettimeofday(&ct,NULL);
                                        update_event_list(fcdata->ec,fcdata->el,1,127, \
                                                            ct.tv_sec,fcdata->markbit);	
										*(fcdata->fcontrol) = *(fcdata->ccontrol); //added by sk on 20180512
									}//if (0xC8 == tcbuf[1])
									if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                    {//if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))	
										if(SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),lkch[cp-0x5a],0x02))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS!=update_channel_status(fcdata->sockfd,chanstatus, \
																		lkch[cp-0x5a],0x02,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = cp;
											sinfo.color = 0x02;
											sinfo.time = 0;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
										/*	
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
											csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == lkch[cp-0x5a][i])
													break;
												sinfo.chans += 1;
												tcsta = lkch[cp-0x5a][i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02; //00000010-green 
												*csta = tcsta;
												csta++;
											}
										*/
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
											csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == lkch[cp-0x5a][i])
													break;
												sinfo.chans += 1;
												tcsta = lkch[cp-0x5a][i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02; //00000010-green 
												*csta = tcsta;
												csta++;
											}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
											memset(sibuf,0,sizeof(sibuf));
											if (SUCCESS != status_info_report(sibuf,&sinfo))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("status info pack err,File:%s,Line:%d\n", \
																				__FILE__,__LINE__);
											#endif
											}
											else
											{
												write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
											}
										}//report info to server actively
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,89,ct.tv_sec,fcdata->markbit);
									}//if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                	continue;
                            	}//if ((1 == tcred) || (1 == tcyfyes) || (1 == close))
								if (0 == fpc)
								{//phase control of first times
									fpc = 1;
									cp = pinfo.phaseid;
								}//phase control of first times

								if ((cp == tcbuf[1]) && (0xC8 != cp))
								{
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
									{
										if ((0x5a <= cp) && (cp <= 0x5d))
                                            sinfo.conmode = cp;
                                        else
                                            sinfo.conmode = 29;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
								
										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == lkch[cp-0x5a][i])
                    							break;
                							sinfo.chans += 1;
                							tcsta = lkch[cp-0x5a][i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
                							tcsta |= 0x02; //00000010-green 
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}

									objecti[0].objectv[0] = 0xf4;
                                    factovs = 0;
                                    memset(cbuf,0,sizeof(cbuf));
                                    if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    if (!(*(fcdata->markbit) & 0x1000))
                                    {
                                        write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                    }
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,89,ct.tv_sec,fcdata->markbit);
									continue;
								}
								else
								{//control phase is not current phase
									if ((0x01 <= cp) && (cp <= 0x20))
									{//if ((0x01 <= cp) && (cp <= 0x20))
										memset(cc,0,sizeof(cc));
										pcc = cc;
										memset(wcc,0,sizeof(wcc));
										memset(wnpcc,0,sizeof(wnpcc));
										memset(wpcc,0,sizeof(wpcc));
										z = 0;
										k = 0;
										s = 0;
										pce = 0;
										for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
										{
											if (0 == (tscdata->channel->ChannelList[i].ChannelId))
												break;
											if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
											{
												#ifdef CLOSE_LAMP
                                                tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
            									{
                									tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                    									continue;
            									}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((5 <= tclc) && (tclc <= 8))
														continue;
												}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if ((9 <= tclc) && (tclc <= 12))
                    									continue;
												}
                                                #endif
												*pcc = tscdata->channel->ChannelList[i].ChannelId;
												pcc++;
												ce = 0;
												if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                                {//if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                                    for (j = 0; j < MAX_CHANNEL; j++)
                                                    {
                                                        if (0 == lkch[tcbuf[1]-0x5a][j])
                                                            break;
                                                        if (lkch[tcbuf[1]-0x5a][j] \
                                                            == tscdata->channel->ChannelList[i].ChannelId)
                                                        {
                                                            ce = 1;
                                                            break;
                                                        }
                                                    }
                                                }//if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                                else if (0xC8 == tcbuf[1])
                                                {//else if (0xC8 == tcbuf[1])
                                                    tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                    if (*(fcdata->ccontrol) & (0x00000001 << (tclc - 1)))
                                                        ce = 1;
                                                }//else if (0xC8 == tcbuf[1])
												if (0 == ce)
												{
													wcc[z] = tscdata->channel->ChannelList[i].ChannelId;
													z++;
													if (3 == tscdata->channel->ChannelList[i].ChannelType)
													{
														wpcc[k] = tscdata->channel->ChannelList[i].ChannelId;
														k++;
														pce = 1;
														continue;
													}
													else
													{
														wnpcc[s] = tscdata->channel->ChannelList[i].ChannelId;
														s++;
														continue;
													}		
												}
											}
										}
									}//if ((0x01 <= cp) && (cp <= 0x20))
									else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
									{//else if ((0x5a <= cp) && (cp <= 0x5d))
										memset(cc,0,sizeof(cc));
                                        pcc = cc;
										if ((0x5a <= cp) && (cp <= 0x5d))
										{
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == lkch[cp-0x5a][i])
													break;
												*pcc = lkch[cp-0x5a][i];
												pcc++;
											}
										}
										else if (0xC8 == cp)
										{
											for (i = 0; i < MAX_CHANNEL; i++)
                                            {
                                                if (*(fcdata->fcontrol) & (0x00000001 << i))
                                                {
                                                    #ifdef CLOSE_LAMP
                                                    if (((i+1) >= 5) && ((i+1) <= 12))
                                                    {
                                                        if (*(fcdata->specfunc) & (0x01 << ((i+1) - 5)))
                                                            continue;
                                                    }
                                                    #else
                                                    if((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
                                                    {
                                                        tclc = i + 1;
                                                        if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                                                            continue;
                                                    }
                                                  if((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((5 <= tclc) && (tclc <= 8))
                                                            continue;
                                                    }
                                                  if((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((9 <= tclc) && (tclc <= 12))
                                                            continue;
                                                    }
                                                    #endif
                                                    *pcc = i + 1;
													pcc++;
                                                }
                                            }
										}//else if (0xC8 == cp)
                                        memset(wcc,0,sizeof(wcc));
                                        memset(wnpcc,0,sizeof(wnpcc));
                                        memset(wpcc,0,sizeof(wpcc));
                                        z = 0;
                                        k = 0;
                                        s = 0;
                                        pce = 0;
                                        for (i = 0; i < MAX_CHANNEL; i++)
                                        {//for (i = 0; i < MAX_CHANNEL_LINE; i++)
                                            if (0 == cc[i])
                                                break;
                                            ce = 0;
											if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                            {//if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                                for (j = 0; j < MAX_CHANNEL; j++)
                                                {
                                                    if (0 == lkch[tcbuf[1]-0x5a][j])
                                                        break;
                                                    if (lkch[tcbuf[1]-0x5a][j] == cc[i])
                                                    {
                                                        ce = 1;
                                                        break;
                                                    }
                                                }
                                            }//if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                            else if (0xC8 == tcbuf[1])
                                            {//else if (0xC8 == tcbuf[1])
                                                if (*(fcdata->ccontrol) & (0x00000001 << (cc[i]-1)))
                                                    ce = 1;
                                            }//else if (0xC8 == tcbuf[1])
                                            if (0 == ce)
                                            {
                                                wcc[z] = cc[i];
                                                z++;
                                                if ((0x0d <= cc[i]) && (cc[i] <= 0x10))
                                                {
                                                    wpcc[k] = cc[i];
                                                    k++;
                                                    pce =1;
                                                    continue;
                                                }
                                                else
                                                {
                                                    wnpcc[s] = cc[i];
                                                    s++;
                                                    continue;
                                                }
                                            }
										}
									}//else if ((0x5a <= cp) && (cp <= 0x5d))
									if (0xC8 == tcbuf[1])
                                        *(fcdata->trans) |= 0x01;

									if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
												sinfo.conmode = 29;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											sinfo.chans = 0;
                                        	memset(sinfo.csta,0,sizeof(sinfo.csta));
                                        	csta = sinfo.csta;
                                        	for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == cc[i])
                                                	break;
                                            	sinfo.chans += 1;
                                            	tcsta = cc[i];
                                            	tcsta <<= 2;
                                            	tcsta &= 0xfc;
                                            	tcsta |= 0x02;
                                            	*csta = tcsta;
                                            	csta++;
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}
									if ((0 != wcc[0]) && (pinfo.gftime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
                                                    	sinfo.csta[j] |= 0x03; //00000001-green flash
														break;
                                                	}
                                            	}
                                        	}								
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}
									//green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = 0;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }	
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wpcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wpcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                            			memset(&dctd,0,sizeof(dctd));
                            			dctd.mode = 29;//traffic control
                            			dctd.pattern = *(fcdata->patternid);
                            			dctd.lampcolor = 0x01;
                            			dctd.lamptime = pinfo.ytime;
                            			dctd.phaseid = 0;
                            			dctd.stageline = pinfo.stageline;
                            			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            			#endif
                            			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
                            			memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;	
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                            			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}

									if (pinfo.rtime > 0)
									{
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            			{
                                			memset(&dctd,0,sizeof(dctd));
                                			dctd.mode = 29;//network control
                                			dctd.pattern = *(fcdata->patternid);
                                			dctd.lampcolor = 0x00;
                                			dctd.lamptime = pinfo.rtime;
                                			dctd.phaseid = 0;
                                			dctd.stageline = pinfo.stageline;
                                			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                            			}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//network control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x00;
                                            dctd.lamptime = pinfo.rtime;
                                            dctd.phaseid = 0;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
                                		fbdata[2] = pinfo.stageline;
                                		fbdata[3] = 0x00;
                                		fbdata[4] = pinfo.rtime;
                                		if (!wait_write_serial(*(fcdata->fbserial)))
                                		{
                                   			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   			#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
                                       			update_event_list(fcdata->ec,fcdata->el,1,16, \
																		ct.tv_sec,fcdata->markbit);
                                       			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                       			{
                                       			#ifdef FULL_DETECT_DEBUG
                                           			printf("gen err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                       			#endif
                                       			}
                                   			}
                                		}
                                		else
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                   			printf("face board port cannot write,Line:%d\n",__LINE__);
                                		#endif
                                		}
										sleep(pinfo.rtime);
									}
								
									if ((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d))
                                    {	
										if (SUCCESS != \
											ms_set_lamp_color(*(fcdata->bbserial),lkch[tcbuf[1]-0x5a],0x02))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
							
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																lkch[tcbuf[1]-0x5a],0x02,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										ncmode = *(fcdata->contmode);
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = tcbuf[1];
											sinfo.color = 0x02;
											sinfo.time = 0;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;

											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
											csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == lkch[tcbuf[1]-0x5a][i])
													break;
												sinfo.chans += 1;
												tcsta = lkch[tcbuf[1]-0x5a][i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02;
												*csta = tcsta;
												csta++;
											}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));					
											memset(sibuf,0,sizeof(sibuf));
											if (SUCCESS != status_info_report(sibuf,&sinfo))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("status info pack err,File:%s,Line:%d\n", \
																			__FILE__,__LINE__);
											#endif
											}
											else
											{
												write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
											}
										}//report info to server actively
									}
									if (0xC8 == tcbuf[1])
									{
										memset(ccon,0,sizeof(ccon));
										j = 0;
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (*(fcdata->ccontrol) & (0x00000001 << i))
											{
												#ifdef CLOSE_LAMP
												if (((i+1) >= 5) && ((i+1) <= 12))
												{
													if (*(fcdata->specfunc) & (0x01 << ((i+1) - 5)))
														continue;
												}
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
                                                {
                                                    tclc = i + 1; 
                                                    if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                                                        continue;
                                                }
                                                if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
                                                {
                                                    tclc = i + 1;
                                                    if ((5 <= tclc) && (tclc <= 8))
                                                        continue;
                                                }
                                                if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
                                                {
                                                    tclc = i + 1;
                                                    if ((9 <= tclc) && (tclc <= 12))
                                                        continue;
                                                }
												#endif
												ccon[j] = i + 1;
												j++;
											}
										}
										*(fcdata->fcontrol) = *(fcdata->ccontrol);
										if(SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),ccon,0x02))
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                            *(fcdata->markbit) |= 0x0800;
                                        }
                                        if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                                                    		ccon,0x02,fcdata->markbit))
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                        #endif
                                        }
										ncmode = *(fcdata->contmode);
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = ncmode;
											sinfo.color = 0x02;
											sinfo.time = 0;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
											csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == ccon[i])
													break;
												sinfo.chans += 1;
												tcsta = ccon[i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02; //00000010-green 
												*csta = tcsta;
												csta++;
											}

											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
											memset(sibuf,0,sizeof(sibuf));
											if (SUCCESS != status_info_report(sibuf,&sinfo))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("status info pack err,File:%s,Line:%d\n", \
														__FILE__,__LINE__);
											#endif
											}
											else
											{
												write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
											}
										}//report info to server actively
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,127, \
															ct.tv_sec,fcdata->markbit);
									}//if (0xC8 == tcbuf[1])
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = 0;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = 0;
                                        dctd.phaseid = 0;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = 0;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (0xC8 == tcbuf[1])
                                        *(fcdata->trans) = 0;
									cp = tcbuf[1];

									objecti[0].objectv[0] = 0xf4;
									factovs = 0;
									memset(cbuf,0,sizeof(cbuf));
									if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                            			printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									if (!(*(fcdata->markbit) & 0x1000))
									{
                            			write(*(fcdata->sockfd->csockfd),cbuf,factovs);
									}
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,89,ct.tv_sec,fcdata->markbit);							
									continue;	
								}//control phase is not current phase
							}//if (((0x5a <= tcbuf[1]) && (tcbuf[1] <= 0x5d)) || (0xC8 == tcbuf[1]))
							else if ((0x01 <= tcbuf[1]) && (tcbuf[1] <= 0x20))
							{//control someone phase
								//check phaseid whether exist in phase list;
								pex = 0;
								for (i = 0; i < (tscdata->phase->FactPhaseNum); i++)
								{
									if (0 == (tscdata->phase->PhaseList[i].PhaseId))
										break;
									if (tcbuf[1] == (tscdata->phase->PhaseList[i].PhaseId))
									{
										pex = 1;
										break;
									}	
								}
								if (0 == pex)
								{
								#ifdef FULL_DETECT_DEBUG
									printf("Not fit phase id,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									objecti[0].objectv[0] = 0xf4;
                                    factovs = 0;
                                    memset(cbuf,0,sizeof(cbuf));
                                    if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x00))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    if (!(*(fcdata->markbit) & 0x1000))
                                    {
                                        write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                    }
									continue;
								}
								//end check phaseid whether exist in phase list;

								if ((1 == dcred) || (1 == dcyfyes) || (1 == close) || (1 == phcon))
                            	{//if ((1 == tcred) || (1 == tcyfyes) || (1 == close))
									fpc = 1;
									phcon = 0;
									cp = tcbuf[1];
                                	if (1 == dcyfyes)
                                	{
                                    	pthread_cancel(dcyfid);
                                    	pthread_join(dcyfid,NULL);
                                    	dcyfyes = 0;
                                	}
									if (1 != dcred)
									{
										new_all_red(&ardata);
									}
									dcred = 0;
									close = 0;
					//				#ifdef CLOSE_LAMP
                                    ms_set_lamp_color(*(fcdata->bbserial),clch,0x03);
									update_channel_status(fcdata->sockfd,chanstatus,clch,0x03,fcdata->markbit);
                   //                 #endif
									memset(nc,0,sizeof(nc));
                                    pcc = nc;
                                    for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
                                    {
                                        if (0 == (tscdata->channel->ChannelList[i].ChannelId))
                                            break;
                                        if (tcbuf[1] == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
                                        {
											#ifdef CLOSE_LAMP
											tclc = tscdata->channel->ChannelList[i].ChannelId;
											if ((tclc >= 0x05) && (tclc <= 0x0c))
											{
												if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
													continue;
											}
											#else
											if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
													continue;
											}
											if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((5 <= tclc) && (tclc <= 8))
													continue;
											}
											if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((9 <= tclc) && (tclc <= 12))
													continue;
											}
											#endif
                                            *pcc = tscdata->channel->ChannelList[i].ChannelId;
                                            pcc++;
                                        }
                                    }
                                	if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),nc,0x02))
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                	#endif
                                    	*(fcdata->markbit) |= 0x0800;
                                	}
                                	if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                                        				nc,0x02,fcdata->markbit))
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                	#endif
                                	}
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 29;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
                                        sinfo.phase |= (0x01 << (cp - 1));														
									/*	
										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							sinfo.chans += 1;
                							tcsta = i + 1;
                							tcsta <<= 2;
                							tcsta &= 0xfc;
											for (j = 0; j < MAX_CHANNEL; j++)
											{
												if (0 == nc[j])
													break;
												if ((i+1) == nc[j])
												{
													tcsta |= 0x02;
													break;
												}
											}
                							*csta = tcsta;
                							csta++;
            							}
								*/
										sinfo.chans = 0;
										memset(sinfo.csta,0,sizeof(sinfo.csta));
                                        csta = sinfo.csta;
                                        for (i = 0; i < MAX_CHANNEL; i++)
                                        {
                                            if (0 == nc[i])
                                                break;
                                            sinfo.chans += 1;
                                            tcsta = nc[i];
                                            tcsta <<= 2;
                                            tcsta &= 0xfc;
                                            tcsta |= 0x02; //00000010-green 
                                            *csta = tcsta;
                                            csta++;
                                        }
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,88,ct.tv_sec,fcdata->markbit);
                                	continue;
                            	}//if ((1 == tcred) || (1 == tcyfyes) || (1 == close))
								if (0 == fpc)
								{//phase control of first times
									fpc = 1;
									cp = pinfo.phaseid;
								}//phase control of first times

								if (cp == tcbuf[1])
								{
									memset(cc,0,sizeof(cc));
									pcc = cc;
									for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
									{
										if (0 == (tscdata->channel->ChannelList[i].ChannelId))
											break;
										if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
										{
											#ifdef CLOSE_LAMP
											tclc = tscdata->channel->ChannelList[i].ChannelId;
											if ((tclc >= 0x05) && (tclc <= 0x0c))
											{
												if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
													continue;
											}
											#else
											if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
													continue;
											}
											if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((5 <= tclc) && (tclc <= 8))
													continue;
											}
											if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((9 <= tclc) && (tclc <= 12))
													continue;
											}
											#endif
											*pcc = tscdata->channel->ChannelList[i].ChannelId;
											pcc++;
										}
									}
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
									{
										sinfo.conmode = 29;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (cp - 1));
								
										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == cc[i])
                    							break;
                							sinfo.chans += 1;
                							tcsta = cc[i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
                							tcsta |= 0x02; //00000010-green 
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}

									objecti[0].objectv[0] = 0xf4;
                                    factovs = 0;
                                    memset(cbuf,0,sizeof(cbuf));
                                    if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    if (!(*(fcdata->markbit) & 0x1000))
                                    {
                                        write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                    }
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,88,ct.tv_sec,fcdata->markbit);
									continue;
								}
								else
								{//control phase is not current phase
									memset(nc,0,sizeof(nc));
                                    pcc = nc;
                                    for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
                                    {
                                        if (0 == (tscdata->channel->ChannelList[i].ChannelId))
                                            break;
                                        if (tcbuf[1] == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
                                        {
											#ifdef CLOSE_LAMP
											tclc = tscdata->channel->ChannelList[i].ChannelId;
											if ((tclc >= 0x05) && (tclc <= 0x0c))
											{
												if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
													continue;
											}
											#else
											if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
													continue;
											}
											if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((5 <= tclc) && (tclc <= 8))
													continue;
											}
											if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
											{
												tclc = tscdata->channel->ChannelList[i].ChannelId;
												if ((9 <= tclc) && (tclc <= 12))
													continue;
											}
											#endif
                                            *pcc = tscdata->channel->ChannelList[i].ChannelId;
                                            pcc++;
                                        }
                                    }
									if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
									{//if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
										memset(cc,0,sizeof(cc));
                                        pcc = cc;
										if ((0x5a <= cp) && (cp <= 0x5d))
                                        {
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == lkch[cp-0x5a][i])
													break;
												*pcc = lkch[cp-0x5a][i];
												pcc++;
											}
										}
										else if (0xC8 == cp)
										{//else if (0xC8 == cp)
											for (i = 0; i < MAX_CHANNEL; i++)
                                            {
                                                if (*(fcdata->ccontrol) & (0x00000001 << i))
                                                {
                                                    #ifdef CLOSE_LAMP
                                                    if (((i+1) >= 5) && ((i+1) <= 12))
                                                    {
                                                        if (*(fcdata->specfunc) & (0x01 << ((i+1) - 5)))
                                                            continue;
                                                    }
                                                    #else
                                                    if((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
                                                    {
                                                        tclc = i + 1;
                                                        if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                                                            continue;
                                                    }
                                                  if((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((5 <= tclc) && (tclc <= 8))
                                                            continue;
                                                    }
                                                  if((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((9 <= tclc) && (tclc <= 12))
                                                            continue;
                                                    }
                                                    #endif
                                                    *pcc = i + 1;
													pcc++;
                                                }
                                            }
										}//else if (0xC8 == cp)
                                        memset(wcc,0,sizeof(wcc));
                                        memset(wnpcc,0,sizeof(wnpcc));
                                        memset(wpcc,0,sizeof(wpcc));
                                        z = 0;
                                        k = 0;
                                        s = 0;
                                        pce = 0;
                                        for (i = 0; i < MAX_CHANNEL; i++)
                                        {
                                            if (0 == cc[i])
                                                break;
                                            ce = 0;
											for (j = 0; j < MAX_CHANNEL; j++)
                                            {
                                                if (0 == nc[j])
                                                    break;
                                                if (nc[j] == cc[i])
                                                {
                                                    ce = 1;
                                                    break;
                                                }
                                            }
                                            if (0 == ce)
                                            {
                                                wcc[z] = cc[i];
                                                z++;
                                                if ((0x0d <= cc[i]) && (cc[i] <= 0x10))
                                                {
                                                    wpcc[k] = cc[i];
                                                    k++;
                                                    pce = 1;
                                                    continue;
                                                }
                                                else
                                                {
                                                    wnpcc[s] = cc[i];
                                                    s++;
                                                    continue;
                                                }
                                            }
										}
									}//if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
									else if ((0x01 <= cp) && (cp <= 0x20))
									{//else if ((0x01 <= cp) && (cp <= 0x20))
										memset(cc,0,sizeof(cc));
										pcc = cc;
										memset(wcc,0,sizeof(wcc));
										memset(wnpcc,0,sizeof(wnpcc));
										memset(wpcc,0,sizeof(wpcc));
										z = 0;
										k = 0;
										s = 0;
										pce = 0;
										for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
										{
											if (0 == (tscdata->channel->ChannelList[i].ChannelId))
												break;
											if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
											{
												#ifdef CLOSE_LAMP
                                                tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
            									{
                									tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                    									continue;
            									}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((5 <= tclc) && (tclc <= 8))
														continue;
												}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if ((9 <= tclc) && (tclc <= 12))
                    									continue;
												}	
                                                #endif
												*pcc = tscdata->channel->ChannelList[i].ChannelId;
												pcc++;
												ce = 0;
												for (j = 0; j < MAX_CHANNEL; j++)
												{
													if (0 == nc[j])
														break;
													if (nc[j] == tscdata->channel->ChannelList[i].ChannelId)
													{
														ce = 1;
														break;
													}
												}
												if (0 == ce)
												{
													wcc[z] = tscdata->channel->ChannelList[i].ChannelId;
													z++;
													if (3 == tscdata->channel->ChannelList[i].ChannelType)
													{
														wpcc[k] = tscdata->channel->ChannelList[i].ChannelId;
														k++;
														pce = 1;
														continue;
													}
													else
													{
														wnpcc[s] = tscdata->channel->ChannelList[i].ChannelId;
														s++;
														continue;
													}		
												}
											}
										}
									}//else if ((0x01 <= cp) && (cp <= 0x20))

									if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											sinfo.chans = 0;
                                        	memset(sinfo.csta,0,sizeof(sinfo.csta));
                                        	csta = sinfo.csta;
                                        	for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == cc[i])
                                                	break;
                                            	sinfo.chans += 1;
                                            	tcsta = cc[i];
                                            	tcsta <<= 2;
                                            	tcsta &= 0xfc;
                                            	tcsta |= 0x02;
                                            	*csta = tcsta;
                                            	csta++;
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}
									if ((0 != wcc[0]) && (pinfo.gftime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
                                                    	sinfo.csta[j] |= 0x03; //00000001-green flash
														break;
                                                	}
                                            	}
                                        	}								
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}
									//green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = cp;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = cp;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wpcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wpcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                            			memset(&dctd,0,sizeof(dctd));
                            			dctd.mode = 29;//traffic control
                            			dctd.pattern = *(fcdata->patternid);
                            			dctd.lampcolor = 0x01;
                            			dctd.lamptime = pinfo.ytime;
                            			dctd.phaseid = cp;
                            			dctd.stageline = pinfo.stageline;
                            			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            			#endif
                            			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = cp;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                            			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                            			{
                            			#ifdef FULL_DETECT_DEBUG
                               				printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = 0;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }	
											for (i = 0; i < MAX_CHANNEL; i++)
                                        	{
                                            	if (0 == wcc[i])
                                                	break;
                                            	for (j = 0; j < sinfo.chans; j++)
                                            	{
                                                	if (0 == sinfo.csta[j])
                                                    	break;
                                                	tcsta = sinfo.csta[j];
                                                	tcsta &= 0xfc;
                                                	tcsta >>= 2;
                                                	tcsta &= 0x3f;
                                                	if (wcc[i] == tcsta)
                                                	{
                                                    	sinfo.csta[j] &= 0xfc;
														break;
                                                	}
                                            	}
                                        	}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}

									if (pinfo.rtime > 0)
									{
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            			{
                                			memset(&dctd,0,sizeof(dctd));
                                			dctd.mode = 29;//network control
                                			dctd.pattern = *(fcdata->patternid);
                                			dctd.lampcolor = 0x00;
                                			dctd.lamptime = pinfo.rtime;
                                			dctd.phaseid = cp;
                                			dctd.stageline = pinfo.stageline;
                                			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                   				printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                            			}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//network control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x00;
                                            dctd.lamptime = pinfo.rtime;
                                            dctd.phaseid = cp;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
                                		fbdata[2] = pinfo.stageline;
                                		fbdata[3] = 0x00;
                                		fbdata[4] = pinfo.rtime;
                                		if (!wait_write_serial(*(fcdata->fbserial)))
                                		{
                                   			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   			#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
                                       			update_event_list(fcdata->ec,fcdata->el,1,16, \
																		ct.tv_sec,fcdata->markbit);
                                       			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                       			{
                                       			#ifdef FULL_DETECT_DEBUG
                                           			printf("gen err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                       			#endif
                                       			}
                                   			}
                                		}
                                		else
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                   			printf("face board port cannot write,Line:%d\n",__LINE__);
                                		#endif
                                		}
										sleep(pinfo.rtime);
									}

									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),nc,0x02))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
						
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			nc,0x02,fcdata->markbit))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									ncmode = *(fcdata->contmode);
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = /*29*/ncmode;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (tcbuf[1] - 1));

										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == nc[i])
                    							break;
                							sinfo.chans += 1;
                							tcsta = nc[i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
                							tcsta |= 0x02;
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));					
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = tcbuf[1];
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = 0;
                                        dctd.phaseid = tcbuf[1];
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = 0;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									cp = tcbuf[1];

									objecti[0].objectv[0] = 0xf4;
									factovs = 0;
									memset(cbuf,0,sizeof(cbuf));
									if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                            			printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									if (!(*(fcdata->markbit) & 0x1000))
									{
                            			write(*(fcdata->sockfd->csockfd),cbuf,factovs);
									}
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,88,ct.tv_sec,fcdata->markbit);							
									continue;	
								}//control phase is not current phase
							}//control someone phase
							else if(0x27 == tcbuf[1])
							{//net step by step
								fpc = 0;
								if ((1 == dcred) || (1 == close) || (1 == dcyfyes) || (1 == phcon))	
								{
									phcon = 0;
									dcred = 0;
									close = 0;
									if (1 == dcyfyes)
									{
										pthread_cancel(dcyfid);
										pthread_join(dcyfid,NULL);
										dcyfyes = 0;
									}
									if (1 != dcred)
									{
										new_all_red(&ardata);
									}
									dcred = 0;
									close = 0;
				//					#ifdef CLOSE_LAMP
                                    ms_set_lamp_color(*(fcdata->bbserial),clch,0x03);
									update_channel_status(fcdata->sockfd,chanstatus,clch,0x03,fcdata->markbit);
               //                     #endif
									if (0 == cp)
									{//not have phase control
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
                                    		*(fcdata->markbit) |= 0x0800;
                                		}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    					pinfo.chan,0x02,fcdata->markbit))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               			#endif
                                		}

										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											sinfo.conmode = 29;
											sinfo.color = 0x02;
											sinfo.time = 0;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											sinfo.phase = 0;
											sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
											/*				
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								sinfo.chans += 1;
                								tcsta = i + 1;
                								tcsta <<= 2;
                								tcsta &= 0xfc;
												for (j = 0; j < MAX_CHANNEL; j++)
												{
													if (0 == pinfo.chan[j])
														break;
													if ((i+1) == pinfo.chan[j])
													{
														tcsta |= 0x02;
														break;
													}
												}
                								*csta = tcsta;
                								csta++;
            								}*/
											sinfo.chans = 0;
											memset(sinfo.csta,0,sizeof(sinfo.csta));
                                            csta = sinfo.csta;
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == pinfo.chan[i])
													break;
												sinfo.chans += 1;
												tcsta = pinfo.chan[i];
												tcsta <<= 2;
												tcsta &= 0xfc;
												tcsta |= 0x02; //00000010-green 
												*csta = tcsta;
												csta++;
											}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//not have phase control
									else
									{//have phase control
										if ((0x5a <= cp) && (cp <= 0x5d))
										{//if ((0x5a <= cp) && (cp <= 0x5d))
											if (SUCCESS != \
												ms_set_lamp_color(*(fcdata->bbserial),lkch[cp-0x5a],0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																		lkch[cp-0x5a],0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = cp;
												sinfo.color = 0x02;
												sinfo.time = 0;
												sinfo.stage = pinfo.stageline;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
											/*
												sinfo.chans = 0;
												memset(sinfo.csta,0,sizeof(sinfo.csta));
												csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													sinfo.chans += 1;
													tcsta = i + 1;
													tcsta <<= 2;
													tcsta &= 0xfc;
													for (j = 0; j < MAX_CHANNEL; j++)
													{
														if (0 == lkch[cp-0x5a][j])
															break;
														if ((i+1) == lkch[cp-0x5a][j])
														{
															tcsta |= 0x02;
															break;
														}
													}
													*csta = tcsta;
													csta++;
												}
												*/
												sinfo.chans = 0;
												memset(sinfo.csta,0,sizeof(sinfo.csta));
                                                csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == lkch[cp-0x5a][i])
														break;
													sinfo.chans += 1;
													tcsta = lkch[cp-0x5a][i];
													tcsta <<= 2;
													tcsta &= 0xfc;
													tcsta |= 0x02; //00000010-green 
													*csta = tcsta;
													csta++;
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}//if ((0x5a <= cp) && (cp <= 0x5d))
										else if (0xC8 == cp)
										{//else if (0xC8 == cp)
											memset(ccon,0,sizeof(ccon));
                                            j = 0;
                                            for (i = 0; i < MAX_CHANNEL; i++)
                                            {
                                                if (*(fcdata->ccontrol) & (0x00000001 << i))
                                                {
                                                    #ifdef CLOSE_LAMP
                                                    if (((i+1) >= 5) && ((i+1) <= 12))
                                                    {
                                                        if (*(fcdata->specfunc) & (0x01 << ((i+1) - 5)))
                                                            continue;
                                                    }
                                                    #else
                                                    if((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
                                                    {
                                                        tclc = i + 1;
                                                        if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                                                            continue;
                                                    }
                                                   if((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((5 <= tclc) && (tclc <= 8))
                                                            continue;
                                                    }
                                                   if((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((9 <= tclc) && (tclc <= 12))
                                                            continue;
                                                    }
													#endif
                                                    ccon[j] = i + 1;
                                                    j++;
                                                }
                                            }
                                            if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),ccon,0x02))
                                            {
                                            #ifdef FULL_DETECT_DEBUG
                                                printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                            #endif
                                                *(fcdata->markbit) |= 0x0800;
                                            }
                                            if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                                                                ccon,0x02,fcdata->markbit))
                                            {
                                            #ifdef FULL_DETECT_DEBUG
                                                printf("update err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                            #endif
                                            }
                                            if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
                                            {//report info to server actively
                                                sinfo.conmode = 29;
                                                sinfo.color = 0x02;
                                                sinfo.time = 0;
                                                sinfo.stage = pinfo.stageline;
                                                sinfo.cyclet = 0;
                                                sinfo.phase = 0;

                                                sinfo.chans = 0;
                                                memset(sinfo.csta,0,sizeof(sinfo.csta));
                                                csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
                                                {
                                                    if (0 == ccon[i])
                                                        break;
                                                    sinfo.chans += 1;
                                                    tcsta = ccon[i];
                                                    tcsta <<= 2;
                                                    tcsta &= 0xfc;
                                                    tcsta |= 0x02; //00000010-green 
                                                    *csta = tcsta;
                                                    csta++;
                                                }
                                                memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
                                                memset(sibuf,0,sizeof(sibuf));
                                                if (SUCCESS != status_info_report(sibuf,&sinfo))
                                                {
                                                #ifdef FULL_DETECT_DEBUG
                                                    printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                                #endif
                                                }
                                                else
                                                {
                                                    write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
                                                }
                                            }//report info to server actively
										}//else if (0xC8 == cp)
										else if ((0x01 <= cp) && (cp <= 0x20))
										{//else if ((0x01 <= cp) && (cp <= 0x20))
											memset(cc,0,sizeof(cc));
											pcc = cc;
											for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
											{
												if (0 == (tscdata->channel->ChannelList[i].ChannelId))
													break;
												if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
												{
													#ifdef CLOSE_LAMP
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((tclc >= 0x05) && (tclc <= 0x0c))
													{
														if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
															continue;
													}
													#else
													if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
													{
														tclc = tscdata->channel->ChannelList[i].ChannelId;
														if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
															continue;
													}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
													{
														tclc = tscdata->channel->ChannelList[i].ChannelId;
														if ((5 <= tclc) && (tclc <= 8))
															continue;
													}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
													{
														tclc = tscdata->channel->ChannelList[i].ChannelId;
														if ((9 <= tclc) && (tclc <= 12))
															continue;
													}
													#endif
													*pcc = tscdata->channel->ChannelList[i].ChannelId;
													pcc++;
												}
											}
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),cc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				cc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("update err,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											if((!(*(fcdata->markbit)&0x1000))&&(!(*(fcdata->markbit)&0x8000)))
											{//report info to server actively
												sinfo.conmode = 29;
												sinfo.color = 0x02;
												sinfo.time = 0;
												sinfo.stage = pinfo.stageline;
												sinfo.cyclet = 0;
												sinfo.phase = 0;
												sinfo.phase |= (0x01 << (cp - 1));
											/*
												sinfo.chans = 0;
												memset(sinfo.csta,0,sizeof(sinfo.csta));
												csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													sinfo.chans += 1;
													tcsta = i + 1;
													tcsta <<= 2;
													tcsta &= 0xfc;
													for (j = 0; j < MAX_CHANNEL; j++)
													{
														if (0 == cc[j])
															break;
														if ((i+1) == cc[j])
														{
															tcsta |= 0x02;
															break;
														}
													}
													*csta = tcsta;
													csta++;
												}
											*/
												sinfo.chans = 0;
												memset(sinfo.csta,0,sizeof(sinfo.csta));
                                                csta = sinfo.csta;
												for (i = 0; i < MAX_CHANNEL; i++)
												{
													if (0 == cc[i])
														break;
													sinfo.chans += 1;
													tcsta = cc[i];
													tcsta <<= 2;
													tcsta &= 0xfc;
													tcsta |= 0x02; //00000010-green 
													*csta = tcsta;
													csta++;
												}
												memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
												memset(sibuf,0,sizeof(sibuf));
												if (SUCCESS != status_info_report(sibuf,&sinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
												#endif
												}
												else
												{
													write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
												}
											}//report info to server actively
										}//else if ((0x01 <= cp) && (cp <= 0x20))
									}//have phase control
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,80,ct.tv_sec,fcdata->markbit);
									continue;
								}//if ((1 == dcred) || (1 == close) || (1 == dcyfyes))

								if (0 == cp)
								{
								if ((0==pinfo.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))
								{
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = /*29*/ncmode;
										sinfo.color = 0x02;
										sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
											if (0 == pinfo.chan[i])
												break;
                							sinfo.chans += 1;
                							tcsta = pinfo.chan[i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
											tcsta |= 0x02;
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
								}//if ((0==pinfo.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))

								if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))
								{
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = /*28*/ncmode;
										sinfo.color = 0x03;
										sinfo.time = pinfo.gftime;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
									
										for (i = 0; i < MAX_CHANNEL; i++)
                                		{
                                			if (0 == pinfo.cchan[i])
                                        		break;
                                    		for (j = 0; j < sinfo.chans; j++)
                                    		{
                                        		if (0 == sinfo.csta[j])
                                            		break;
                                        		tcsta = sinfo.csta[j];
                                        		tcsta &= 0xfc;
                                        		tcsta >>= 2;
                                        		tcsta &= 0x3f;
                                        		if (pinfo.cchan[i] == tcsta)
                                        		{
                                            		sinfo.csta[j] &= 0xfc;
                                           			sinfo.csta[j] |= 0x03; //00000001-green flash
													break;
                                        		}
                                    		}
                                		}								
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
								}//if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))

								//current phase begin to green flash
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 29;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = pinfo.gftime;
									dctd.phaseid = pinfo.phaseid;
									dctd.stageline = pinfo.stageline;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 29;//traffic control
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x02;
                                    dctd.lamptime = pinfo.gftime;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;		
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 29;
                            	fbdata[2] = pinfo.stageline;
                            	fbdata[3] = 0x02;
                            	fbdata[4] = pinfo.gftime;
                            	if (!wait_write_serial(*(fcdata->fbserial)))
                            	{
                                	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                	#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    	if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
                                	}
                            	}
                            	else
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            	#endif
                            	}
								if (pinfo.gftime > 0)
								{	
									ngf = 0;
									while (1)
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x03))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																pinfo.cchan,0x03,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);

										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x02))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			pinfo.cchan,0x02,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);
									
										ngf += 1;
										if (ngf >= pinfo.gftime)
											break;
									}
								}//if (pinfo.gftime > 0)
								if (1 == (pinfo.cpcexist))
								{
									//current phase begin to yellow lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cnpchan,0x01))
        							{
        							#ifdef FULL_DETECT_DEBUG
            							printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        							#endif
										*(fcdata->markbit) |= 0x0800;
        							}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
													pinfo.cnpchan,0x01, fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cpchan,0x00))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																	pinfo.cpchan,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
								}
								else
								{
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x01))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														pinfo.cchan,0x01,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
								}

								if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))
								{
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = /*29*/ncmode;
										sinfo.color = 0x01;
										sinfo.time = pinfo.ytime;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
										for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == pinfo.cnpchan[i])
                    							break;
                							for (j = 0; j < sinfo.chans; j++)
                							{
                    							if (0 == sinfo.csta[j])
                        							break;
                    							tcsta = sinfo.csta[j];
                    							tcsta &= 0xfc;
                    							tcsta >>= 2;
                    							tcsta &= 0x3f;
                    							if (pinfo.cnpchan[i] == tcsta)
                    							{
                        							sinfo.csta[j] &= 0xfc;
													sinfo.csta[j] |= 0x01; //00000001-yellow
													break;
                    							}
                							}
            							}
										for (i = 0; i < MAX_CHANNEL; i++)
                                		{
                                			if (0 == pinfo.cpchan[i])
                                        		break;
                                    		for (j = 0; j < sinfo.chans; j++)
                                    		{
                                        		if (0 == sinfo.csta[j])
                                            		break;
                                        		tcsta = sinfo.csta[j];
                                        		tcsta &= 0xfc;
                                        		tcsta >>= 2;
                                        		tcsta &= 0x3f;
                                        		if (pinfo.cpchan[i] == tcsta)
                                        		{
                                            		sinfo.csta[j] &= 0xfc;
													break;
                                        		}
                                    		}
                                		}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
								}//if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))

								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            	{
                               		memset(&dctd,0,sizeof(dctd));
                               		dctd.mode = 29;//traffic control
                               		dctd.pattern = *(fcdata->patternid);
                               		dctd.lampcolor = 0x01;
                               		dctd.lamptime = pinfo.ytime;
                               		dctd.phaseid = pinfo.phaseid;
                               		dctd.stageline = pinfo.stageline;
                               		if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                               		{
                               		#ifdef FULL_DETECT_DEBUG
                                   		printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               		#endif
                               		}
                            	}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 29;//traffic control
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x01;
                                    dctd.lamptime = pinfo.ytime;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;		
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 29;
                            	fbdata[2] = pinfo.stageline;
                            	fbdata[3] = 0x01;
                            	fbdata[4] = pinfo.ytime;
                            	if (!wait_write_serial(*(fcdata->fbserial)))
                            	{
                               		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               		{
                               		#ifdef FULL_DETECT_DEBUG
                                   		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               		#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
                                   		update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                   		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   		{
                                   		#ifdef FULL_DETECT_DEBUG
                                       		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   		#endif
                                   		}
                               		}
                            	}
                            	else
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                               		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            	#endif
                            	}
								sleep(pinfo.ytime);

								//current phase begin to red lamp
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x00))
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
									*(fcdata->markbit) |= 0x0800;
                            	}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.cchan,0x00,fcdata->markbit))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}

								if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))
								{
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = /*29*/ncmode;
										sinfo.color = 0x00;
										sinfo.time = pinfo.rtime;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
										for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == pinfo.cchan[i])
                    							break;
                							for (j = 0; j < sinfo.chans; j++)
                							{
                    							if (0 == sinfo.csta[j])
                        							break;
                    							tcsta = sinfo.csta[j];
                    							tcsta &= 0xfc;
                    							tcsta >>= 2;
                    							tcsta &= 0x3f;
                    							if (pinfo.cchan[i] == tcsta)
                    							{
                        							sinfo.csta[j] &= 0xfc;
													break;
                    							}
                							}
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively
								}//if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))

								if (pinfo.rtime > 0)
								{
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                                		memset(&dctd,0,sizeof(dctd));
                                		dctd.mode = 29;//traffic control
                                		dctd.pattern = *(fcdata->patternid);
                                		dctd.lampcolor = 0x00;
                                		dctd.lamptime = pinfo.rtime;
                                		dctd.phaseid = pinfo.phaseid;
                                		dctd.stageline = pinfo.stageline;
                                		if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                		#endif
                                		}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x00;
                                        dctd.lamptime = pinfo.rtime;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                                	fbdata[2] = pinfo.stageline;
                                	fbdata[3] = 0x00;
                                	fbdata[4] = pinfo.rtime;
                                	if (!wait_write_serial(*(fcdata->fbserial)))
                                	{
                                    	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                        	update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                        	if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                        	{
                                        	#ifdef FULL_DETECT_DEBUG
                                            	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        	#endif
                                        	}
                                    	}
                                	}
                                	else
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                	#endif
                                	}
									sleep(pinfo.rtime);
								}

								*(fcdata->slnum) += 1;
								*(fcdata->stageid) = \
									tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
								if (0 == (tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId))
								{
									*(fcdata->slnum) = 0;
									*(fcdata->stageid) = \
										tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
								}
								//get phase info of next phase
								memset(&pinfo,0,sizeof(pinfo));
        						if (SUCCESS != ms_get_phase_info(fcdata,tscdata,rettl,*(fcdata->slnum),&pinfo))
        						{
        						#ifdef FULL_DETECT_DEBUG
            						printf("get phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
									output_log("Timing control,get phase info err");
        						#endif
									ms_end_part_child_thread();
            						return FAIL;
        						}
        						*(fcdata->phaseid) = 0;
        						*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));

								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
									*(fcdata->markbit) |= 0x0800;
                            	}
						
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																pinfo.chan,0x02,fcdata->markbit))
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
                            	}
								ncmode = *(fcdata->contmode);
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = /*29*/ncmode;
									sinfo.color = 0x02;
									sinfo.time = 0;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
										if (0 == pinfo.chan[i])
											break;
                						sinfo.chans += 1;
                						tcsta = pinfo.chan[i];
                						tcsta <<= 2;
                						tcsta &= 0xfc;
										tcsta |= 0x02;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
	
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 29;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = 0;
									dctd.phaseid = pinfo.phaseid;
									dctd.stageline = pinfo.stageline;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 29;//traffic control
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x02;
                                    dctd.lamptime = 0;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;		
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 29;
                            	fbdata[2] = pinfo.stageline;
                            	fbdata[3] = 0x02;
                            	fbdata[4] = 0;
                            	if (!wait_write_serial(*(fcdata->fbserial)))
                            	{
                                	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                	#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    	if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
                                	}
                            	}
                            	else
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            	#endif
                            	}							
								}//0 == cp
								if (0 != cp)
								{
									if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
									{//if ((0x5a <= cp) && (cp <= 0x5d))
										*(fcdata->slnum) = 0;
										*(fcdata->stageid) = \
												tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
										memset(&pinfo,0,sizeof(pinfo));
										if(SUCCESS != ms_get_phase_info(fcdata,tscdata,rettl,0,&pinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
											output_log("Timing control,get phase info err");
										#endif
											ms_end_part_child_thread();
											return FAIL;
										}
										*(fcdata->phaseid) = 0;
										*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));
										memset(cc,0,sizeof(cc));
                                        pcc = cc;
										if ((0x5a <= cp) && (cp <= 0x5d))
                                        {
											for (i = 0; i < MAX_CHANNEL; i++)
											{
												if (0 == lkch[cp-0x5a][i])
													break;
												*pcc = lkch[cp-0x5a][i];
												pcc++;
											}
										}
										else if (0xC8 == cp)
										{
											for (i = 0; i < MAX_CHANNEL; i++)
                                            {
                                                if (*(fcdata->ccontrol) & (0x00000001 << i))
                                                {
                                                    #ifdef CLOSE_LAMP
                                                    if (((i+1) >= 5) && ((i+1) <= 12))
                                                    {
                                                        if (*(fcdata->specfunc) & (0x01 << ((i+1) - 5)))
                                                            continue;
                                                    }
                                                    #else
                                                    if((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
                                                    {
                                                        tclc = i + 1;
                                                        if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                                                            continue;
                                                    }
                                                   if((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((5 <= tclc) && (tclc <= 8))
                                                            continue;
                                                    }
                                                   if((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
                                                    {
                                                        tclc = i + 1;
                                                        if ((9 <= tclc) && (tclc <= 12))
                                                            continue;
                                                    }
                                                    #endif
                                                    *pcc = i + 1;
													pcc++;
                                                }
                                            }
										}//else if (0xC8 == cp)
                                        memset(wcc,0,sizeof(wcc));
                                        memset(wnpcc,0,sizeof(wnpcc));
                                        memset(wpcc,0,sizeof(wpcc));
                                        z = 0;
                                        k = 0;
                                        s = 0;
                                        pce = 0;
                                        for (i = 0; i < MAX_CHANNEL; i++)
                                        {//for (i = 0; i < MAX_CHANNEL; i++)
                                            if (0 == cc[i])
                                                break;
                                            ce = 0;
											for (j = 0; j < MAX_CHANNEL; j++)
                                            {
                                                if (0 == pinfo.chan[j])
                                                    break;
                                                if (pinfo.chan[j] == cc[i])
                                                {
                                                    ce = 1;
                                                    break;
                                                }
                                            }
                                            if (0 == ce)
                                            {
                                                wcc[z] = cc[i];
                                                z++;
                                                if ((0x0d <= cc[i]) && (cc[i] <= 0x10))
                                                {
                                                    wpcc[k] = cc[i];
                                                    k++;
                                                    pce = 1;
                                                    continue;
                                                }
                                                else
                                                {
                                                    wnpcc[s] = cc[i];
                                                    s++;
                                                    continue;
                                                }
                                            }
										}
									}//if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
									else if ((0x01 <= cp) && (cp <= 0x20))
									{//else if ((0x01 <= cp) && (cp <= 0x20))
										for (i = 0; i < (tscdata->timeconfig->FactStageNum); i++)
										{
											if (0 == (tscdata->timeconfig->TimeConfigList[rettl][i].StageId))
												break;
											rpi = tscdata->timeconfig->TimeConfigList[rettl][i].PhaseId;
											rpc = 0;
											get_phase_id(rpi,&rpc);
											if (cp == rpc)
											{
												break;
											}
										}
										if (i != (tscdata->timeconfig->FactStageNum))
										{
											if (0 == (tscdata->timeconfig->TimeConfigList[rettl][i+1].StageId))
											{
												*(fcdata->slnum) = 0;
												*(fcdata->stageid) = \
												tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
												memset(&pinfo,0,sizeof(pinfo));
												if(SUCCESS != ms_get_phase_info(fcdata,tscdata,rettl,0,&pinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("Timing control,get phase info err");
												#endif
													ms_end_part_child_thread();
													return FAIL;
												}
												*(fcdata->phaseid) = 0;
												*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));
											}
											else
											{
												*(fcdata->slnum) = i + 1;
												*(fcdata->stageid) = \
													tscdata->timeconfig->TimeConfigList[rettl][i+1].StageId;
												memset(&pinfo,0,sizeof(pinfo));
												if(SUCCESS!=ms_get_phase_info(fcdata,tscdata,rettl,i+1,&pinfo))
												{
												#ifdef FULL_DETECT_DEBUG
													printf("info err,File: %s,Line: %d\n",__FILE__,__LINE__);
													output_log("Timing control,get phase info err");
												#endif
													ms_end_part_child_thread();
													return FAIL;
												}
												*(fcdata->phaseid) = 0;
												*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));
											}
										}//if (i != (tscdata->timeconfig->FactStageNum))
										else
										{
											*(fcdata->slnum) = 0;
											*(fcdata->stageid) = \
													tscdata->timeconfig->TimeConfigList[rettl][0].StageId;
											memset(&pinfo,0,sizeof(pinfo));
											if(SUCCESS != ms_get_phase_info(fcdata,tscdata,rettl,0,&pinfo))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
												output_log("Timing control,get phase info err");
											#endif
												ms_end_part_child_thread();
												return FAIL;
											}
											*(fcdata->phaseid) = 0;
											*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));
										}//if (i == (tscdata->timeconfig->FactStageNum))

										memset(cc,0,sizeof(cc));
										pcc = cc;
										memset(wcc,0,sizeof(wcc));
										memset(wnpcc,0,sizeof(wnpcc));
										memset(wpcc,0,sizeof(wpcc));
										z = 0;
										k = 0;
										s = 0;
										pce = 0;
										for (i = 0; i < (tscdata->channel->FactChannelNum); i++)
										{
											if (0 == (tscdata->channel->ChannelList[i].ChannelId))
												break;
											if (cp == (tscdata->channel->ChannelList[i].ChannelCtrlSrc))
											{
												#ifdef CLOSE_LAMP
                                                tclc = tscdata->channel->ChannelList[i].ChannelId;
                                                if ((tclc >= 0x05) && (tclc <= 0x0c))
                                                {
                                                    if (*(fcdata->specfunc) & (0x01 << (tclc - 5)))
                                                        continue;
                                                }
												#else
												if ((*(fcdata->specfunc)&0x10)&&(*(fcdata->specfunc)&0x20))
            									{
                									tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if(((5<=tclc)&&(tclc<=8)) || ((9<=tclc)&&(tclc<=12)))
                    									continue;
            									}
												if ((*(fcdata->specfunc)&0x10)&&(!(*(fcdata->specfunc)&0x20)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
													if ((5 <= tclc) && (tclc <= 8))
														continue;
												}
												if ((*(fcdata->specfunc)&0x20)&&(!(*(fcdata->specfunc)&0x10)))
												{
													tclc = tscdata->channel->ChannelList[i].ChannelId;
                									if ((9 <= tclc) && (tclc <= 12))
                    									continue;
												}
                                                #endif
												*pcc = tscdata->channel->ChannelList[i].ChannelId;
												pcc++;
												ce = 0;
												for (j = 0; j < MAX_CHANNEL; j++)
												{
													if (0 == pinfo.chan[j])
														break;
												if (pinfo.chan[j]==tscdata->channel->ChannelList[i].ChannelId)
													{
														ce = 1;
														break;
													}
												}
												if (0 == ce)
												{
													wcc[z] = tscdata->channel->ChannelList[i].ChannelId;
													z++;
													if (3 == tscdata->channel->ChannelList[i].ChannelType)
													{
														wpcc[k] = tscdata->channel->ChannelList[i].ChannelId;
														k++;
														pce = 1;
														continue;
													}
													else
													{
														wnpcc[s] = tscdata->channel->ChannelList[i].ChannelId;
														s++;
														continue;
													}		
												}
											}
										}
									}//else if ((0x01 <= cp) && (cp <= 0x20))

									if((0==wcc[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x02;
											sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
											sinfo.chans = 0;
            								memset(sinfo.csta,0,sizeof(sinfo.csta));
            								csta = sinfo.csta;
            								for (i = 0; i < MAX_CHANNEL; i++)
            								{
												if (0 == cc[i])
													break;
                								sinfo.chans += 1;
                								tcsta = cc[i];
                								tcsta <<= 2;
                								tcsta &= 0xfc;
												tcsta |= 0x02;
                								*csta = tcsta;
                								csta++;
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//info.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))

									if ((0 != wcc[0]) && (pinfo.gftime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*28*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x03;
											sinfo.time = pinfo.gftime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == wcc[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (wcc[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
                                           				sinfo.csta[j] |= 0x03; //00000001-green flash
														break;
                                        			}
                                    			}
                                			}								
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))

									//current phase begin to green flash
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = pinfo.gftime;
										dctd.phaseid = cp;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = pinfo.gftime;
                                        dctd.phaseid = cp;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = pinfo.gftime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                                		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                    		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                    		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
                                    		}
                                		}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									if (pinfo.gftime > 0)
									{	
										ngf = 0;
										while (1)
										{
											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x03,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("updatechannelerr,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);

											if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("setgreenlamperr,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
												*(fcdata->markbit) |= 0x0800;
											}
											if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wcc,0x02,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("updatechannelerr,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
											to.tv_sec = 0;
											to.tv_usec = 500000;
											select(0,NULL,NULL,NULL,&to);
									
											ngf += 1;
											if (ngf >= pinfo.gftime)
												break;
										}
									}//if (pinfo.gftime > 0)
									if (1 == pce)
									{
										//current phase begin to yellow lamp
										if (SUCCESS!=ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
        								{
        								#ifdef FULL_DETECT_DEBUG
            								printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
        								#endif
											*(fcdata->markbit) |= 0x0800;
        								}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}
									else
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														wcc,0x01,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}

									if ((0 != wcc[0]) && (pinfo.ytime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x01;
											sinfo.time = pinfo.ytime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                            {
                                                sinfo.phase = 0;
                                            }
	
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wnpcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wnpcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														sinfo.csta[j] |= 0x01; //00000001-yellow
														break;
                    								}
                								}
            								}
											for (i = 0; i < MAX_CHANNEL; i++)
                                			{
                                				if (0 == wpcc[i])
                                        			break;
                                    			for (j = 0; j < sinfo.chans; j++)
                                    			{
                                        			if (0 == sinfo.csta[j])
                                            			break;
                                        			tcsta = sinfo.csta[j];
                                        			tcsta &= 0xfc;
                                        			tcsta >>= 2;
                                        			tcsta &= 0x3f;
                                        			if (wpcc[i] == tcsta)
                                        			{
                                            			sinfo.csta[j] &= 0xfc;
														break;
                                        			}
                                    			}
                                			}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            		{
                               			memset(&dctd,0,sizeof(dctd));
                               			dctd.mode = 29;//traffic control
                               			dctd.pattern = *(fcdata->patternid);
                               			dctd.lampcolor = 0x01;
                               			dctd.lamptime = pinfo.ytime;
                               			dctd.phaseid = cp;
                               			dctd.stageline = pinfo.stageline;
                               			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               			#endif
                               			}
                            		}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x01;
                                        dctd.lamptime = pinfo.ytime;
                                        dctd.phaseid = cp;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x01;
                            		fbdata[4] = pinfo.ytime;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
									sleep(pinfo.ytime);

									//current phase begin to red lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                                		printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															wcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}

									if ((0 != wcc[0]) && (pinfo.rtime > 0))
									{
										if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
										{//report info to server actively
											if ((0x01 <= cp) && (cp <= 0x20))
                                                sinfo.conmode = /*29*/ncmode;
                                            else if ((0x5a <= cp) && (cp <= 0x5d))
                                                sinfo.conmode = cp;
											else if (0xC8 == cp)
                                                sinfo.conmode = 29;
											sinfo.color = 0x00;
											sinfo.time = pinfo.rtime;
											sinfo.stage = pinfo.stageline;
											sinfo.cyclet = 0;
											if ((0x01 <= cp) && (cp <= 0x20))
                                            {
                                                sinfo.phase = 0;
                                                sinfo.phase |= (0x01 << (cp - 1));
                                            }
                                            else if (((0x5a <= cp) && (cp <= 0x5d)) || (0xC8 == cp))
                                                sinfo.phase = 0;
	
											for (i = 0; i < MAX_CHANNEL; i++)
            								{
                								if (0 == wcc[i])
                    								break;
                								for (j = 0; j < sinfo.chans; j++)
                								{
                    								if (0 == sinfo.csta[j])
                        								break;
                    								tcsta = sinfo.csta[j];
                    								tcsta &= 0xfc;
                    								tcsta >>= 2;
                    								tcsta &= 0x3f;
                    								if (wcc[i] == tcsta)
                    								{
                        								sinfo.csta[j] &= 0xfc;
														break;
                    								}
                								}
            								}
											memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            								memset(sibuf,0,sizeof(sibuf));
            								if (SUCCESS != status_info_report(sibuf,&sinfo))
            								{
            								#ifdef FULL_DETECT_DEBUG
                								printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            								#endif
            								}
            								else
            								{
                								write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            								}
										}//report info to server actively
									}//if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))

									if (pinfo.rtime > 0)
									{
										if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            			{
                                			memset(&dctd,0,sizeof(dctd));
                                			dctd.mode = 29;//traffic control
                                			dctd.pattern = *(fcdata->patternid);
                                			dctd.lampcolor = 0x00;
                                			dctd.lamptime = pinfo.rtime;
                                			dctd.phaseid = cp;
                                			dctd.stageline = pinfo.stageline;
                                			if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                			{
                                			#ifdef FULL_DETECT_DEBUG
                                    			printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                			#endif
                                			}
                            			}
										#ifdef EMBED_CONFIGURE_TOOL
										if (*(fcdata->markbit2) & 0x0200)
										{
											memset(&dctd,0,sizeof(dctd));
                                            dctd.mode = 29;//traffic control
                                            dctd.pattern = *(fcdata->patternid);
                                            dctd.lampcolor = 0x00;
                                            dctd.lamptime = pinfo.rtime;
                                            dctd.phaseid = cp;
                                            dctd.stageline = pinfo.stageline;		
											if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
											#endif
											}
										}
										#endif
										fbdata[1] = 29;
                                		fbdata[2] = pinfo.stageline;
                                		fbdata[3] = 0x00;
                                		fbdata[4] = pinfo.rtime;
                                		if (!wait_write_serial(*(fcdata->fbserial)))
                                		{
                                    		if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                    		{
                                    		#ifdef FULL_DETECT_DEBUG
                                        		printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    		#endif
												*(fcdata->markbit) |= 0x0800;
												gettimeofday(&ct,NULL);
                                        		update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
                                        		if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																			fcdata->softevent,fcdata->markbit))
                                        		{
                                        		#ifdef FULL_DETECT_DEBUG
                                            		printf("file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        		#endif
                                        		}
                                    		}
                                		}
                                		else
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                		#endif
                                		}
										sleep(pinfo.rtime);
									}
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
										*(fcdata->markbit) |= 0x0800;
                            		}
						
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			pinfo.chan,0x02,fcdata->markbit))
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            		#endif
                            		}
									ncmode = *(fcdata->contmode);
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = /*29*/ncmode;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.phase |= (0x01 << (pinfo.phaseid - 1));

										sinfo.chans = 0;
            							memset(sinfo.csta,0,sizeof(sinfo.csta));
            							csta = sinfo.csta;
            							for (i = 0; i < MAX_CHANNEL; i++)
            							{
                							if (0 == pinfo.chan[i])
                    							break;
                							sinfo.chans += 1;
                							tcsta = pinfo.chan[i];
                							tcsta <<= 2;
                							tcsta &= 0xfc;
                							tcsta |= 0x02;
                							*csta = tcsta;
                							csta++;
            							}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            							memset(sibuf,0,sizeof(sibuf));
            							if (SUCCESS != status_info_report(sibuf,&sinfo))
            							{
            							#ifdef FULL_DETECT_DEBUG
                							printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            							#endif
            							}
            							else
            							{
                							write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            							}
									}//report info to server actively									
	
									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 29;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = pinfo.phaseid;
										dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
                                        dctd.mode = 29;//traffic control
                                        dctd.pattern = *(fcdata->patternid);
                                        dctd.lampcolor = 0x02;
                                        dctd.lamptime = 0;
                                        dctd.phaseid = pinfo.phaseid;
                                        dctd.stageline = pinfo.stageline;		
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 29;
                            		fbdata[2] = pinfo.stageline;
                            		fbdata[3] = 0x02;
                            		fbdata[4] = 0;
                            		if (!wait_write_serial(*(fcdata->fbserial)))
                            		{
                               			if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               			{
                               			#ifdef FULL_DETECT_DEBUG
                                   			printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               			#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
                                   			update_event_list(fcdata->ec,fcdata->el,1,16, \
																	ct.tv_sec,fcdata->markbit);
                                   			if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                   			{
                                   			#ifdef FULL_DETECT_DEBUG
                                       			printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                   			#endif
                                   			}
                               			}
                            		}
                            		else
                            		{
                            		#ifdef FULL_DETECT_DEBUG
                               			printf("face board serial port cannot write,Line:%d\n",__LINE__);
                            		#endif
                            		}
								}//0 != cp

								cp = 0;
								objecti[0].objectv[0] = 0x28;
                                factovs = 0;
                                memset(cbuf,0,sizeof(cbuf));
                                if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                if (!(*(fcdata->markbit) & 0x1000))
                                {
                                    write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                }
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,80,ct.tv_sec,fcdata->markbit);

                                continue;
							}//net step by step
							else if(0x21 == tcbuf[1])
							{//yellow flash
								dcred = 0;
								close = 0;
								cp = 0;
								if (0 == dcyfyes)
								{
									memset(&yfdata,0,sizeof(yfdata));
									yfdata.second = 0;
									yfdata.markbit = fcdata->markbit;
									yfdata.markbit2 = fcdata->markbit2;
									yfdata.serial = *(fcdata->bbserial);
									yfdata.sockfd = fcdata->sockfd;
									yfdata.cs = chanstatus;	
#ifdef FLASH_DEBUG
									char szInfo[32] = {0};
									char szInfoT[64] = {0};
									snprintf(szInfo,sizeof(szInfo)-1,"%s",__FUNCTION__);
									snprintf(szInfoT,sizeof(szInfoT)-1,"%d",__LINE__);
									tsc_save_eventlog(szInfo,szInfoT);
#endif
									int yfret = pthread_create(&dcyfid,NULL,(void *)ms_yellow_flash,&yfdata);
									if (0 != yfret)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
										output_log("Detect control,create yellow flash err");
									#endif
										ms_end_part_child_thread();
										objecti[0].objectv[0] = 0x24;
                                		factovs = 0;
                                		memset(cbuf,0,sizeof(cbuf));
                                		if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x00))
                                		{
                                		#ifdef FULL_DETECT_DEBUG
                                    		printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                		#endif
                                		}
                                		if (!(*(fcdata->markbit) & 0x1000))
                                		{
                                    		write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                		}

										return FAIL;
									}
									dcyfyes = 1;
								}
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 29;
									sinfo.color = 0x05;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;

									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i+1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));							
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
								ncmode = *(fcdata->contmode);
								objecti[0].objectv[0] = 0x24;
                                factovs = 0;
                                memset(cbuf,0,sizeof(cbuf));
                                if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                if (!(*(fcdata->markbit) & 0x1000))
                                {
                                    write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                }
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,79,ct.tv_sec,fcdata->markbit);
								continue;
							}//yellow flash
							else if (0x22 == tcbuf[1])
							{//all red
								close = 0;
								cp = 0;
								if (1 == dcyfyes)
								{
									pthread_cancel(dcyfid);
									pthread_join(dcyfid,NULL);
									dcyfyes = 0;
								}
					
								if (0 == dcred)
								{	
									new_all_red(&ardata);
									dcred = 1;
								}
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 29;
									sinfo.color = 0x00;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;

									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i+1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));						
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
								ncmode = *(fcdata->contmode);
								objecti[0].objectv[0] = 0x25;
                                factovs = 0;
                                memset(cbuf,0,sizeof(cbuf));
                                if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                if (!(*(fcdata->markbit) & 0x1000))
                                {
                                    write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                }
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,78,ct.tv_sec,fcdata->markbit);							
								continue;
							}//all red
							else if (0x23 == tcbuf[1])
							{//close lamp
								dcred = 0;
								cp = 0;
								if (1 == dcyfyes)
                                {
                                    pthread_cancel(dcyfid);
                                    pthread_join(dcyfid,NULL);
                                    dcyfyes = 0;
                                }
								if (0 == close)
                                {
                                    new_all_close(&acdata);
                                    close = 1;
                                }
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 29;
									sinfo.color = 0x04;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;

									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i+1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));						
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
								ncmode = *(fcdata->contmode);
								objecti[0].objectv[0] = 0x26;
                                factovs = 0;
                                memset(cbuf,0,sizeof(cbuf));
                                if (SUCCESS != control_data_pack(cbuf,&itype,objecti,&factovs,0x01))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                if (!(*(fcdata->markbit) & 0x1000))
                                {
                                    write(*(fcdata->sockfd->csockfd),cbuf,factovs);
                                }
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,81,ct.tv_sec,fcdata->markbit);
								continue;
							}//close lamp
						}//status of network control	
					}//net control is valid only when wireless and key control is invalid;
				}//network control
				else if ((0xDA == tcbuf[0]) && (0xED == tcbuf[2]))
				{//key traffic control
					if ((0 == wllock) && (0 == netlock) && (0 == wtlock))
					{//key lock or unlock is suessfully only when wireless lock or unlock is not valid;
						if (0x01 == tcbuf[1])
						{//lock or unlock
							if (0 == keylock)
							{
							#ifdef FULL_DETECT_DEBUG
								printf("**************************Prepare to lock,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
								get_ms_status(&color,&leatime);
							#ifdef FULL_DETECT_DEBUG
                                printf("*********************Prepare to lock,color:%d,File: %s,Line: %d\n",color,__FILE__,__LINE__);
                            #endif
								if (2 != color)
								{//lamp color is not green
									struct timeval			spatime;
									unsigned char			endlock = 0;
									while(1)
									{//inline while loop
										spatime.tv_sec = 0;
										spatime.tv_usec = 200000;
										select(0,NULL,NULL,NULL,&spatime);
										memset(tcbuf,0,sizeof(tcbuf));
										read(*(fcdata->conpipe),tcbuf,sizeof(tcbuf));
										if ((0xDA == tcbuf[0]) && (0xED == tcbuf[2]))
										{
											if (0x01 == tcbuf[1])
											{
												endlock = 1;
												break;
											}
										}
										get_ms_status(&color,&leatime);
										if (2 == color)
										{
											break;
										}
										else
										{
											continue;
										}
									}//inline while loop
									if (1 == endlock)
									{
										continue;
									}
								}//lamp color is not green
								#ifdef FULL_DETECT_DEBUG
                                printf("**************************Prepare to lock,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
								
								keylock = 1;
								dcred = 0;
								close = 0;
                                cktem = 0;
                                kstep = 0;
								ms_end_child_thread();//end man thread and its child thread

								*(fcdata->markbit2) |= 0x0002;
							#if 0
								new_all_red(&ardata);
							//	all_red(*(fcdata->bbserial),0);	
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									gettimeofday(&ct,NULL);
                					update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                					if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                					{
                					#ifdef FULL_DETECT_DEBUG
                    					printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                					#endif
                					}
									*(fcdata->markbit) |= 0x0800;
								}
						#endif
								if (*(fcdata->auxfunc) & 0x01)
                                {//if (*(fcdata->auxfunc) & 0x01)
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcdownti,sizeof(dcdownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcedownti,sizeof(dcedownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (*(fcdata->auxfunc) & 0x01)
                                
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x02;
									sinfo.time = 0;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						if (0 == pinfo.chan[i])
                    						break;
                						sinfo.chans += 1;
                						tcsta = pinfo.chan[i];
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						tcsta |= 0x02; //00000010-green
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
						
								*(fcdata->contmode) = 28;//traffic control mode
								//send current control info to face board
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 2;
								fbdata[4] = 0;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}
								sendfaceInfoToBoard(fcdata,fbdata);
								dcecho[1] = 0x01;
								if (*(fcdata->markbit2) & 0x0800)
								{//comes from side door serial
									*(fcdata->markbit2) &= 0xf7ff;
									if (!wait_write_serial(*(fcdata->sdserial)))
                                    {
                                        if (write(*(fcdata->sdserial),dcecho,sizeof(dcecho)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                            *(fcdata->markbit) |= 0x0800;
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                    #endif
                                    }
								}//comes from side door serial
								else
								{
									if (!wait_write_serial(*(fcdata->fbserial)))
									{
										if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
											update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
											if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																			fcdata->softevent,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
											}
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
								}

								//send down time to configure tool
                            	if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            	{
                                	memset(&dctd,0,sizeof(dctd));
                                	dctd.mode = 28;
                                	dctd.pattern = *(fcdata->patternid);
                                	dctd.lampcolor = 0x02;
                                	dctd.lamptime = 0;
                                	dctd.phaseid = pinfo.phaseid;
                                	dctd.stageline = pinfo.stageline;
                                	if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                	#endif
                                	}
                            	}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 28;
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x02;
                                    dctd.lamptime = 0;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;		
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    pinfo.chan,0x02,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG 
                                    printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
                                {//report info to server actively
                                    memset(err,0,sizeof(err));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != err_report(err,ct.tv_sec,22,1))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    { 
                                        write(*(fcdata->sockfd->csockfd),err,sizeof(err));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,27,ct.tv_sec,fcdata->markbit);
                                }//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
                                	update_event_list(fcdata->ec,fcdata->el,1,27,ct.tv_sec,fcdata->markbit);
								}
								continue;
							}//prepare to lock
							if (1 == keylock)
							{
							#ifdef FULL_DETECT_DEBUG
                                printf("Prepare to unlock,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
								kstep = 0;
								cktem = 0;
								keylock = 0;
								dcred = 0;
								close = 0;
								if (1 == dcyfyes)
								{
									pthread_cancel(dcyfid);
									pthread_join(dcyfid,NULL);
									dcyfyes = 0;
								}
								dcecho[1] = 0x00;
								//tell face board that traffic control is canceled;
								if (*(fcdata->markbit2) & 0x0800)
                                {//comes from side door serial
                                    *(fcdata->markbit2) &= 0xf7ff;
                                    if (!wait_write_serial(*(fcdata->sdserial)))
                                    {
                                        if (write(*(fcdata->sdserial),dcecho,sizeof(dcecho)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                            *(fcdata->markbit) |= 0x0800;
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                    #endif
                                    }
                                }//comes from side door serial
								else
								{
									if (!wait_write_serial(*(fcdata->fbserial)))
									{
										if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
											gettimeofday(&ct,NULL);
											update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
											if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																			fcdata->softevent,fcdata->markbit))
											{
											#ifdef FULL_DETECT_DEBUG
												printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
											#endif
											}
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
								}

								new_all_red(&ardata);
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x00;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
															
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i + 1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
						//		all_red(*(fcdata->bbserial),0);
								*(fcdata->markbit2) &= 0xfffd;
								*(fcdata->contmode) = contmode;//restore control mode
								if (0 == dcyes)
								{
									memset(&dcdata,0,sizeof(dcdata));
        							memset(&pinfo,0,sizeof(pinfo));
        							dcdata.fd = fcdata;
        							dcdata.td = tscdata;
        							dcdata.pi = &pinfo;
        							dcdata.cs = chanstatus;
        							int dcret = pthread_create(&dcpid,NULL, \
													(void *)start_major_salve_control,&dcdata);
        							if (0 != dcret)
        							{
        							#ifdef FULL_DETECT_DEBUG
            							printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
										output_log("detect control,create full detect thread err");
        							#endif
										ms_end_part_child_thread();
            							return FAIL;
        							}
									dcyes = 1;
								}
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
                                {//report info to server actively
                                    memset(err,0,sizeof(err));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != err_report(err,ct.tv_sec,22,3))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),err,sizeof(err));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,29,ct.tv_sec,fcdata->markbit);
                                }//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
                                	update_event_list(fcdata->ec,fcdata->el,1,29,ct.tv_sec,fcdata->markbit);
								}
								continue;
							}//prepare to unlock
						}//lock or unlock
						if (((0x11 <= tcbuf[1]) && (tcbuf[1] <= 0x18)) && (1 == keylock))	
						{//jump stage control
						#ifdef FULL_DETECT_DEBUG
							printf("tcbuf[1]:%d,File:%s,Line:%d\n",tcbuf[1],__FILE__,__LINE__);
						#endif
							memset(&mdt,0,sizeof(markdata_c));
							mdt.redl = &dcred;
							mdt.closel = &close;
							mdt.rettl = &rettl;
							mdt.yfl = &dcyfyes;
							mdt.yfid = &dcyfid;
							mdt.ardata = &ardata;
							mdt.fcdata = fcdata;
							mdt.tscdata = tscdata;
							mdt.chanstatus = chanstatus;
							mdt.sinfo = &sinfo;
							ms_jump_stage_control(&mdt,tcbuf[1],&pinfo);	
						}//jump stage control
						if (((0x20 <= tcbuf[1]) && (tcbuf[1] <= 0x27)) && (1 == keylock))
                        {//direction control
                        #ifdef FULL_DETECT_DEBUG
                            printf("tcbuf[1]:%d,cktem:%d,File:%s,Line:%d\n",tcbuf[1],cktem,__FILE__,__LINE__);
                        #endif
							if (cktem == tcbuf[1])
								continue;
							memset(&mdt,0,sizeof(markdata_c));
                            mdt.redl = &dcred;
                            mdt.closel = &close;
                            mdt.rettl = &rettl;
                            mdt.yfl = &dcyfyes;
                            mdt.yfid = &dcyfid;
                            mdt.ardata = &ardata;
                            mdt.fcdata = fcdata;
                            mdt.tscdata = tscdata;
                            mdt.chanstatus = chanstatus;
                            mdt.sinfo = &sinfo;
							mdt.kstep = &kstep;
							ms_dirch_control(&mdt,cktem,tcbuf[1],dirch,&pinfo);
							cktem = tcbuf[1];
                        }//direction control
						if ((0x02 == tcbuf[1]) && (1 == keylock))
						{//step by step
							kstep = 1;
							if (0 != cktem)
							{//front control is direction control
								memset(wcc,0,sizeof(wcc));
								memset(wnpcc,0,sizeof(wnpcc));
								memset(wpcc,0,sizeof(wpcc));
								z = 0;
								k = 0;
								s = 0;
								pce = 0;
								for (i = 0; i < MAX_CHANNEL; i++)
								{//for (i = 0; i < MAX_CHANNEL; i++)
									if (0 == dirch[cktem-0x20][i])
										break;
									ce = 0;
									for (j = 0; j < MAX_CHANNEL; j++)
									{//for (j = 0; j < MAX_CHANNEL; j++)
										if (0 == pinfo.chan[j])
											break;
										if (dirch[cktem-0x20][i] == pinfo.chan[j])
										{
											ce = 1;
											break;
										}
									}//for (j = 0; j < MAX_CHANNEL; j++)
									if (0 == ce)
									{
										wcc[z] = dirch[cktem-0x20][i];
										z++;
										if ((0x0d <= dirch[cktem-0x20][i]) && (dirch[cktem-0x20][i] <= 0x10))
										{
											wpcc[k] = dirch[cktem-0x20][i];
											k++;
											pce = 1;
										}
										else
										{
											wnpcc[s] = dirch[cktem-0x20][i];
											s++;
										}		
									}
								}//for (i = 0; i < MAX_CHANNEL; i++)
								
								if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
								{
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
									{
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										sinfo.chans = 0;
										memset(sinfo.csta,0,sizeof(sinfo.csta));
										csta = sinfo.csta;
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == dirch[cktem-0x20][i])
												break;
											sinfo.chans += 1;
											tcsta = dirch[cktem-0x20][i];
											tcsta <<= 2;
											tcsta &= 0xfc;
											tcsta |= 0x02; //00000010-green 
											*csta = tcsta;
											csta++;
										}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}
								}//if ((0==wcc[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
								if ((0 != wcc[0]) && (pinfo.gftime > 0))	
								{			
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x03;
										sinfo.time = pinfo.gftime;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == wcc[i])
												break;
											for (j = 0; j < sinfo.chans; j++)
											{
												if (0 == sinfo.csta[j])
													break;
												tcsta = sinfo.csta[j];
												tcsta &= 0xfc;
												tcsta >>= 2;
												tcsta &= 0x3f;
												if (wcc[i] == tcsta)
												{
													sinfo.csta[j] &= 0xfc;
													sinfo.csta[j] |= 0x03; //00000011-green flash
													break;
												}
											}
										}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}//report info to server actively
								}//if ((0 != wcc[0]) && (pinfo.gftime > 0))

								//green flash
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = pinfo.gftime;
									dctd.phaseid = 0;
									dctd.stageline = pinfo.stageline;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                        			dctd.mode = 28;//traffic control
                        			dctd.pattern = *(fcdata->patternid);
                        			dctd.lampcolor = 0x02;
                        			dctd.lamptime = pinfo.gftime;
                        			dctd.phaseid = 0;
                        			dctd.stageline = pinfo.stageline;	
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 0x02;
								fbdata[4] = pinfo.gftime;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,16, \
																ct.tv_sec,fcdata->markbit);
										if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																	fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face board serial port cannot write,Line:%d\n",__LINE__);
								#endif
								}
								ngf = 0;
								if ((0 != wcc[0]) && (pinfo.gftime > 0))
								{//if ((0 != wcc[0]) && (pinfo.gftime > 0))
									while (1)
									{
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x03))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																				wcc,0x03,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x02))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("set lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																					wcc,0x02,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);
										
										ngf += 1;
										if (ngf >= pinfo.gftime)
											break;
									}
								}//if ((0 != wcc[0]) && (pinfo.gftime > 0))
								if (1 == pce)
								{
								//current phase begin to yellow lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wnpcc,0x01))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wnpcc,0x01, fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wpcc,0x00))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wpcc,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								else
								{
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x01))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																			wcc,0x01,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update chan err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}

								if ((0 != wcc[0]) && (pinfo.ytime > 0))
								{
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x01;
										sinfo.time = pinfo.ytime;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
														
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == wnpcc[i])
												break;
											for (j = 0; j < sinfo.chans; j++)
											{
												if (0 == sinfo.csta[j])
													break;
												tcsta = sinfo.csta[j];
												tcsta &= 0xfc;
												tcsta >>= 2;
												tcsta &= 0x3f;
												if (wnpcc[i] == tcsta)
												{
													sinfo.csta[j] &= 0xfc;
													sinfo.csta[j] |= 0x01; //00000001-yellow
													break;
												}
											}
										}
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == wpcc[i])
												break;
											for (j = 0; j < sinfo.chans; j++)
											{
												if (0 == sinfo.csta[j])
													break;
												tcsta = sinfo.csta[j];
												tcsta &= 0xfc;
												tcsta >>= 2;
												tcsta &= 0x3f;
												if (wpcc[i] == tcsta)
												{
													sinfo.csta[j] &= 0xfc;
													break;
												}
											}
										}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("status pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}//report info to server actively
								}//if ((0 != wcc[0]) && (pinfo.ytime > 0))

								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x01;
									dctd.lamptime = pinfo.ytime;
									dctd.phaseid = 0;
									dctd.stageline = pinfo.stageline;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x01;
									dctd.lamptime = pinfo.ytime;
									dctd.phaseid = 0;
									dctd.stageline = pinfo.stageline;	
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 0x01;
								fbdata[4] = pinfo.ytime;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,16, \
															ct.tv_sec,fcdata->markbit);
										if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																fcdata->softevent,fcdata->markbit))
										{	
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face board serial port cannot write,Line:%d\n",__LINE__);
								#endif
								}
								sleep(pinfo.ytime);

								//current phase begin to red lamp
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),wcc,0x00))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("set green lamp err,File:%s,Line:%d\n",__FILE__,__LINE__);
								#endif
									*(fcdata->markbit) |= 0x0800;
								}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																		wcc,0x00,fcdata->markbit))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}

								if ((0 != wcc[0]) && (pinfo.rtime > 0))
								{
									if((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x00;
										sinfo.time = pinfo.rtime;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
																	
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == wcc[i])
												break;
											for (j = 0; j < sinfo.chans; j++)
											{
												if (0 == sinfo.csta[j])
													break;
												tcsta = sinfo.csta[j];
												tcsta &= 0xfc;
												tcsta >>= 2;
												tcsta &= 0x3f;
												if (wcc[i] == tcsta)
												{
													sinfo.csta[j] &= 0xfc;
													break;
												}
											}
										}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}//report info to server actively
								}//if ((0 != wcc[0]) && (pinfo.rtime > 0))
								
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
									*(fcdata->markbit) |= 0x0800;
                            	}
						
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																pinfo.chan,0x02,fcdata->markbit))
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
                            	}

								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x02;
									sinfo.time = 0;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
										if (0 == pinfo.chan[i])
											break;
                						sinfo.chans += 1;
										tcsta = pinfo.chan[i];
										tcsta <<= 2;
										tcsta &= 0xfc;
										tcsta |= 0x02;
										*csta = tcsta;
										csta++;
									}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
									memset(sibuf,0,sizeof(sibuf));
									if (SUCCESS != status_info_report(sibuf,&sinfo))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
									else
									{
										write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
									}
								}//report info to server actively
		
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = 0;
									dctd.phaseid = pinfo.phaseid;
									dctd.stageline = pinfo.stageline;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = 0;
									dctd.phaseid = pinfo.phaseid;
									dctd.stageline = pinfo.stageline;	
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 0x02;
								fbdata[4] = 0;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
										if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face board serial port cannot write,Line:%d\n",__LINE__);
								#endif
								}							

								dcecho[1] = 0x02;
								if (*(fcdata->markbit2) & 0x1000)
								{
									*(fcdata->markbit2) &= 0xefff;
									if (!wait_write_serial(*(fcdata->sdserial)))
									{
										if (write(*(fcdata->sdserial),dcecho,sizeof(dcecho)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("face board serial port cannot write,Line:%d\n",__LINE__);
									#endif
									}	
								}//step by step comes from side door serial
								else
								{
									if (!wait_write_serial(*(fcdata->fbserial)))
									{
										if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("face board serial port cannot write,Line:%d\n",__LINE__);
									#endif
									}
								}							
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									memset(err,0,sizeof(err));
									gettimeofday(&ct,NULL);
									if (SUCCESS != err_report(err,ct.tv_sec,22,5))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
									else
									{
										write(*(fcdata->sockfd->csockfd),err,sizeof(err));
									}
									update_event_list(fcdata->ec,fcdata->el,1,31,ct.tv_sec,fcdata->markbit);
								}//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
									update_event_list(fcdata->ec,fcdata->el,1,31,ct.tv_sec,fcdata->markbit);
								}
								
								cktem = 0;
								continue;
							}//front control is direction control
							if ((1 == dcred) || (1 == dcyfyes) || (1 == close))
							{
								if (1 == close)
								{
									new_all_red(&ardata);
									close = 0;
								}
								dcred = 0;
								if (1 == dcyfyes)
                                {
                                    pthread_cancel(dcyfid);
                                    pthread_join(dcyfid,NULL);
                                    dcyfyes = 0;
									new_all_red(&ardata);
                                }
			//					#ifdef CLOSE_LAMP
                                ms_set_lamp_color(*(fcdata->bbserial),clch,0x03);
								update_channel_status(fcdata->sockfd,chanstatus,clch,0x03,fcdata->markbit);
            //                    #endif
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
								{
								#ifdef FULL_DETECT_DEBUG
                                    printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                    gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                    if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    *(fcdata->markbit) |= 0x0800;	
								}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    							pinfo.chan,0x02,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG 
                                    printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
								dcecho[1] = 0x02;
								if (*(fcdata->markbit2) & 0x1000)
								{
									*(fcdata->markbit2) &= 0xefff;
									if (!wait_write_serial(*(fcdata->sdserial)))
									{
										if (write(*(fcdata->sdserial),dcecho,sizeof(dcecho)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("face board serial port cannot write,Line:%d\n",__LINE__);
									#endif
									}	
								}//step by step comes from side door serial
								else
								{
									if (!wait_write_serial(*(fcdata->fbserial)))
									{
										if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("face board serial port cannot write,Line:%d\n",__LINE__);
									#endif
									}
								}
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x02;
									sinfo.time = 0;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
								/*						
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i + 1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
										for (j = 0; j < MAX_CHANNEL; j++)
										{
											if (0 == pinfo.chan[j])
												break;
											if ((i+1) == pinfo.chan[j])
											{
												tcsta |= 0x02;
												break;
											}
										}
                						*csta = tcsta;
                						csta++;
            						}
								*/
									sinfo.chans = 0;
									memset(sinfo.csta,0,sizeof(sinfo.csta));
                                    csta = sinfo.csta;
									for (i = 0; i < MAX_CHANNEL; i++)
									{
										if (0 == pinfo.chan[i])
											break;
										sinfo.chans += 1;
										tcsta = pinfo.chan[i];
										tcsta <<= 2;
										tcsta &= 0xfc;
										tcsta |= 0x02; //00000010-green 
										*csta = tcsta;
										csta++;
									}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
                                    memset(err,0,sizeof(err));
                                    gettimeofday(&ct,NULL);
                                    if (SUCCESS != err_report(err,ct.tv_sec,22,5))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),err,sizeof(err));
                                    }
									update_event_list(fcdata->ec,fcdata->el,1,31,ct.tv_sec,fcdata->markbit);
								}//report info to server actively
								else
								{
									gettimeofday(&ct,NULL);
                                	update_event_list(fcdata->ec,fcdata->el,1,31,ct.tv_sec,fcdata->markbit);
								}
								continue;
							}
#if 0
							//for WuXi check
							ct.tv_sec = 0;
                            ct.tv_usec = 0;
                            gettimeofday(&ct,NULL);
							if ((ct.tv_sec - wut.tv_sec) < pinfo.mingtime)
							{
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;
									dctd.pattern = *(fcdata->patternid);
                                	dctd.lampcolor = 0x02;
                                	dctd.lamptime = pinfo.mingtime - (ct.tv_sec - wut.tv_sec);
                                	dctd.phaseid = pinfo.phaseid;
                                	dctd.stageline = pinfo.stageline;	
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 2;
                            	fbdata[4] = pinfo.mingtime - (ct.tv_sec - wut.tv_sec);
                            	if (!wait_write_serial(*(fcdata->fbserial)))
                            	{
                                	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                	#endif
										*(fcdata->markbit) |= 0x0800;
                                    	gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
                                	}
                            	}
                            	else
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
                            	}
								sleep(pinfo.mingtime - (ct.tv_sec - wut.tv_sec));
							}
							//for WuXi Check
#endif
							if ((0==pinfo.cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{
									sinfo.conmode = 28;
                                    sinfo.color = 0x02;
                                    sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
                                    sinfo.stage = pinfo.stageline;
                                    sinfo.cyclet = 0;
                                    sinfo.phase = 0;
                                    sinfo.phase |= (0x01 << (pinfo.phaseid - 1));

                                    sinfo.chans = 0;
                                    memset(sinfo.csta,0,sizeof(sinfo.csta));
                                    csta = sinfo.csta;
									for (i = 0; i < MAX_CHANNEL; i++)
                                    {
                                        if (0 == pinfo.chan[i])
                                            break;
                                        sinfo.chans += 1;
                                        tcsta = pinfo.chan[i];
                                        tcsta <<= 2;
                                        tcsta &= 0xfc;
                                        tcsta |= 0x02;
                                        *csta = tcsta;
                                        csta++;
                                    }
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
                                    memset(sibuf,0,sizeof(sibuf));
                                    if (SUCCESS != status_info_report(sibuf,&sinfo))
                                    {
                                    #ifdef PERSON_DEBUG
                                        printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
                                    }
								}
							}
							if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x03;
									sinfo.time = pinfo.gftime;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
									
									for (i = 0; i < MAX_CHANNEL; i++)
                                	{
                                		if (0 == pinfo.cchan[i])
                                        	break;
                                    	for (j = 0; j < sinfo.chans; j++)
                                    	{
                                        	if (0 == sinfo.csta[j])
                                            	break;
                                        	tcsta = sinfo.csta[j];
                                        	tcsta &= 0xfc;
                                        	tcsta >>= 2;
                                        	tcsta &= 0x3f;
                                        	if (pinfo.cchan[i] == tcsta)
                                        	{
                                            	sinfo.csta[j] &= 0xfc;
                                           		sinfo.csta[j] |= 0x03; //00000001-green flash
												break;
                                        	}
                                    	}
                                	}								
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
							}

							//send down time to configure tool
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
							{
								memset(&dctd,0,sizeof(dctd));
								dctd.mode = 28;
								dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x02;
                                dctd.lamptime = pinfo.gftime;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;	
								if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
								#endif
								}
							}
							#ifdef EMBED_CONFIGURE_TOOL
                            if (*(fcdata->markbit2) & 0x0200)
                            {
                                memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 28;
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x02;
                                dctd.lamptime = pinfo.gftime;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;   
                                if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
                            }
                            #endif
							fbdata[1] = 28;
							fbdata[2] = pinfo.stageline;
							fbdata[3] = 2;
                            fbdata[4] = pinfo.gftime;
                            if (!wait_write_serial(*(fcdata->fbserial)))
                            {
                                if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
									*(fcdata->markbit) |= 0x0800;
                                    gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }
                            }
                            else
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
                            {//report info to server actively
                                memset(err,0,sizeof(err));
                                gettimeofday(&ct,NULL);
                                if (SUCCESS != err_report(err,ct.tv_sec,22,5))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                else
                                {
                                    write(*(fcdata->sockfd->csockfd),err,sizeof(err));
                                }
								update_event_list(fcdata->ec,fcdata->el,1,31,ct.tv_sec,fcdata->markbit);
                            }//report info to server actively
							else
							{
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,31,ct.tv_sec,fcdata->markbit);
							}
							//begin to green flash
							if (pinfo.gftime > 0)
							{
								ngf = 0;
								while (1)
								{//green flash loop
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x03))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
										if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
										pinfo.cchan,0x03,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG 
										printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
									to.tv_sec = 0;
									to.tv_usec = 500000;
									select(0,NULL,NULL,NULL,&to);
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x02))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
										if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
										pinfo.cchan,0x02,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
									to.tv_sec = 0;
									to.tv_usec = 500000;
									select(0,NULL,NULL,NULL,&to);

									ngf += 1;
									if (ngf >= pinfo.gftime)
										break;
								}//green flash loop
							}//if (pinfo.gftime > 0)
							//end green flash

							//yellow lamp 
							if (1 == pinfo.cpcexist)
							{//have person channels
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cnpchan,0x01))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                   	if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
									*(fcdata->markbit) |= 0x0800;
								}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.cnpchan,0x01,fcdata->markbit))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cpchan,0x00))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
									gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                   	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
									*(fcdata->markbit) |= 0x0800;
                               	}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    							pinfo.cpchan,0x00,fcdata->markbit))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
                               	}	
							}//have person channels
							else
							{//not have person channels
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x01))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
									gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                   	if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
									*(fcdata->markbit) |= 0x0800;
                               	}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                   									pinfo.cchan,0x01,fcdata->markbit))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
                               	}
							}//not have person channels
							if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x01;
									sinfo.time = pinfo.ytime;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						if (0 == pinfo.cnpchan[i])
                    						break;
                						for (j = 0; j < sinfo.chans; j++)
                						{
                    						if (0 == sinfo.csta[j])
                        						break;
                    						tcsta = sinfo.csta[j];
                    						tcsta &= 0xfc;
                    						tcsta >>= 2;
                    						tcsta &= 0x3f;
                    						if (pinfo.cnpchan[i] == tcsta)
                    						{
                        						sinfo.csta[j] &= 0xfc;
												sinfo.csta[j] |= 0x01; //00000001-yellow
												break;
                    						}
                						}
            						}
									for (i = 0; i < MAX_CHANNEL; i++)
                                	{
                                		if (0 == pinfo.cpchan[i])
                                        	break;
                                    	for (j = 0; j < sinfo.chans; j++)
                                    	{
                                        	if (0 == sinfo.csta[j])
                                            	break;
                                        	tcsta = sinfo.csta[j];
                                        	tcsta &= 0xfc;
                                        	tcsta >>= 2;
                                        	tcsta &= 0x3f;
                                        	if (pinfo.cpchan[i] == tcsta)
                                        	{
                                            	sinfo.csta[j] &= 0xfc;
												break;
                                        	}
                                    	}
                                	}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
							}

							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
                               	memset(&dctd,0,sizeof(dctd));
                               	dctd.mode = 28;//traffic control
                               	dctd.pattern = *(fcdata->patternid);
                               	dctd.lampcolor = 0x01;
                               	dctd.lamptime = pinfo.ytime;
                               	dctd.phaseid = pinfo.phaseid;
                               	dctd.stageline = pinfo.stageline;
                               	if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                               	#endif
                               	}
                            }
							#ifdef EMBED_CONFIGURE_TOOL
                            if (*(fcdata->markbit2) & 0x0200)
                            {
                                memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 28;//traffic control
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x01;
                                dctd.lamptime = pinfo.ytime;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;  
                                if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
                            }
                            #endif
							fbdata[1] = 28;
							fbdata[2] = pinfo.stageline;
							fbdata[3] = 1;
                            fbdata[4] = pinfo.ytime;
                            if (!wait_write_serial(*(fcdata->fbserial)))
                            {
                               	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
									*(fcdata->markbit) |= 0x0800;
                                   	gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                   	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
                               	}
                            }
                            else
                            {
                            #ifdef FULL_DETECT_DEBUG
                               	printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
							sleep(pinfo.ytime);
							//end yellow lamp

							//red lamp
							if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x00))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																fcdata->softevent,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
								*(fcdata->markbit) |= 0x0800;
							}
							if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus,pinfo.cchan,\
										0x00,fcdata->markbit))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
							if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x00;
									sinfo.time = pinfo.rtime;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						if (0 == pinfo.cchan[i])
                    						break;
                						for (j = 0; j < sinfo.chans; j++)
                						{
                    						if (0 == sinfo.csta[j])
                        						break;
                    						tcsta = sinfo.csta[j];
                    						tcsta &= 0xfc;
                    						tcsta >>= 2;
                    						tcsta &= 0x3f;
                    						if (pinfo.cchan[i] == tcsta)
                    						{
                        						sinfo.csta[j] &= 0xfc;
												break;
                    						}
                						}
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
							}

							if (pinfo.rtime > 0)
							{
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                                {
                                    memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 28;//traffic control
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x00;
                                    dctd.lamptime = pinfo.rtime;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;
                                    if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 28;//traffic control
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x00;
                                    dctd.lamptime = pinfo.rtime;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;		
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 0;
                            	fbdata[4] = pinfo.rtime;
                            	if (!wait_write_serial(*(fcdata->fbserial)))
                            	{
                                	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                	#endif
										*(fcdata->markbit) |= 0x0800;
                                    	gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
                                	}
                            	}
                            	else
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
                            	}
                                sleep(pinfo.rtime);
							}	
							//end red lamp
							*(fcdata->slnum) += 1;
                            *(fcdata->stageid) = \
                                tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
                            if (0 == (tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId))
                            {
                                *(fcdata->slnum) = 0;
                                *(fcdata->stageid) = \
                                    tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
                            }
							//get info of next phase
							memset(&pinfo,0,sizeof(pinfo));
							if (SUCCESS != ms_get_phase_info(fcdata,tscdata,rettl,*(fcdata->slnum),&pinfo))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("get phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
								output_log("detect control,get phase info err");
							#endif
								ms_end_part_child_thread();
								return FAIL;
							}
							*(fcdata->phaseid) = 0;
							*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));
							if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																fcdata->softevent,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
								*(fcdata->markbit) |= 0x0800;
                            }
							if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus,pinfo.chan,\
                                        0x02,fcdata->markbit))
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }

							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x02;
								sinfo.time = 0;
								sinfo.stage = pinfo.stageline;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
								sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
									if (0 == pinfo.chan[i])
										break;
                					sinfo.chans += 1;
                					tcsta = pinfo.chan[i];
                					tcsta <<= 2;
                					tcsta &= 0xfc;
									tcsta |= 0x02;
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
							}//report info to server actively

							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
							{
								memset(&dctd,0,sizeof(dctd));
								dctd.mode = 28;
								dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x02;
                                dctd.lamptime = 0;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;	
								if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
								#endif
								}
							}
							#ifdef EMBED_CONFIGURE_TOOL
                            if (*(fcdata->markbit2) & 0x0200)
                            {
                                memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 28;
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x02;
                                dctd.lamptime = 0;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;  
                                if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
                            }
                            #endif
							fbdata[1] = 28;
							fbdata[2] = pinfo.stageline;
							fbdata[3] = 2;
                            fbdata[4] = 0;
                            if (!wait_write_serial(*(fcdata->fbserial)))
                            {
                                if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
									*(fcdata->markbit) |= 0x0800;
                                    gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }
                            }
                            else
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }

                            dcecho[1] = 0x02;
							if (*(fcdata->markbit2) & 0x1000)
							{
								*(fcdata->markbit2) &= 0xefff;
								if (!wait_write_serial(*(fcdata->sdserial)))
                                {
                                    if (write(*(fcdata->sdserial),dcecho,sizeof(dcecho)) < 0)
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                        *(fcdata->markbit) |= 0x0800;
                                    }
                                }
                                else
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                #endif
                                }	
							}//step by step comes from side door serial
							else
							{
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
										if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(fcdata->markbit) |= 0x0800;
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face board serial port cannot write,Line:%d\n",__LINE__);
								#endif
								}
							}

							continue;
						}//step by step
						if ((0x03 == tcbuf[1]) && (1 == keylock))
						{//yellow flash
							kstep = 0;
                            cktem = 0;
							dcred = 0;
							close = 0;
							if (0 == dcyfyes)
							{
								memset(&yfdata,0,sizeof(yfdata));
								yfdata.second = 0;
								yfdata.markbit = fcdata->markbit;
								yfdata.markbit2 = fcdata->markbit2;
								yfdata.serial = *(fcdata->bbserial);
								yfdata.sockfd = fcdata->sockfd;
								yfdata.cs = chanstatus;
#ifdef FLASH_DEBUG
								char szInfo[32] = {0};
								char szInfoT[64] = {0};
								snprintf(szInfo,sizeof(szInfo)-1,"%s",__FUNCTION__);
								snprintf(szInfoT,sizeof(szInfoT)-1,"%d",__LINE__);
								tsc_save_eventlog(szInfo,szInfoT);
#endif
								int yfret = pthread_create(&dcyfid,NULL,(void *)ms_yellow_flash,&yfdata);
								if (0 != yfret)
								{
								#ifdef FULL_DETECT_DEBUG
									printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
									output_log("detect control,create yellow flash err");
								#endif
									ms_end_part_child_thread();
									return FAIL;
								}
								dcyfyes = 1;
							}
							dcecho[1] = 0x03;
							if (*(fcdata->markbit2) & 0x2000)
							{
								*(fcdata->markbit2) &= 0xdfff;
								if (!wait_write_serial(*(fcdata->sdserial)))
                                {
                                    if (write(*(fcdata->sdserial),dcecho,sizeof(dcecho)) < 0)
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                        *(fcdata->markbit) |= 0x0800;
                                    }
                                }
                                else
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                #endif
                                }
							}//yellow flash comes from side door serial;
							else
							{
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
										if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el, \
																		fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(fcdata->markbit) |= 0x0800;
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face serial cannot write,File:%s,Line:%d\n",__FILE__,__LINE__);
								#endif
								}
							}

							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x05;
								sinfo.time = 0;
								sinfo.stage = 0;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					sinfo.chans += 1;
                					tcsta = i + 1;
                					tcsta <<= 2;
                					tcsta &= 0xfc;
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
                                memset(err,0,sizeof(err));
                                gettimeofday(&ct,NULL);
                                if (SUCCESS != err_report(err,ct.tv_sec,22,7))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                else
                                {
                                    write(*(fcdata->sockfd->csockfd),err,sizeof(err));
                                }
								update_event_list(fcdata->ec,fcdata->el,1,33,ct.tv_sec,fcdata->markbit);
							}//report info to server actively
							else
							{
								gettimeofday(&ct,NULL);
                            	update_event_list(fcdata->ec,fcdata->el,1,33,ct.tv_sec,fcdata->markbit);
							}
							continue;
						}//yellow flash
						if ((0x04 == tcbuf[1]) && (1 == keylock))
						{//all red
							kstep = 0;
                            cktem = 0;
							if (1 == dcyfyes)
							{
								pthread_cancel(dcyfid);
								pthread_join(dcyfid,NULL);
								dcyfyes = 0;
							}
							close = 0;
							if (0 == dcred)
							{
								new_all_red(&ardata);	
								dcred = 1;
							}
							dcecho[1] = 0x04;
							if (*(fcdata->markbit2) & 0x4000)
                            {
                                *(fcdata->markbit2) &= 0xbfff;
                                if (!wait_write_serial(*(fcdata->sdserial)))
                                {
                                    if (write(*(fcdata->sdserial),dcecho,sizeof(dcecho)) < 0)
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                        *(fcdata->markbit) |= 0x0800;
                                    }
                                }
                                else
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("face board serial port cannot write,Line:%d\n",__LINE__);
                                #endif
                                }
                            }//all red comes from side door serial
							else
							{
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
										if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(fcdata->markbit) |= 0x0800;
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face serial cannot write,File:%s,Line:%d\n",__FILE__,__LINE__);
								#endif
								}
							}

							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x00;
								sinfo.time = 0;
								sinfo.stage = 0;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					sinfo.chans += 1;
                					tcsta = i + 1;
                					tcsta <<= 2;
                					tcsta &= 0xfc;
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
								memset(err,0,sizeof(err));
                                gettimeofday(&ct,NULL);
                                if (SUCCESS != err_report(err,ct.tv_sec,22,9))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                else
                                {
                                    write(*(fcdata->sockfd->csockfd),err,sizeof(err));
                                }
								update_event_list(fcdata->ec,fcdata->el,1,35,ct.tv_sec,fcdata->markbit);
							}//report info to server actively
							else
							{
								gettimeofday(&ct,NULL);
                            	update_event_list(fcdata->ec,fcdata->el,1,35,ct.tv_sec,fcdata->markbit);
							}
							continue;
						}//all red
						if ((0x05 == tcbuf[1]) && (1 == keylock))
						{//all close
							kstep = 0;
                            cktem = 0;
							if (1 == dcyfyes)
							{
								pthread_cancel(dcyfid);
								pthread_join(dcyfid,NULL);
								dcyfyes = 0;
							}
							dcred = 0;
							if (0 == close)
							{
								new_all_close(&acdata);	
								close = 1;
							}
							dcecho[1] = 0x05;
							if (!wait_write_serial(*(fcdata->fbserial)))
							{
								if (write(*(fcdata->fbserial),dcecho,sizeof(dcecho)) < 0)
								{
								#ifdef FULL_DETECT_DEBUG
									printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
									*(fcdata->markbit) |= 0x0800;
								}
							}
							else
							{
							#ifdef FULL_DETECT_DEBUG
								printf("face board serial cannot write,File:%s,Line:%d\n",__FILE__,__LINE__);
							#endif
							}
							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x04;
								sinfo.time = 0;
								sinfo.stage = 0;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					sinfo.chans += 1;
                					tcsta = i + 1;
                					tcsta <<= 2;
                					tcsta &= 0xfc;
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
							#if 0
								memset(err,0,sizeof(err));
                                gettimeofday(&ct,NULL);
                                if (SUCCESS != err_report(err,ct.tv_sec,22,9))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("err_report call err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
                                else
                                {
                                    write(*(fcdata->sockfd->csockfd),err,sizeof(err));
                                }
								update_event_list(fcdata->ec,fcdata->el,1,35,ct.tv_sec,fcdata->markbit);
							#endif
							}//report info to server actively
							else
							{
							#if 0
								gettimeofday(&ct,NULL);
                            	update_event_list(fcdata->ec,fcdata->el,1,35,ct.tv_sec,fcdata->markbit);
							#endif
							}
							continue;
						}//all close
					}//key lock or unlock is suessfully only when wireless lock or unlock is not valid;
				}//key traffic control
				else if (!strncmp("WLTC1",tcbuf,5))
				{//wireless terminal traffic control
					if ((0 == keylock) && (0 == netlock) && (0 == wtlock))
                    {//wireless lock or unlock is suessfully only when key lock or unlock is not valid;
						unsigned char           wlbuf[5] = {0};
                        unsigned char           s = 0;
                        for (s = 5; ;s++)
                        {
                            if (('E' == tcbuf[s]) && ('N' == tcbuf[s+1]) && ('D' == tcbuf[s+2]))
                                break;
                            if ('\0' == tcbuf[s])
                                break;
                            if ((s - 5) > 4)
                                break;
                            wlbuf[s - 5] = tcbuf[s];
                        }
                        #ifdef FULL_DETECT_DEBUG
                        printf("************wlbuf: %s,File: %s,Line: %d\n",wlbuf,__FILE__,__LINE__);
                        #endif
						if (!strcmp("SOCK",wlbuf))
						{//lock or unlock
							if (0 == wllock)
							{//prepare to lock
							#ifdef FULL_DETECT_DEBUG
								printf("Prepare to lock,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
								get_ms_status(&color,&leatime);
								if (2 != color)
								{//lamp color is not green
									struct timeval			spatime;
									unsigned char			endlock = 0;
									while(1)
									{//inline while loop
										spatime.tv_sec = 0;
										spatime.tv_usec = 200000;
										select(0,NULL,NULL,NULL,&spatime);
										memset(tcbuf,0,sizeof(tcbuf));
										read(*(fcdata->conpipe),tcbuf,sizeof(tcbuf));
									
										if (!strncmp("WLTC1",tcbuf,5))
                                        {
                                            memset(wlbuf,0,sizeof(wlbuf));
                                            s = 0;
                                            for (s = 5; ;s++)
                                            {
                                                if(('E'==tcbuf[s]) && ('N'==tcbuf[s+1]) && ('D'==tcbuf[s+2]))
                                                    break;
                                                if ('\0' == tcbuf[s])
                                                    break;
                                                if ((s - 5) > 4)
                                                    break;
                                                wlbuf[s - 5] = tcbuf[s];
                                            }
                                            if (!strcmp("SOCK",wlbuf))
                                            {
                                                endlock = 1;
                                                break;
                                            }
                                        }	
	
										get_ms_status(&color,&leatime);
										if (2 == color)
										{
											break;
										}
										else
										{
											continue;
										}
									}//inline while loop
									if (1 == endlock)
									{
										continue;
									}
								}//lamp color is not green
								
								wllock = 1;
								dcred = 0;
								close = 0;
								dircon = 0;
                                firdc = 1;
                                fdirn = 0;
                                cdirn = 0;
								ms_end_child_thread();//end man thread and its child thread
								*(fcdata->markbit2) |= 0x0010;
							#if 0
								new_all_red(&ardata);
							//	all_red(*(fcdata->bbserial),0);	
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									gettimeofday(&ct,NULL);
                					update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                					if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                					{
                					#ifdef FULL_DETECT_DEBUG
                    					printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                					#endif
                					}
									*(fcdata->markbit) |= 0x0800;
								}
							#endif
							if (*(fcdata->auxfunc) & 0x01)
                                {//if (*(fcdata->auxfunc) & 0x01)
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcdownti,sizeof(dcdownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    if (!wait_write_serial(*(fcdata->bbserial)))
                                    {
                                        if (write(*(fcdata->bbserial),dcedownti,sizeof(dcedownti)) < 0)
                                        {
                                        #ifdef FULL_DETECT_DEBUG
                                            printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                        #endif
                                        }
                                    }
                                    else
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("face board cannot write,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }//if (*(fcdata->auxfunc) & 0x01)
                                
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x02;
									sinfo.time = 0;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						if (0 == pinfo.chan[i])
                    						break;
                						sinfo.chans += 1;
                						tcsta = pinfo.chan[i];
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						tcsta |= 0x02; //00000010-green
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
							
								*(fcdata->contmode) = 28;//traffic control mode
								//send current control info to face board
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 2;
								fbdata[4] = 0;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
										gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}
								sendfaceInfoToBoard(fcdata,fbdata);
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    pinfo.chan,0x02,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG 
                                    printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            	{
                                	memset(wltc,0,sizeof(wltc));
                                	strcpy(wltc,"SOCKBEGIN");
                                	write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
									//send down time to configure tool
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = 0;
									dctd.phaseid = pinfo.phaseid;
									dctd.stageline = pinfo.stageline;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{ 
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
                            	}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 28;
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x02;
                                    dctd.lamptime = 0;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline;		
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,90,ct.tv_sec,fcdata->markbit);

								continue;
							}//prepare to lock
							if (1 == wllock)
							{//prepare to unlock
							#ifdef FULL_DETECT_DEBUG
                                printf("Prepare to unlock,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
								wllock = 0;
								dcred = 0;
								close = 0;
								dircon = 0;
                                firdc = 1;
                                fdirn = 0;
                                cdirn = 0;
								if (1 == dcyfyes)
								{
									pthread_cancel(dcyfid);
									pthread_join(dcyfid,NULL);
									dcyfyes = 0;
								}
								
								new_all_red(&ardata);
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x00;
									sinfo.time = 0;
									sinfo.stage = 0;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
															
									sinfo.chans = 0;
            						memset(sinfo.csta,0,sizeof(sinfo.csta));
            						csta = sinfo.csta;
            						for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						sinfo.chans += 1;
                						tcsta = i + 1;
                						tcsta <<= 2;
                						tcsta &= 0xfc;
                						*csta = tcsta;
                						csta++;
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File: %s,Line: %d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
						//		all_red(*(fcdata->bbserial),0);
								*(fcdata->markbit2) &= 0xffef;
								*(fcdata->contmode) = contmode;//restore control mode
								if (0 == dcyes)
								{
									memset(&dcdata,0,sizeof(dcdata));
        							memset(&pinfo,0,sizeof(pinfo));
        							dcdata.fd = fcdata;
        							dcdata.td = tscdata;
        							dcdata.pi = &pinfo;
        							dcdata.cs = chanstatus;
        							int dcret = pthread_create(&dcpid,NULL, \
													(void *)start_major_salve_control,&dcdata);
        							if (0 != dcret)
        							{
        							#ifdef FULL_DETECT_DEBUG
            							printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
										output_log("detect control,create full detect thread err");
        							#endif
										ms_end_part_child_thread();
            							return FAIL;
        							}
									dcyes = 1;
								}
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            	{
                                	memset(wltc,0,sizeof(wltc));
                                	strcpy(wltc,"SOCKEND");
                                	write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
                            	}
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,91,ct.tv_sec,fcdata->markbit);

								continue;
							}//prepare to unlock
						}//lock or unlock
						if ((1 == wllock) && (!strcmp("STEP",wlbuf)))
						{//step by step
							firdc = 1;
                            cdirn = 0;
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
                                memset(wltc,0,sizeof(wltc));
                                strcpy(wltc,"STEPBEGIN");
                                write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
                            }
							if ((1 == dcred) || (1 == dcyfyes) || (1 == close))
							{
								if (1 == close)
								{
									new_all_red(&ardata);
									close = 0;
								}
								dcred = 0;
								if (1 == dcyfyes)
                                {
                                    pthread_cancel(dcyfid);
                                    pthread_join(dcyfid,NULL);
                                    dcyfyes = 0;
									new_all_red(&ardata);
                                }
				//				#ifdef CLOSE_LAMP
                                ms_set_lamp_color(*(fcdata->bbserial),clch,0x03);
								update_channel_status(fcdata->sockfd,chanstatus,clch,0x03,fcdata->markbit);
                 //               #endif
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
								{
								#ifdef FULL_DETECT_DEBUG
                                    printf("set lamp color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                    gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                    if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    *(fcdata->markbit) |= 0x0800;	
								}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    							pinfo.chan,0x02,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG 
                                    printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x02;
									sinfo.time = 0;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
									
									sinfo.chans = 0;
									memset(sinfo.csta,0,sizeof(sinfo.csta));
                                    csta = sinfo.csta;
									for (i = 0; i < MAX_CHANNEL; i++)
									{
										if (0 == pinfo.chan[i])
											break;
										sinfo.chans += 1;
										tcsta = pinfo.chan[i];
										tcsta <<= 2;
										tcsta &= 0xfc;
										tcsta |= 0x02; //00000010-green 
										*csta = tcsta;
										csta++;
									}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
	
								continue;
							}
				
							if ((1 == dircon) && (0 != fdirn))
                            {//direction control happen
								unsigned char			dcchan[MAX_CHANNEL] = {0};
								unsigned char			dcpchan[MAX_CHANNEL] = {0};
								unsigned char			dcnpchan[MAX_CHANNEL] = {0};
								unsigned char			dexist = 0;
								unsigned char			dpexist = 0;
								unsigned char			*pd = dcchan;

								s = 0;
								k = 0;
								for (i = 0; i < MAX_CHANNEL; i++)
								{//i
									if (0 == dirch[fdirn-1][i])
										break;
									dexist = 0;
									for (j = 0; j < MAX_CHANNEL; j++ )
									{//j
										if (0 == pinfo.chan[j])
											break;
										if (dirch[fdirn-1][i] == pinfo.chan[j])
										{
											dexist = 1;
											break;
										}			
									}//j
									if (0 == dexist)
									{//if (0 == exist)
										*pd = dirch[fdirn-1][i];
										pd++;
										for (j = 0; j < (tscdata->channel->FactChannelNum); j++)
										{//2j
											if (0 == (tscdata->channel->ChannelList[j].ChannelId))
												break;
											if(dirch[fdirn-1][i]==(tscdata->channel->ChannelList[j].ChannelId))
											{
												if (3 == tscdata->channel->ChannelList[j].ChannelType)
												{
													dcpchan[s] = dirch[fdirn-1][i];
													s++;
													dpexist = 1;		
												}
												else
												{
													dcnpchan[k] = dirch[fdirn-1][i];
													k++;
												}
												break;
											}
										}//2j
									}//if (0 == exist)
								}//i
								//end compute
								if (0 == dcchan[0])
								{
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = 6;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
																
										sinfo.chans = 0;
										memset(sinfo.csta,0,sizeof(sinfo.csta));
										csta = sinfo.csta;
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == dcchan[i])
												break;
											sinfo.chans += 1;
											tcsta = dcchan[i];
											tcsta <<= 2;
											tcsta &= 0xfc;
											tcsta |= 0x02;
											*csta = tcsta;
											csta++;
										}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}//report info to server actively
								}//if ((0==cchan[0])&&(pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0))

								if (0 != dcchan[0])
								{
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x03;
										sinfo.time = 3;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
										
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == dcchan[i])
												break;
											for (j = 0; j < sinfo.chans; j++)
											{
												if (0 == sinfo.csta[j])
													break;
												tcsta = sinfo.csta[j];
												tcsta &= 0xfc;
												tcsta >>= 2;
												tcsta &= 0x3f;
												if (dcchan[i] == tcsta)
												{
													sinfo.csta[j] &= 0xfc;
													sinfo.csta[j] |= 0x03; //00000001-green flash
													break;
												}
											}
										}								
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));	
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}//report info to server actively
								}//if ((0 != cchan[0]) && (pinfo.gftime > 0))

								//current phase begin to green flash
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = 3;
									dctd.phaseid = 0;
									dctd.stageline = 0;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x02;
									dctd.lamptime = 3;
									dctd.phaseid = 0;
									dctd.stageline = 0;	
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 28;
								fbdata[2] = 0;
								fbdata[3] = 0x02;
								fbdata[4] = 3;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face board serial port cannot write,Line:%d\n",__LINE__);
								#endif
								}
								if (pinfo.gftime > 0)
								{
									ngf = 0;
									while (1)
									{//green flash
										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dcchan,0x03))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;	
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														dcchan,0x03,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);

										if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dcchan,0x02))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("close lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
										if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														dcchan,0x02,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										to.tv_sec = 0;
										to.tv_usec = 500000;
										select(0,NULL,NULL,NULL,&to);
									
										ngf += 1;
										if (ngf >= 3)
											break;
									}//green flash
								}//if (pinfo.gftime > 0)
								if (1 == dpexist)
								{
									//current phase begin to yellow lamp
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dcnpchan,0x01))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														dcnpchan,0x01, fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dcpchan,0x00))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set red lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
																		dcpchan,0x00,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
								}
								else
								{
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dcchan,0x01))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set yellow lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															dcchan,0x01,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
									}
								}
								
								if (0 != dcchan[0])
								{
									if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x01;
										sinfo.time = 3;
										sinfo.stage = 0;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
																
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == dcnpchan[i])
												break;
											for (j = 0; j < sinfo.chans; j++)
											{
												if (0 == sinfo.csta[j])
													break;
												tcsta = sinfo.csta[j];
												tcsta &= 0xfc;
												tcsta >>= 2;
												tcsta &= 0x3f;
												if (dcnpchan[i] == tcsta)
												{
													sinfo.csta[j] &= 0xfc;
													sinfo.csta[j] |= 0x01; //00000001-yellow
													break;
												}
											}
										}
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == dcpchan[i])
												break;
											for (j = 0; j < sinfo.chans; j++)
											{
												if (0 == sinfo.csta[j])
													break;
												tcsta = sinfo.csta[j];
												tcsta &= 0xfc;
												tcsta >>= 2;
												tcsta &= 0x3f;
												if (dcpchan[i] == tcsta)
												{
													sinfo.csta[j] &= 0xfc;
													break;
												}
											}
										}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}//report info to server actively
								}//if ((0 != cchan[0]) && (pinfo.ytime > 0))

								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x01;
									dctd.lamptime = 3;
									dctd.phaseid = 0;
									dctd.stageline = 0;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
								{
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;//traffic control
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x01;
									dctd.lamptime = 3;
									dctd.phaseid = 0;
									dctd.stageline = 0;	
									if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#endif
								fbdata[1] = 28;
								fbdata[2] = 0;
								fbdata[3] = 0x01;
								fbdata[4] = 3;
								if (!wait_write_serial(*(fcdata->fbserial)))
								{
									if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
									{
									#ifdef FULL_DETECT_DEBUG
										printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										*(fcdata->markbit) |= 0x0800;
									}
								}
								else
								{
								#ifdef FULL_DETECT_DEBUG
									printf("face board serial port cannot write,Line:%d\n",__LINE__);
								#endif
								}

								sleep(3);

								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),dcchan,0x00))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									*(fcdata->markbit) |= 0x0800;
								}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
														dcchan,0x00,fcdata->markbit))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}
								
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.chan,0x02,fcdata->markbit))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									*(fcdata->markbit) |= 0x0800;
									return FAIL;
								}
								else
								{//set success
									if ((!(*(fcdata->markbit) & 0x1000))&&(!(*(fcdata->markbit) & 0x8000)))
									{//report info to server actively
										sinfo.conmode = 28;
										sinfo.color = 0x02;
										sinfo.time = 0;
										sinfo.stage = pinfo.stageline;
										sinfo.cyclet = 0;
										sinfo.phase = 0;
                                    	sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
										sinfo.chans = 0;
										memset(sinfo.csta,0,sizeof(sinfo.csta));
										csta = sinfo.csta;
										for (i = 0; i < MAX_CHANNEL; i++)
										{
											if (0 == pinfo.chan[i])
												break;
											sinfo.chans += 1;
											tcsta = pinfo.chan[i];
											tcsta <<= 2;
											tcsta &= 0xfc;
											tcsta |= 0x02; //00000010-green 
											*csta = tcsta;
											csta++;
										}
										memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
										memset(sibuf,0,sizeof(sibuf));
										if (SUCCESS != status_info_report(sibuf,&sinfo))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
										else
										{
											write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
										}
									}//report info to server actively

									if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = pinfo.phaseid;
                                		dctd.stageline = pinfo.stageline;
										if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("send time err,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#ifdef EMBED_CONFIGURE_TOOL
									if (*(fcdata->markbit2) & 0x0200)
									{
										memset(&dctd,0,sizeof(dctd));
										dctd.mode = 28;//traffic control
										dctd.pattern = *(fcdata->patternid);
										dctd.lampcolor = 0x02;
										dctd.lamptime = 0;
										dctd.phaseid = pinfo.phaseid;
                                		dctd.stageline = pinfo.stageline;	
										if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
										#endif
										}
									}
									#endif
									fbdata[1] = 28;
									fbdata[2] = pinfo.stageline;
									fbdata[3] = 0x02;
									fbdata[4] = 0;
									if (!wait_write_serial(*(fcdata->fbserial)))
									{
										if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
										{
										#ifdef FULL_DETECT_DEBUG
											printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
											*(fcdata->markbit) |= 0x0800;
										}
									}
									else
									{
									#ifdef FULL_DETECT_DEBUG
										printf("face board serial port cannot write,Line:%d\n",__LINE__);
									#endif
									}							
								}//set success

                                dircon = 0;
								fdirn = 0;
                                continue;
                            }//diredtion control happen
	
							if ((0==pinfo.cchan[0])&&((pinfo.gftime>0)||(pinfo.ytime>0)||(pinfo.rtime>0)))
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{
									sinfo.conmode = 28;
                                    sinfo.color = 0x02;
                                    sinfo.time = pinfo.gftime + pinfo.ytime + pinfo.rtime;
                                    sinfo.stage = pinfo.stageline;
                                    sinfo.cyclet = 0;
                                    sinfo.phase = 0;
                                    sinfo.phase |= (0x01 << (pinfo.phaseid - 1));

                                    sinfo.chans = 0;
                                    memset(sinfo.csta,0,sizeof(sinfo.csta));
                                    csta = sinfo.csta;
									for (i = 0; i < MAX_CHANNEL; i++)
                                    {
                                        if (0 == pinfo.chan[i])
                                            break;
                                        sinfo.chans += 1;
                                        tcsta = pinfo.chan[i];
                                        tcsta <<= 2;
                                        tcsta &= 0xfc;
                                        tcsta |= 0x02;
                                        *csta = tcsta;
                                        csta++;
                                    }
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
                                    memset(sibuf,0,sizeof(sibuf));
                                    if (SUCCESS != status_info_report(sibuf,&sinfo))
                                    {
                                    #ifdef PERSON_DEBUG
                                        printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                    else
                                    {
                                        write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
                                    }
								}
							}
							if ((0 != pinfo.cchan[0]) && (pinfo.gftime > 0))	
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x03;
									sinfo.time = pinfo.gftime;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
									
									for (i = 0; i < MAX_CHANNEL; i++)
                                	{
                                		if (0 == pinfo.cchan[i])
                                        	break;
                                    	for (j = 0; j < sinfo.chans; j++)
                                    	{
                                        	if (0 == sinfo.csta[j])
                                            	break;
                                        	tcsta = sinfo.csta[j];
                                        	tcsta &= 0xfc;
                                        	tcsta >>= 2;
                                        	tcsta &= 0x3f;
                                        	if (pinfo.cchan[i] == tcsta)
                                        	{
                                            	sinfo.csta[j] &= 0xfc;
                                            	sinfo.csta[j] |= 0x03; //00000001-green flash
												break;
                                        	}
                                    	}
                                	}								
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));			
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
							}

							fbdata[1] = 28;	
							fbdata[2] = pinfo.stageline;
							fbdata[3] = 2;
                            fbdata[4] = pinfo.gftime;
                            if (!wait_write_serial(*(fcdata->fbserial)))
                            {
                                if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
									*(fcdata->markbit) |= 0x0800;
                                    gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }
                            }
                            else
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
							//begin to green flash
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
							{
								//send down time to configure tool
								memset(&dctd,0,sizeof(dctd));
								dctd.mode = 28;
								dctd.pattern = *(fcdata->patternid);
								dctd.lampcolor = 0x02;
								dctd.lamptime = pinfo.gftime;
								dctd.phaseid = pinfo.phaseid;
								dctd.stageline = pinfo.stageline;
								if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
								#endif
								}
							}
							#ifdef EMBED_CONFIGURE_TOOL
                            if (*(fcdata->markbit2) & 0x0200)
                            {
                                memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 28;
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x02;
                                dctd.lamptime = pinfo.gftime;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;   
                                if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
                            }
                            #endif
							if (pinfo.gftime > 0)
							{
								ngf = 0;
								while (1)
								{//green flash loop
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x03))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
										if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
										pinfo.cchan,0x03,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG 
										printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
									to.tv_sec = 0;
									to.tv_usec = 500000;
									select(0,NULL,NULL,NULL,&to);
									if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x02))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
									#endif
										gettimeofday(&ct,NULL);
										update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
										if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
										{
										#ifdef FULL_DETECT_DEBUG
											printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
										#endif
										}
										*(fcdata->markbit) |= 0x0800;
									}
									if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
										pinfo.cchan,0x02,fcdata->markbit))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("update channel err,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
									to.tv_sec = 0;
									to.tv_usec = 500000;
									select(0,NULL,NULL,NULL,&to);

									ngf += 1;
									if (ngf >= pinfo.gftime)
										break;
								}//green flash loop
							}//if (pinfo.gftime > 0)
							//end green flash

							//yellow lamp 
							if (1 == pinfo.cpcexist)
							{//have person channels
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cnpchan,0x01))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
									gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                   	if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
									*(fcdata->markbit) |= 0x0800;
								}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
															pinfo.cnpchan,0x01,fcdata->markbit))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
								#endif
								}
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cpchan,0x00))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
									gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                   	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
									*(fcdata->markbit) |= 0x0800;
                               	}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                    							pinfo.cpchan,0x00,fcdata->markbit))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
                               	}	
							}//have person channels
							else
							{//not have person channels
								if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x01))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("set color err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
									gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                   	if(SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
									*(fcdata->markbit) |= 0x0800;
                               	}
								if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus, \
                                   									pinfo.cchan,0x01,fcdata->markbit))
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
                               	}
							}//not have person channels
							if ((0 != pinfo.cchan[0]) && (pinfo.ytime > 0))
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x01;
									sinfo.time = pinfo.ytime;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						if (0 == pinfo.cnpchan[i])
                    						break;
                						for (j = 0; j < sinfo.chans; j++)
                						{
                    						if (0 == sinfo.csta[j])
                        						break;
                    						tcsta = sinfo.csta[j];
                    						tcsta &= 0xfc;
                    						tcsta >>= 2;
                    						tcsta &= 0x3f;
                    						if (pinfo.cnpchan[i] == tcsta)
                    						{
                        						sinfo.csta[j] &= 0xfc;
												sinfo.csta[j] |= 0x01; //00000001-yellow
												break;
                    						}
                						}
            						}
									for (i = 0; i < MAX_CHANNEL; i++)
                                	{
                                		if (0 == pinfo.cpchan[i])
                                        	break;
                                    	for (j = 0; j < sinfo.chans; j++)
                                    	{
                                        	if (0 == sinfo.csta[j])
                                            	break;
                                        	tcsta = sinfo.csta[j];
                                        	tcsta &= 0xfc;
                                        	tcsta >>= 2;
                                        	tcsta &= 0x3f;
                                        	if (pinfo.cpchan[i] == tcsta)
                                        	{
                                            	sinfo.csta[j] &= 0xfc;
												break;
                                        	}
                                    	}
                                	}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
							}

							fbdata[1] = 28;	
							fbdata[2] = pinfo.stageline;
							fbdata[3] = 1;
                            fbdata[4] = pinfo.ytime;
                            if (!wait_write_serial(*(fcdata->fbserial)))
                            {
                               	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                               	{
                               	#ifdef FULL_DETECT_DEBUG
                                   	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                               	#endif
									*(fcdata->markbit) |= 0x0800;
                                   	gettimeofday(&ct,NULL);
                                   	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                   	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                   	{
                                   	#ifdef FULL_DETECT_DEBUG
                                       	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                   	#endif
                                   	}
                               	}
                            }
                            else
                            {
                            #ifdef FULL_DETECT_DEBUG
                               	printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {   
                                //send down time to configure tool
                                memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 28;
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x01;
                                dctd.lamptime = pinfo.ytime;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;
                                if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                #endif
                                }
                            }
							#ifdef EMBED_CONFIGURE_TOOL
							if (*(fcdata->markbit2) & 0x0200)
							{
								memset(&dctd,0,sizeof(dctd));
                                dctd.mode = 28;
                                dctd.pattern = *(fcdata->patternid);
                                dctd.lampcolor = 0x01;
                                dctd.lamptime = pinfo.ytime;
                                dctd.phaseid = pinfo.phaseid;
                                dctd.stageline = pinfo.stageline;	
								if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
								{
								#ifdef FULL_DETECT_DEBUG
									printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
								#endif
								}
							}
							#endif
							sleep(pinfo.ytime);
							//end yellow lamp

							//red lamp
							if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.cchan,0x00))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("set lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																fcdata->softevent,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
								*(fcdata->markbit) |= 0x0800;
							}
							if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus,pinfo.cchan,\
										0x00,fcdata->markbit))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
							#endif
							}
							if ((0 != pinfo.cchan[0]) && (pinfo.rtime > 0))
							{
								if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
								{//report info to server actively
									sinfo.conmode = 28;
									sinfo.color = 0x00;
									sinfo.time = pinfo.rtime;
									sinfo.stage = pinfo.stageline;
									sinfo.cyclet = 0;
									sinfo.phase = 0;
									sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
									for (i = 0; i < MAX_CHANNEL; i++)
            						{
                						if (0 == pinfo.cchan[i])
                    						break;
                						for (j = 0; j < sinfo.chans; j++)
                						{
                    						if (0 == sinfo.csta[j])
                        						break;
                    						tcsta = sinfo.csta[j];
                    						tcsta &= 0xfc;
                    						tcsta >>= 2;
                    						tcsta &= 0x3f;
                    						if (pinfo.cchan[i] == tcsta)
                    						{
                        						sinfo.csta[j] &= 0xfc;
												break;
                    						}
                						}
            						}
									memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            						memset(sibuf,0,sizeof(sibuf));
            						if (SUCCESS != status_info_report(sibuf,&sinfo))
            						{
            						#ifdef FULL_DETECT_DEBUG
                						printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            						#endif
            						}
            						else
            						{
                						write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            						}
								}//report info to server actively
								if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
								{   
									//send down time to configure tool
									memset(&dctd,0,sizeof(dctd));
									dctd.mode = 28;
									dctd.pattern = *(fcdata->patternid);
									dctd.lampcolor = 0x00;
									dctd.lamptime = pinfo.rtime;
									dctd.phaseid = pinfo.phaseid;
									dctd.stageline = pinfo.stageline;
									if (SUCCESS != timedown_data_to_conftool(fcdata->sockfd,&dctd))
									{
									#ifdef FULL_DETECT_DEBUG
										printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
									#endif
									}
								}
								#ifdef EMBED_CONFIGURE_TOOL
								if (*(fcdata->markbit2) & 0x0200)
                                {
                                    //send down time to configure tool
                                   	memset(&dctd,0,sizeof(dctd));
                                    dctd.mode = 28;
                                    dctd.pattern = *(fcdata->patternid);
                                    dctd.lampcolor = 0x00;
                                    dctd.lamptime = pinfo.rtime;
                                    dctd.phaseid = pinfo.phaseid;
                                    dctd.stageline = pinfo.stageline; 
                                    if (SUCCESS != timedown_data_to_embed(fcdata->sockfd,&dctd))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("time down fail,File:%s,Line:%d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }		
								#endif
							}
							if (pinfo.rtime > 0)
							{
								fbdata[1] = 28;
								fbdata[2] = pinfo.stageline;
								fbdata[3] = 0;
                            	fbdata[4] = pinfo.rtime;
                            	if (!wait_write_serial(*(fcdata->fbserial)))
                            	{
                                	if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                	{
                                	#ifdef FULL_DETECT_DEBUG
                                    	printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                	#endif
										*(fcdata->markbit) |= 0x0800;
                                    	gettimeofday(&ct,NULL);
                                    	update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    	if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																		fcdata->softevent,fcdata->markbit))
                                    	{
                                    	#ifdef FULL_DETECT_DEBUG
                                        	printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    	#endif
                                    	}
                                	}
                            	}
                            	else
                            	{
                            	#ifdef FULL_DETECT_DEBUG
                                	printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            	#endif
                            	}
                                sleep(pinfo.rtime);
							}	
							//end red lamp
							*(fcdata->slnum) += 1;
                            *(fcdata->stageid) = \
                                tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
                            if (0 == (tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId))
                            {
                                *(fcdata->slnum) = 0;
                                *(fcdata->stageid) = \
                                    tscdata->timeconfig->TimeConfigList[rettl][*(fcdata->slnum)].StageId;
                            }
							//get info of next phase
							memset(&pinfo,0,sizeof(pinfo));
							if (SUCCESS != ms_get_phase_info(fcdata,tscdata,rettl,*(fcdata->slnum),&pinfo))
							{
							#ifdef FULL_DETECT_DEBUG
								printf("get phase info err,File: %s,Line: %d\n",__FILE__,__LINE__);
								output_log("detect control,get phase info err");
							#endif
								ms_end_part_child_thread();
								return FAIL;
							}
							*(fcdata->phaseid) = 0;
							*(fcdata->phaseid) |= (0x01 << (pinfo.phaseid - 1));
							if (SUCCESS != ms_set_lamp_color(*(fcdata->bbserial),pinfo.chan,0x02))
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("set green lamp err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
								gettimeofday(&ct,NULL);
                                update_event_list(fcdata->ec,fcdata->el,1,15,ct.tv_sec,fcdata->markbit);
                                if (SUCCESS != generate_event_file(fcdata->ec,fcdata->el,\
																fcdata->softevent,fcdata->markbit))
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
                                }
								*(fcdata->markbit) |= 0x0800;
                            }
							if (SUCCESS != update_channel_status(fcdata->sockfd,chanstatus,pinfo.chan,\
                                        0x02,fcdata->markbit))
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("update channel err,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }
							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x02;
								sinfo.time = 0;
								sinfo.stage = pinfo.stageline;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
								sinfo.phase |= (0x01 << (pinfo.phaseid - 1));
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
									if (0 == pinfo.chan[i])
										break;	
                					sinfo.chans += 1;
                					tcsta = pinfo.chan[i];
                					tcsta <<= 2;
                					tcsta &= 0xfc;
									tcsta |= 0x02;	
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
							}//report info to server actively

							fbdata[1] = 28;
							fbdata[2] = pinfo.stageline;
							fbdata[3] = 2;
                            fbdata[4] = 0;
                            if (!wait_write_serial(*(fcdata->fbserial)))
                            {
                                if (write(*(fcdata->fbserial),fbdata,sizeof(fbdata)) < 0)
                                {
                                #ifdef FULL_DETECT_DEBUG
                                    printf("write err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                #endif
									*(fcdata->markbit) |= 0x0800;
                                    gettimeofday(&ct,NULL);
                                    update_event_list(fcdata->ec,fcdata->el,1,16,ct.tv_sec,fcdata->markbit);
                                    if (SUCCESS!=generate_event_file(fcdata->ec,fcdata->el,\
																	fcdata->softevent,fcdata->markbit))
                                    {
                                    #ifdef FULL_DETECT_DEBUG
                                        printf("gen file err,File: %s,Line: %d\n",__FILE__,__LINE__);
                                    #endif
                                    }
                                }
                            }
                            else
                            {
                            #ifdef FULL_DETECT_DEBUG
                                printf("can't write,File: %s,Line: %d\n",__FILE__,__LINE__);
                            #endif
                            }

							gettimeofday(&ct,NULL);
                            update_event_list(fcdata->ec,fcdata->el,1,92,ct.tv_sec,fcdata->markbit);

							continue;
						}//step by step
						if ((1 == wllock) && (!strcmp("YF",wlbuf)))
						{//yellow flash
							dcred = 0;
							close = 0;
							dircon = 0;
                            firdc = 1;
                            fdirn = 0;
                            cdirn = 0;
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
                                memset(wltc,0,sizeof(wltc));
                                strcpy(wltc,"YFBEGIN");
                                write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
                            }
							if (0 == dcyfyes)
							{
								memset(&yfdata,0,sizeof(yfdata));
								yfdata.second = 0;
								yfdata.markbit = fcdata->markbit;
								yfdata.markbit2 = fcdata->markbit2;
								yfdata.serial = *(fcdata->bbserial);
								yfdata.sockfd = fcdata->sockfd;
								yfdata.cs = chanstatus;
#ifdef FLASH_DEBUG
								char szInfo[32] = {0};
								char szInfoT[64] = {0};
								snprintf(szInfo,sizeof(szInfo)-1,"%s",__FUNCTION__);
								snprintf(szInfoT,sizeof(szInfoT)-1,"%d",__LINE__);
								tsc_save_eventlog(szInfo,szInfoT);
#endif
								int yfret = pthread_create(&dcyfid,NULL,(void *)ms_yellow_flash,&yfdata);
								if (0 != yfret)
								{
								#ifdef FULL_DETECT_DEBUG
									printf("create thread err,File: %s,Line: %d\n",__FILE__,__LINE__);
									output_log("detect control,create yellow flash err");
								#endif
									ms_end_part_child_thread();
									return FAIL;
								}
								dcyfyes = 1;
							}
							
							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x05;
								sinfo.time = 0;
								sinfo.stage = 0;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					sinfo.chans += 1;
                					tcsta = i + 1;
                					tcsta <<= 2;
                					tcsta &= 0xfc;
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
							}//report info to server actively
							gettimeofday(&ct,NULL);
                            update_event_list(fcdata->ec,fcdata->el,1,93,ct.tv_sec,fcdata->markbit);

							continue;
						}//yellow flash
						if ((1 == wllock) && (!strcmp("RED",wlbuf)))
						{//all red
							dircon = 0;
                            firdc = 1;
                            fdirn = 0;
                            cdirn = 0;
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
                                memset(wltc,0,sizeof(wltc));
                                strcpy(wltc,"REDBEGIN");
                                write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
                            }
							if (1 == dcyfyes)
							{
								pthread_cancel(dcyfid);
								pthread_join(dcyfid,NULL);
								dcyfyes = 0;
							}
							close = 0;
							if (0 == dcred)
							{
								new_all_red(&ardata);	
								dcred = 1;
							}
							
							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x00;
								sinfo.time = 0;
								sinfo.stage = 0;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					sinfo.chans += 1;
                					tcsta = i + 1;
                					tcsta <<= 2;
                					tcsta &= 0xfc;
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
							}//report info to server actively
							gettimeofday(&ct,NULL);
                            update_event_list(fcdata->ec,fcdata->el,1,94,ct.tv_sec,fcdata->markbit);

							continue;
						}//all red
						if ((1 == wllock) && (!strcmp("CLO",wlbuf)))
						{//all close
							dircon = 0;
                            firdc = 1;
                            fdirn = 0;
                            cdirn = 0;
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
                                memset(wltc,0,sizeof(wltc));
                                strcpy(wltc,"CLOBEGIN");
                                write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
                            }
							if (1 == dcyfyes)
							{
								pthread_cancel(dcyfid);
								pthread_join(dcyfid,NULL);
								dcyfyes = 0;
							}
							dcred = 0;
							if (0 == close)
							{
								new_all_close(&acdata);	
								close = 1;
							}
							
							if ((!(*(fcdata->markbit) & 0x1000)) && (!(*(fcdata->markbit) & 0x8000)))
							{//report info to server actively
								sinfo.conmode = 28;
								sinfo.color = 0x04;
								sinfo.time = 0;
								sinfo.stage = 0;
								sinfo.cyclet = 0;
								sinfo.phase = 0;
															
								sinfo.chans = 0;
            					memset(sinfo.csta,0,sizeof(sinfo.csta));
            					csta = sinfo.csta;
            					for (i = 0; i < MAX_CHANNEL; i++)
            					{
                					sinfo.chans += 1;
                					tcsta = i + 1;
                					tcsta <<= 2;
                					tcsta &= 0xfc;
                					*csta = tcsta;
                					csta++;
            					}
								memcpy(fcdata->sinfo,&sinfo,sizeof(statusinfo_t));
            					memset(sibuf,0,sizeof(sibuf));
            					if (SUCCESS != status_info_report(sibuf,&sinfo))
            					{
            					#ifdef FULL_DETECT_DEBUG
                					printf("status info pack err,File:%s,Line:%d\n",__FILE__,__LINE__);
            					#endif
            					}
            					else
            					{
                					write(*(fcdata->sockfd->csockfd),sibuf,sizeof(sibuf));
            					}
							}//report info to server actively
							continue;
						}//all close 
						if ((1 == wllock) && (!strncmp("SP",wlbuf,2)))
						{//stage phase
							unsigned char	staid = 0;
							if (!strcmp("SP11",wlbuf))
							{
								staid = 0x01; 
							}
							else if (!strcmp("SP12",wlbuf))
                            {
                                staid = 0x02;
                            }
							else if (!strcmp("SP13",wlbuf))
                            {
                                staid = 0x03;
                            }
							else if (!strcmp("SP14",wlbuf))
                            {
                                staid = 0x04;
                            }
							else if (!strcmp("SP15",wlbuf))
                            {
                                staid = 0x05;
                            }
							else if (!strcmp("SP16",wlbuf))
                            {
                                staid = 0x06;
                            }
							else if (!strcmp("SP17",wlbuf))
                            {
                                staid = 0x07;
                            }
							else if (!strcmp("SP18",wlbuf))
							{
								staid = 0x08;
							}
							memset(&mdt,0,sizeof(markdata_c));
							mdt.redl = &dcred;
							mdt.closel = &close;
							mdt.rettl = &rettl;
							mdt.dircon = &dircon;
							mdt.firdc = &firdc;
							mdt.yfl = &dcyfyes;
							mdt.yfid = &dcyfid;
							mdt.ardata = &ardata;
							mdt.fcdata = fcdata;
							mdt.tscdata = tscdata;
							mdt.chanstatus = chanstatus;
							mdt.sinfo = &sinfo;
							ms_mobile_jp_control(&mdt,staid,&pinfo,fdirch);
							dircon = 0;
                            firdc = 1;
							fdirn = 0;
							cdirn = 0;
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
                                memset(wltc,0,sizeof(wltc));
                                strncpy(wltc,wlbuf,4);
								strcat(wltc,"BEGIN");	
                                write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
                            }
							continue;
						}//stage phase
						if ((1 == wllock) && (!strncmp("DIR",wlbuf,3)))
						{//Direction control
							dircon = 1;
							memset(cdirch,0,sizeof(cdirch));
							if (!strcmp("DIR1",wlbuf))
							{
								cdirn = 1;
								j = 0;
								for(i = 0; i < MAX_CHANNEL; i++)
								{
									if (0 == dirch[0][i])
										break;
									cdirch[j] = dirch[0][i];
									j++;
								}
							}
							else if (!strcmp("DIR2",wlbuf))
                            {
								cdirn = 2;
                                j = 0;
                                for(i = 0; i < MAX_CHANNEL; i++)
                                {
                                    if (0 == dirch[1][i])
                                        break;
                                    cdirch[j] = dirch[1][i];
                                    j++;
                                }
                            }						
							else if (!strcmp("DIR3",wlbuf))
                            {
								cdirn = 3;
                                j = 0;
                                for(i = 0; i < MAX_CHANNEL; i++)
                                {
                                    if (0 == dirch[2][i])
                                        break;
                                    cdirch[j] = dirch[2][i];
                                    j++;
                                }
                            }
							else if (!strcmp("DIR4",wlbuf))
                            {
								cdirn = 4;
                                j = 0;
                                for(i = 0; i < MAX_CHANNEL; i++)
                                {
                                    if (0 == dirch[3][i])
                                        break;
                                    cdirch[j] = dirch[3][i];
                                    j++;
                                }
                            }
							else if (!strcmp("DIR5",wlbuf))
                            {
								cdirn = 5;
                                j = 0;
                                for(i = 0; i < MAX_CHANNEL; i++)
                                {
                                    if (0 == dirch[4][i])
                                        break;
                                    cdirch[j] = dirch[4][i];
                                    j++;
                                }
                            }
							else if (!strcmp("DIR6",wlbuf))
                            {
								cdirn = 6;
                                j = 0;
                                for(i = 0; i < MAX_CHANNEL; i++)
                                {
                                    if (0 == dirch[5][i])
                                        break;
                                    cdirch[j] = dirch[5][i];
                                    j++;
                                }
                            }
							else if (!strcmp("DIR7",wlbuf))
                            {
								cdirn = 7;
                                j = 0;
                                for(i = 0; i < MAX_CHANNEL; i++)
                                {
                                    if (0 == dirch[6][i])
                                        break;
                                    cdirch[j] = dirch[6][i];
                                    j++;
                                }
                            }						
							else if (!strcmp("DIR8",wlbuf))
                            {
								cdirn = 8;
                                j = 0;
                                for(i = 0; i < MAX_CHANNEL; i++)
                                {
                                    if (0 == dirch[7][i])
                                        break;
                                    cdirch[j] = dirch[7][i];
                                    j++;
                                }
                            }

							if (fdirn == cdirn) //two dir control is same
							{
								continue;
							}	
							memset(&mdt,0,sizeof(markdata_c));
							mdt.redl = &dcred;
							mdt.closel = &close;
							mdt.rettl = &rettl;
							mdt.dircon = &dircon;
							mdt.firdc = &firdc;
							mdt.yfl = &dcyfyes;
							mdt.yfid = &dcyfid;
							mdt.ardata = &ardata;
							mdt.fcdata = fcdata;
							mdt.tscdata = tscdata;
							mdt.chanstatus = chanstatus;
							mdt.sinfo = &sinfo;
							ms_mobile_direct_control(&mdt,&pinfo,cdirch,fdirch);
							firdc = 0;
							fdirn = cdirn;
							cdirn = 0;
							memset(fdirch,0,sizeof(fdirch));
							for (i = 0; i < MAX_CHANNEL; i++)
							{
								if (0 == cdirch[i])
									break;
								fdirch[i] = cdirch[i];
							}
							if ((*(fcdata->markbit) & 0x0002) && (*(fcdata->markbit) & 0x0010))
                            {
                                memset(wltc,0,sizeof(wltc));
                                strncpy(wltc,wlbuf,4);
                                strcat(wltc,"BEGIN");
                                write(*(fcdata->sockfd->ssockfd),wltc,sizeof(wltc));
                            }
							continue;
						}//Direction control
                    }//wireless lock or unlock is suessfully only when key lock or unlock is not valid;
				}//wireless terminal traffic control
			}//if (FD_ISSET(*(fcdata->conpipe),&nread))
		}//cpret > 0
	}//while loop
	
	return SUCCESS;	
}



